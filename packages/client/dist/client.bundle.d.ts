// Generated by dts-bundle-generator v8.0.1

import { Component, IComponent, IWorld } from 'bitecs';
import { AnimationAction, AnimationClip, AnimationMixer, Group, Object3D, PerspectiveCamera, Ray, Scene, Texture, WebGLRenderer } from 'three';
import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader';

export declare const NULL_EID = 0;
export declare const INITIAL_VERSION = 0;
export declare const LOCAL_VERSION = -1;
export declare const REMOVAL_INTERVAL = 3;
export declare const SystemOrder: Readonly<{
	Time: 0;
	EventHandling: 100;
	Setup: 200;
	BeforeMatricesUpdate: 300;
	MatricesUpdate: 400;
	BeforeRender: 500;
	Render: 600;
	AfterRender: 700;
	PostProcess: 800;
	TearDown: 900;
}>;
export type Prefab = (world: IWorld, params: object) => number;
export type Serializer = (world: IWorld, eid: number) => any;
export type Deserializer = (world: IWorld, eid: number, data: any, updatedAt: number) => void;
export type NetworkDeserializer = (world: IWorld, eid: number, data: any, updatedAt: number) => void;
export type DiffChecker = (world: IWorld, eid: number, cache: any, updatedAt: number) => boolean;
export type SerializerFunctions = {
	deserializer: Deserializer;
	diffChecker: DiffChecker;
	networkDeserializer: NetworkDeserializer;
	serializer: Serializer;
};
export type System = (world: IWorld) => void;
export declare const NETWORK_INTERVAL: number;
export declare const F32_EPSILON = 0.00001;
export declare const TIME_EPSILON = 2;
export declare class App {
	private systems;
	private world;
	private networkAdapter;
	private streamAdapter;
	readonly userId: string;
	constructor(params: {
		canvas: HTMLCanvasElement;
		roomId: string;
		userId?: string;
		username?: string;
	});
	private init;
	registerSystem(system: System, orderPriority?: number): void;
	deregisterSystem(system: System): void;
	getSystemOrderPriority(system: System): number;
	tick(): void;
	start(): void;
	stop(): void;
	getWorld(): IWorld;
}
export declare const AudioContextComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const AudioContextSuspended: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const AudioContextResuming: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class AudioContextProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): AudioContextProxy;
	allocate(context: AudioContext): void;
	free(): void;
	get context(): AudioContext;
}
export declare const AudioSource: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type AudioSourceNode = MediaStreamAudioSourceNode | MediaElementAudioSourceNode;
export declare class AudioSourceProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): AudioSourceProxy;
	allocate(source: AudioSourceNode, gain: GainNode, panner: PannerNode): void;
	free(): void;
	get gain(): GainNode;
	get source(): AudioSourceNode;
	get panner(): PannerNode;
}
export declare const AudioDestination: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Avatar: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const BVHGenerator: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const HasBVH: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const PerspectiveCameraComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class PerspectiveCameraProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): PerspectiveCameraProxy;
	allocate(camera: PerspectiveCamera): void;
	free(): void;
	get camera(): PerspectiveCamera;
}
export declare const SceneCamera: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const FpsCamera: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Canvas: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class CanvasProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): CanvasProxy;
	allocate(canvas: HTMLCanvasElement): void;
	free(): void;
	get canvas(): HTMLCanvasElement;
}
export declare class EntityRootGroup extends Group {
	isEntityRootGroup: boolean;
	type: string;
	constructor();
}
export declare const EntityObject3D: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class EntityObject3DProxy {
	private static instance;
	private eid;
	private rootObjectMap;
	private objectsMap;
	private groupMap;
	private constructor();
	static get(eid: number): EntityObject3DProxy;
	allocate(): void;
	free(): void;
	get root(): Object3D;
	set root(obj: Object3D);
	get objects(): Object3D[];
	get group(): EntityRootGroup;
}
export declare const GltfRoot: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class GltfRootProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): GltfRootProxy;
	allocate(root: Group): void;
	free(): void;
	get root(): Group;
}
export declare const GltfAssetLoader: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class GltfAssetLoaderProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): GltfAssetLoaderProxy;
	allocate(url: string): void;
	free(): void;
	get url(): string;
}
export declare const GltfSceneLoader: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class GltfSceneLoaderProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): GltfSceneLoaderProxy;
	allocate(url: string): void;
	free(): void;
	get url(): string;
}
export declare const Grabbable: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Grabbed: import("bitecs").ComponentType<{
	distance: "f32";
}>;
export declare const GrabbedByFirstSource: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const GrabbedBySecondSource: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const FirstSourceInteractable: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const FirstSourceInteracted: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const FirstSourceInteractionTriggerEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const FirstSourceInteractionLeaveEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SecondSourceInteractable: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SecondSourceInteracted: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SecondSourceInteractionTriggerEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SecondSourceInteractionLeaveEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const InputSource: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const FirstInputSource: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SecondInputSource: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const InputSourceTriggered: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const InputSourceReleased: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare enum KeyEventType {
	Down = 0,
	Up = 1
}
export type KeyEventValue = {
	code: number;
	type: KeyEventType;
};
export declare const KeyEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class KeyEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): KeyEventProxy;
	allocate(): void;
	add(type: KeyEventType, code: number): void;
	free(): void;
	get events(): KeyEventValue[];
}
export declare const KeyEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const KeyHold: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const LinearMoveBackward: import("bitecs").ComponentType<{
	speed: "f32";
}>;
export declare const LinearMoveForward: import("bitecs").ComponentType<{
	speed: "f32";
}>;
export declare const LinearMoveLeft: import("bitecs").ComponentType<{
	speed: "f32";
}>;
export declare const LinearMoveRight: import("bitecs").ComponentType<{
	speed: "f32";
}>;
export declare const LinearTranslate: import("bitecs").ComponentType<{
	duration: "f32";
	targetX: "f32";
	targetY: "f32";
	targetZ: "f32";
}>;
export declare const LinearRotate: import("bitecs").ComponentType<{
	duration: "f32";
	targetX: "f32";
	targetY: "f32";
	targetZ: "f32";
	targetW: "f32";
}>;
export declare const LinearScale: import("bitecs").ComponentType<{
	duration: "f32";
	targetX: "f32";
	targetY: "f32";
	targetZ: "f32";
}>;
export declare const Loading: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MicRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MicConnectedEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MicConnectedEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MessageSender: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MessageSenderProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MessageSenderProxy;
	allocate(data: any): void;
	free(): void;
	get data(): any;
}
export declare const MessageEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type MessageEventValue = {
	data: any;
};
export declare class MessageEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MessageEventProxy;
	allocate(): void;
	add(data: any): void;
	free(): void;
	get events(): MessageEventValue[];
}
export declare const MessageEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MixerAnimation: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MixerAnimationProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MixerAnimationProxy;
	allocate(mixer: AnimationMixer): void;
	free(): void;
	get mixer(): AnimationMixer;
}
export declare const HasAnimations: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ActiveAnimations: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class ActiveAnimationsProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): ActiveAnimationsProxy;
	allocate(): void;
	add(action: AnimationAction): void;
	clear(): void;
	remove(action: AnimationAction): void;
	free(): void;
	get actions(): AnimationAction[];
}
export declare const ActiveAnimationsUpdated: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const LazyActiveAnimations: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type LazyActiveAnimationsValue = {
	index: number;
	paused: boolean;
	startedAt: number;
};
export declare class LazyActiveAnimationsProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): LazyActiveAnimationsProxy;
	allocate(): void;
	add(index: number, startedAt: number, paused: boolean): void;
	clear(): void;
	free(): void;
	get animations(): LazyActiveAnimationsValue[];
}
export declare enum MouseButtonEventType {
	Down = 0,
	Up = 1
}
export declare enum MouseButtonType {
	Left = 0,
	Middle = 1,
	Right = 2
}
export type MouseButtonEventValue = {
	button: MouseButtonType;
	x: number;
	y: number;
	type: MouseButtonEventType;
};
export declare const MouseButtonEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MouseButtonEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MouseButtonHold: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MouseButtonEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MouseButtonEventProxy;
	allocate(): void;
	add(type: MouseButtonEventType, button: MouseButtonType, x: number, y: number): void;
	free(): void;
	get events(): MouseButtonEventValue[];
}
export declare const MouseMoveEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MouseMoveEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type MouseMoveEventValue = {
	x: number;
	y: number;
};
export declare class MouseMoveEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MouseMoveEventProxy;
	allocate(): void;
	add(x: number, y: number): void;
	free(): void;
	get events(): MouseMoveEventValue[];
}
export declare const MousePosition: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MousePositionProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MousePositionProxy;
	allocate(): void;
	free(): void;
	update(x: number, y: number): void;
	get x(): number;
	get y(): number;
}
export declare const CurrentMousePosition: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const PreviousMousePosition: import("bitecs").ComponentType<import("bitecs").ISchema>;
// Generated by dts-bundle-generator v8.0.1
export type Callback = (payload?: any) => void;
declare class StateAdapter {
	private channel;
	private eventListenerMap;
	readonly userId: string;
	constructor(params: {
		roomId: string;
		url?: string;
		userId: string;
		username?: string;
	});
	addEventListener(name: string, callback: Callback): void;
	removeEventListener(name: string): void;
	push(name: string, data: any): void;
}
export declare enum NetworkMessageType {
	AddComponent = "add_component",
	Broadcast = "broadcast",
	CreateEntity = "create_entity",
	RemoveEntity = "remove_entity",
	RemoveComponent = "remove_component",
	TextMessage = "text_message",
	UpdateComponent = "update_component",
	UserJoined = "user_joined",
	UserLeft = "user_left",
	UsernameChange = "username_change",
	UsersList = "users_list"
}
export declare enum NetworkedType {
	Local = "local",
	Remote = "remote",
	Shared = "shared"
}
export type CacheData = any;
export type NetworkedComponent = {
	cache: CacheData;
	owner: string;
	updatedAt: number;
	version: number;
};
export declare const Local: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Remote: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Shared: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Networked: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class NetworkedProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): NetworkedProxy;
	allocate(networkId: string, type: NetworkedType, creator: string, prefabName: string, prefabParams: any): void;
	free(): void;
	hasNetworkedComponent(key: string): boolean;
	initNetworkedComponent(key: string, cache: CacheData, owner: string, updatedAt: number, version: number): void;
	updateNetworkedComponent(key: string, cache: CacheData, owner: string, updatedAt: number, version: number): void;
	getNetworkedComponent(key: string): NetworkedComponent;
	removeNetworkedComponent(key: string): void;
	get creator(): string;
	get networkId(): string;
	get prefabName(): string;
	get prefabParams(): any;
	get type(): NetworkedType;
}
export declare const NetworkedEntityManager: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class NetworkedEntityManagerProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): NetworkedEntityManagerProxy;
	allocate(): void;
	free(): void;
	add(eid: number, networkId: string, userId: string): void;
	remove(networkId: string): void;
	getNetworkId(eid: number): string;
	getNetworkIdsByUserId(userId: string): string[];
	clearNetworkIdsByUserId(userId: string): void;
	getEid(networkId: string): number;
	deleted(networkId: string): boolean;
}
export declare const StateClient: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class StateClientProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): StateClientProxy;
	allocate(adapter: StateAdapter): void;
	free(): void;
	get adapter(): StateAdapter;
}
export declare const NetworkEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type NetworkEventValue = {
	data: any;
	type: NetworkMessageType;
};
export declare class NetworkEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): NetworkEventProxy;
	allocate(): void;
	add(type: NetworkMessageType, data: any): void;
	free(): void;
	get events(): NetworkEventValue[];
}
export declare const NetworkEventReceiver: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkEventReceiverReady: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const TextMessageNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const UserNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const EntityNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ComponentNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const BroadcastNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkEventSender: import("bitecs").ComponentType<{
	lastSendTime: "f32";
}>;
export declare const NetworkedPosition: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkedQuaternion: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkedScale: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkedMixerAnimation: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const BroadcastRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class BroadcastRequestorProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): BroadcastRequestorProxy;
	allocate(data: any): void;
	free(): void;
	get data(): any;
}
export declare const NullComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Peers: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type PeerValue = {
	joined: boolean;
	previousUsername: string;
	username: string;
};
export declare class PeersProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): PeersProxy;
	allocate(): void;
	free(): void;
	get peers(): Map<string, PeerValue>;
}
export declare const PeersManager: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const UsernameChangeRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class UsernameChangeRequestorProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): UsernameChangeRequestorProxy;
	allocate(username: string): void;
	free(): void;
	get username(): string;
}
export declare const Pointer: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class PointerProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): PointerProxy;
	allocate(): void;
	update(x: number, y: number): void;
	free(): void;
	get x(): number;
	get y(): number;
}
export declare const Prefabs: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class PrefabsProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): PrefabsProxy;
	allocate(): void;
	free(): void;
	register(key: string, prefab: Prefab): void;
	deregister(key: string): void;
	get(key: string): Prefab;
}
export declare const RayComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class RayProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): RayProxy;
	allocate(ray: Ray): void;
	free(): void;
	get ray(): Ray;
}
export declare const ActiveRay: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const FirstRay: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SecondRay: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Raycastable: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Raycasted: import("bitecs").ComponentType<{
	distance: "f32";
}>;
export declare const RaycastedByFirstRay: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const RaycastedBySecondRay: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const RaycastedNearest: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const RaycastedNearestByFirstRay: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const RaycastedNearestBySecondRay: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const EntityRemoval: import("bitecs").ComponentType<{
	interval: "ui8";
}>;
export declare const Renderer: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class RendererProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): RendererProxy;
	allocate(renderer: WebGLRenderer): void;
	free(): void;
	get renderer(): WebGLRenderer;
}
export declare const RoomId: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class RoomIdProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): RoomIdProxy;
	allocate(roomId: string): void;
	free(): void;
	get roomId(): string;
}
export declare const SceneComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const InScene: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class SceneProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): SceneProxy;
	allocate(scene: Scene): void;
	free(): void;
	get scene(): Scene;
}
export declare const SceneObject: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SceneEnvironmentMapLoader: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class SceneEnvironmentMapLoaderProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): SceneEnvironmentMapLoaderProxy;
	allocate(url: string): void;
	free(): void;
	get url(): string;
}
export declare const Selectable: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Selected: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare enum SelectedType {
	Deselected = 0,
	Selected = 1
}
export declare const SelectedEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type SelectedEventValue = {
	eid: number;
	type: SelectedType;
};
export declare class SelectedEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): SelectedEventProxy;
	allocate(): void;
	add(type: SelectedType, eid: number): void;
	free(): void;
	get events(): SelectedEventValue[];
}
export declare const SelectedEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Serializers: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class SerializersProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): SerializersProxy;
	allocate(): void;
	free(): void;
	register(component: IComponent, serializers: SerializerFunctions): void;
	deregister(component: IComponent): void;
	get(component: IComponent): SerializerFunctions;
	has(component: IComponent): boolean;
}
export declare const ComponentKeys: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class ComponentKeysProxy {
	private static instance;
	private eid;
	private toComponents;
	private toKeys;
	private constructor();
	static get(eid: number): ComponentKeysProxy;
	allocate(): void;
	free(): void;
	register(key: string, component: IComponent): void;
	deregister(key: string): void;
	getComponent(key: string): IComponent;
	hasComponent(key: string): boolean;
	getKey(component: IComponent): string;
	hasKey(component: IComponent): boolean;
}
declare class StreamAdapter {
	private device;
	private socket;
	private connected;
	private joined;
	private recvTransport;
	private sendTransport;
	private connectedEventListener;
	private joinedEventListener;
	private disconnectedEventListener;
	private newPeerEventListener;
	private joinedPeerEventListener;
	private leftPeerEventListener;
	private exitedPeerEventListener;
	private newConsumerEventListener;
	private consumerInfoQueue;
	constructor(serverUrl?: string);
	connect(roomId: string, peerId: string): Promise<{
		id: string;
		joined: boolean;
	}[]>;
	on(eventName: string, callback: (...args: any[]) => void): void;
	off(eventName: string): void;
	private handleConsumerInfos;
	exit(): Promise<void>;
	join(): Promise<void>;
	leave(): Promise<void>;
	private createSendTransport;
	private createRecvTransport;
	produce(track: MediaStreamTrack): Promise<void>;
}
export declare enum StreamMessageType {
	Connected = "connected",
	Joined = "joined",
	Disconnected = "disconnected",
	ExitedPeer = "exitedPeer",
	JoinedPeer = "joinedPeer",
	LeftPeer = "leftPeer",
	NewConsumer = "newConsumer",
	NewPeer = "newPeer"
}
export declare const StreamClient: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class StreamClientProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): StreamClientProxy;
	allocate(adapter: StreamAdapter): void;
	free(): void;
	get adapter(): StreamAdapter;
}
export declare const StreamConnectRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamJoinRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamLeaveRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type StreamEventValue = {
	data: any;
	type: StreamMessageType;
};
export declare class StreamEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): StreamEventProxy;
	allocate(): void;
	add(type: StreamMessageType, data: any): void;
	free(): void;
	get events(): StreamEventValue[];
}
export declare const StreamEventReceiver: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamEventReceiverReady: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ConnectedStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const DisconnectedStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const JoinedStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ExitedPeerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const JoinedPeerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const LeftPeerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NewConsumerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NewPeerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamRemotePeers: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type StreamRemotePeersValue = Map<string, {
	id: string;
	joined: boolean;
}>;
export declare class StreamRemotePeersProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): StreamRemotePeersProxy;
	allocate(): void;
	free(): void;
	remove(id: string): void;
	get peers(): StreamRemotePeersValue;
}
export declare const StreamRemotePeerRegister: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Time: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class TimeProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): TimeProxy;
	allocate(): void;
	free(): void;
	get delta(): number;
	set delta(delta: number);
	get elapsed(): number;
	set elapsed(elapsed: number);
	get timestamp(): number;
	set timestamp(timestamp: number);
}
export declare const Timestamp: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class TimestampProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): TimestampProxy;
	allocate(): void;
	free(): void;
	get timestamp(): number;
	set timestamp(timestamp: number);
}
export declare enum TouchEventType {
	Cancel = 0,
	End = 1,
	Start = 2
}
export type TouchEventValue = {
	type: TouchEventType;
	x: number;
	y: number;
};
export declare const TouchEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const TouchEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const TouchHold: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class TouchEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): TouchEventProxy;
	allocate(): void;
	add(type: TouchEventType, x: number, y: number): void;
	free(): void;
	get events(): TouchEventValue[];
}
export declare const TouchMoveEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const TouchMoveEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type TouchMoveEventValue = {
	x: number;
	y: number;
};
export declare class TouchMoveEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): TouchMoveEventProxy;
	allocate(): void;
	add(x: number, y: number): void;
	free(): void;
	get events(): TouchMoveEventValue[];
}
export declare const TouchPosition: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class TouchPositionProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): TouchPositionProxy;
	allocate(): void;
	free(): void;
	update(x: number, y: number): void;
	get x(): number;
	get y(): number;
}
export declare const TransformUpdated: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const UserId: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class UserIdProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): UserIdProxy;
	allocate(userId: string): void;
	free(): void;
	get userId(): string;
}
export declare const XRSessionComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class XRSessionProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): XRSessionProxy;
	allocate(): void;
	free(): void;
	get mode(): XRSessionMode | null;
	set mode(mode: XRSessionMode);
	get session(): XRSession | null;
	set session(session: XRSession | null);
}
export declare const XRFrameComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class XRFrameProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): XRFrameProxy;
	allocate(): void;
	free(): void;
	get frame(): XRFrame | null;
	set frame(frame: XRFrame | null);
}
export declare const InvisibleInAR: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const XRController: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class XRControllerProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): XRControllerProxy;
	allocate(controller: Group): void;
	free(): void;
	get controller(): Group;
}
export declare const FirstXRController: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SecondXRController: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ActiveXRController: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare enum WebXRSessionEventType {
	End = 0,
	Start = 1
}
export type WebXRSessionEventValue = {
	mode: XRSessionMode;
	session: XRSession;
	type: WebXRSessionEventType;
};
export declare const WebXRSessionEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class WebXRSessionEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): WebXRSessionEventProxy;
	allocate(): void;
	add(type: WebXRSessionEventType, mode: XRSessionMode, session: XRSession): void;
	free(): void;
	get events(): WebXRSessionEventValue[];
}
export declare const WebXRSessionEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const WebXRSessionManager: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare enum XRControllerType {
	First = 0,
	Second = 1
}
export declare enum XRControllerConnectionEventType {
	Connected = "connected",
	Disconnected = "disconnected"
}
export type XRControllerConnectionEventValue = {
	controller: XRControllerType;
	type: XRControllerConnectionEventType;
};
export declare const XRControllerConnectionEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class XRControllerConnectionEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): XRControllerConnectionEventProxy;
	allocate(): void;
	add(controller: XRControllerType, type: XRControllerConnectionEventType): void;
	free(): void;
	get events(): XRControllerConnectionEventValue[];
}
export declare const XRControllerConnectionEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare enum XRControllerSelectEventType {
	End = "selectend",
	Start = "selectstart"
}
export type XRControllerSelectEventValue = {
	controller: XRControllerType;
	type: XRControllerSelectEventType;
};
export declare const XRControllerSelectEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class XRControllerSelectEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): XRControllerSelectEventProxy;
	allocate(): void;
	add(controller: XRControllerType, type: XRControllerSelectEventType): void;
	free(): void;
	get events(): XRControllerSelectEventValue[];
}
export declare const XRControllerSelectEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const WindowResizeEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const WindowResizeEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const WindowSize: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type SerializedMixerAnimation = {
	index: number;
	paused: boolean;
	time: number;
}[];
export declare const mixerAnimationSerializers: {
	deserializer: (world: IWorld, eid: number, data: SerializedMixerAnimation, updatedAt: number) => void;
	diffChecker: (world: IWorld, eid: number, cache: SerializedMixerAnimation, updatedAt: number) => boolean;
	networkDeserializer: (world: IWorld, eid: number, data: SerializedMixerAnimation, updatedAt: number) => void;
	serializer: (world: IWorld, eid: number) => SerializedMixerAnimation;
};
export type SerializedPosition = [
	x: number,
	y: number,
	z: number
];
export type SerializedQuaternion = [
	x: number,
	y: number,
	z: number,
	w: number
];
export type SerializedScale = [
	x: number,
	y: number,
	z: number
];
export declare const positionSerializers: {
	deserializer: (world: IWorld, eid: number, data: SerializedPosition) => void;
	diffChecker: (world: IWorld, eid: number, cache: SerializedPosition) => boolean;
	networkDeserializer: (world: IWorld, eid: number, data: SerializedPosition) => void;
	serializer: (world: IWorld, eid: number) => SerializedPosition;
};
export declare const quaternionSerializers: {
	deserializer: (world: IWorld, eid: number, data: SerializedQuaternion) => void;
	diffChecker: (world: IWorld, eid: number, cache: SerializedQuaternion) => boolean;
	networkDeserializer: (world: IWorld, eid: number, data: SerializedQuaternion) => void;
	serializer: (world: IWorld, eid: number) => SerializedQuaternion;
};
export declare const scaleSerializers: {
	deserializer: (world: IWorld, eid: number, data: SerializedScale) => void;
	diffChecker: (world: IWorld, eid: number, cache: SerializedScale) => boolean;
	networkDeserializer: (world: IWorld, eid: number, data: SerializedScale) => void;
	serializer: (world: IWorld, eid: number) => SerializedScale;
};
export declare const resumeAudioContextSystem: (world: IWorld) => void;
export declare const generateBVHSystem: (world: IWorld) => void;
export declare const canvasSystem: (world: IWorld) => void;
export declare const entityObject3DSystem: (world: IWorld) => void;
export declare const entityRemovalSystem: (world: IWorld) => void;
export declare const fpsCameraSystem: (world: IWorld) => void;
export declare const gltfSystem: (world: IWorld) => void;
export declare const gltfAssetLoadSystem: (world: IWorld) => void;
export declare const gltfSceneLoadSystem: (world: IWorld) => void;
export declare const grabSystem: (world: IWorld) => void;
export declare const grabbedObjectsRayTrackSystem: (world: IWorld) => void;
export declare const interactSystem: (world: IWorld) => void;
export declare const clearInteractionSystem: (world: IWorld) => void;
export declare const keyEventHandleSystem: (world: IWorld) => void;
export declare const keyEventClearSystem: (world: IWorld) => void;
export declare const lazilyActivateAnimationSystem: (world: IWorld) => void;
export declare const linearMoveSystem: (world: IWorld) => void;
export declare const linearTransformSystem: (world: IWorld) => void;
export declare const micRequestSystem: (world: IWorld) => void;
export declare const micEventClearSystem: (world: IWorld) => void;
export declare const messageSendSystem: (world: IWorld) => void;
export declare const messageEventReceiveSystem: (world: IWorld) => void;
export declare const clearMessageEventSystem: (world: IWorld) => void;
export declare const mixerAnimationSystem: (world: IWorld) => void;
export declare const clearActiveAnimationsUpdatedSystem: (world: IWorld) => void;
export declare const mouseButtonEventHandleSystem: (world: IWorld) => void;
export declare const mouseButtonEventClearSystem: (world: IWorld) => void;
export declare const mouseMoveEventHandleSystem: (world: IWorld) => void;
export declare const mouseMoveEventClearSystem: (world: IWorld) => void;
export declare const mousePositionToPointerSystem: (world: IWorld) => void;
export declare const mousePositionTrackSystem: (world: IWorld) => void;
export declare const mouseInteractionTriggerSystem: (world: IWorld) => void;
export declare const networkedSystem: (world: IWorld) => void;
export declare const networkedEntitySystem: (world: IWorld) => void;
export declare const networkEventHandleSystem: (world: IWorld) => void;
export declare const networkEventClearSystem: (world: IWorld) => void;
export declare const networkSendSystem: (world: IWorld) => void;
export declare const peerSystem: (world: IWorld) => void;
export declare const perspectiveCameraSystem: (world: IWorld) => void;
export declare const positionalAudioSystem: (world: IWorld) => void;
export declare const prefabsSystem: (world: IWorld) => void;
export declare const pointerToRaySystem: (world: IWorld) => void;
export declare const raycastSystem: (world: IWorld) => void;
export declare const clearRaycastedSystem: (world: IWorld) => void;
export declare const renderSystem: (world: IWorld) => void;
export declare const rendererSystem: (world: IWorld) => void;
export declare const sceneSystem: (world: IWorld) => void;
export declare const sceneEnvironmentMapLoadSystem: (world: IWorld) => void;
export declare const selectSystem: (world: IWorld) => void;
export declare const selectedEventClearSystem: (world: IWorld) => void;
export declare const streamConnectionSystem: (world: IWorld) => void;
export declare const streamEventHandleSystem: (world: IWorld) => void;
export declare const streamEventClearSystem: (world: IWorld) => void;
export declare const streamRemotePeerRegisterSystem: (world: IWorld) => void;
export declare const timeSystem: (world: IWorld) => void;
export declare const touchEventHandleSystem: (world: IWorld) => void;
export declare const touchEventClearSystem: (world: IWorld) => void;
export declare const touchInteractionTriggerSystem: (world: IWorld) => void;
export declare const touchMoveEventHandleSystem: (world: IWorld) => void;
export declare const touchMoveEventClearSystem: (world: IWorld) => void;
export declare const touchPositionToPointerSystem: (world: IWorld) => void;
export declare const touchPositionTrackSystem: (world: IWorld) => void;
export declare const clearTransformUpdatedSystem: (world: IWorld) => void;
export declare const updateMatricesSystem: (world: IWorld) => void;
export declare const webxrCameraSystem: (world: IWorld) => void;
export declare const webxrControllerEventHandlingSystem: (world: IWorld) => void;
export declare const webxrControllerSystem: (world: IWorld) => void;
export declare const clearWebXRControllerEventSystem: (world: IWorld) => void;
export declare const webxrRaySystem: (world: IWorld) => void;
export declare const webxrSessionManagementSystem: (world: IWorld) => void;
export declare const clearWebXRSessionEventSystem: (world: IWorld) => void;
export declare const windowResizeEventHandleSystem: (world: IWorld) => void;
export declare const windowResizeEventClearSystem: (world: IWorld) => void;
export declare const getAudioContextProxy: (world: IWorld) => AudioContextProxy;
export declare const addAudioSourceWithAudioSourceNode: (world: IWorld, eid: number, source: MediaStreamAudioSourceNode | MediaElementAudioSourceNode) => void;
export declare const addAudioSourceWithElement: (world: IWorld, eid: number, audio: HTMLAudioElement) => void;
export declare const addAudioSourceWithStream: (world: IWorld, eid: number, stream: MediaStream) => void;
export declare const removeEntityIfNoComponent: (world: IWorld, eid: number) => boolean;
export declare const removeComponentsAndThenEntity: (world: IWorld, eid: number) => void;
export declare const hasComponents: (world: IWorld, components: Component[], eid: number) => boolean;
export declare const getRendererProxy: (world: IWorld) => RendererProxy;
export declare const getSceneCameraProxy: (world: IWorld) => PerspectiveCameraProxy;
export declare function loadGltfBitecs(world: IWorld, eid: number, url: string): Generator<void, GLTF>;
export declare function toGenerator<T>(pending: Promise<T>): Generator<void, T>;
export declare const addObject3D: (world: IWorld, obj: Object3D, eid: number) => void;
export declare const removeObject3D: (world: IWorld, obj: Object3D, eid: number) => void;
export declare const hasObject3D: (world: IWorld, obj: Object3D, eid: number) => boolean;
export declare const addAnimation: (world: IWorld, eid: number, action: AnimationAction) => void;
export declare const getCurrentMousePositionProxy: (world: IWorld) => MousePositionProxy;
export declare const getPreviousMousePositionProxy: (world: IWorld) => MousePositionProxy;
export declare const getMyUserId: (world: IWorld) => string;
export declare const getRoomId: (world: IWorld) => string;
export declare const getStateAdapter: (world: IWorld) => StateAdapter;
export declare const createNetworkedEntity: (world: IWorld, type: NetworkedType.Local | NetworkedType.Shared, prefabName: string, prefabParams?: any) => number;
export declare const getPeersProxy: (world: IWorld) => PeersProxy;
export declare const getAvatarUsername: (world: IWorld, eid: number) => string | null;
export declare const registerPrefab: (world: IWorld, key: string, prefab: Prefab) => void;
export declare const deregisterPrefab: (world: IWorld, key: string) => void;
export declare const getPrefab: (world: IWorld, key: string) => Prefab;
export declare const registerSerializers: (world: IWorld, key: string, component: IComponent, serializers: SerializerFunctions) => void;
export declare const deregisterSerializers: (world: IWorld, key: string) => void;
export declare const getSerializers: (world: IWorld, key: string) => SerializerFunctions;
export declare const hasSerializers: (world: IWorld, key: string) => boolean;
export declare const getComponentKey: (world: IWorld, component: IComponent) => string;
export declare const hasComponentKey: (world: IWorld, component: IComponent) => boolean;
export declare const getStreamClientProxy: (world: IWorld) => StreamClientProxy;
export declare function loadGltf(url: string): Generator<void, GLTF>;
export declare const resizeObject3D: (obj: Object3D, targetSize?: number) => Object3D;
export declare const recenterObject3D: (obj: Object3D) => Object3D;
export declare function loadHdrTexture(url: string): Generator<void, Texture>;
export declare const collectClips: (root: Object3D) => AnimationClip[];
export declare const getTimeProxy: (world: IWorld) => TimeProxy;
export declare const getTimestampProxy: (world: IWorld) => TimestampProxy;
export declare const getXRFrameProxy: (world: IWorld) => XRFrameProxy;
export declare const getXRSessionProxy: (world: IWorld) => XRSessionProxy;
export declare const addWebXRSessionEvent: (world: IWorld, type: WebXRSessionEventType, mode: XRSessionMode, session: XRSession) => void;
export declare const isXRPresenting: (world: IWorld) => boolean;
export declare const inVR: (world: IWorld) => boolean;
export declare const inAR: (world: IWorld) => boolean;
export declare const getFirstXRControllerEid: (world: IWorld) => number;
export declare const getSecondXRControllerEid: (world: IWorld) => number;

export {};
