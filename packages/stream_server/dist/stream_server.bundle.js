/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/accepts/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/accepts/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Negotiator = __webpack_require__(/*! negotiator */ "../../node_modules/negotiator/index.js")
var mime = __webpack_require__(/*! mime-types */ "../../node_modules/mime-types/index.js")

/**
 * Module exports.
 * @public
 */

module.exports = Accepts

/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts (req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req)
  }

  this.headers = req.headers
  this.negotiator = new Negotiator(req)
}

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */

Accepts.prototype.type =
Accepts.prototype.types = function (types_) {
  var types = types_

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i]
    }
  }

  // no types, return all requested types
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes()
  }

  // no accept header, return first given type
  if (!this.headers.accept) {
    return types[0]
  }

  var mimes = types.map(extToMime)
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))
  var first = accepts[0]

  return first
    ? types[mimes.indexOf(first)]
    : false
}

/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.encoding =
Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_

  // support flattened arguments
  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length)
    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i]
    }
  }

  // no encodings, return all requested encodings
  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings()
  }

  return this.negotiator.encodings(encodings)[0] || false
}

/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.charset =
Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_

  // support flattened arguments
  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length)
    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i]
    }
  }

  // no charsets, return all requested charsets
  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets()
  }

  return this.negotiator.charsets(charsets)[0] || false
}

/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */

Accepts.prototype.lang =
Accepts.prototype.langs =
Accepts.prototype.language =
Accepts.prototype.languages = function (languages_) {
  var languages = languages_

  // support flattened arguments
  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length)
    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i]
    }
  }

  // no languages, return all requested languages
  if (!languages || languages.length === 0) {
    return this.negotiator.languages()
  }

  return this.negotiator.languages(languages)[0] || false
}

/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function extToMime (type) {
  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function validMime (type) {
  return typeof type === 'string'
}


/***/ }),

/***/ "../../node_modules/base64id/lib/base64id.js":
/*!***************************************************!*\
  !*** ../../node_modules/base64id/lib/base64id.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

/*!
 * base64id v0.1.0
 */

/**
 * Module dependencies
 */

var crypto = __webpack_require__(/*! crypto */ "crypto");

/**
 * Constructor
 */

var Base64Id = function() { };

/**
 * Get random bytes
 *
 * Uses a buffer if available, falls back to crypto.randomBytes
 */

Base64Id.prototype.getRandomBytes = function(bytes) {

  var BUFFER_SIZE = 4096
  var self = this;  
  
  bytes = bytes || 12;

  if (bytes > BUFFER_SIZE) {
    return crypto.randomBytes(bytes);
  }
  
  var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);
  var threshold = parseInt(bytesInBuffer*0.85);

  if (!threshold) {
    return crypto.randomBytes(bytes);
  }

  if (this.bytesBufferIndex == null) {
     this.bytesBufferIndex = -1;
  }

  if (this.bytesBufferIndex == bytesInBuffer) {
    this.bytesBuffer = null;
    this.bytesBufferIndex = -1;
  }

  // No buffered bytes available or index above threshold
  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
     
    if (!this.isGeneratingBytes) {
      this.isGeneratingBytes = true;
      crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {
        self.bytesBuffer = bytes;
        self.bytesBufferIndex = 0;
        self.isGeneratingBytes = false;
      }); 
    }
    
    // Fall back to sync call when no buffered bytes are available
    if (this.bytesBufferIndex == -1) {
      return crypto.randomBytes(bytes);
    }
  }
  
  var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); 
  this.bytesBufferIndex++; 
  
  return result;
}

/**
 * Generates a base64 id
 *
 * (Original version from socket.io <http://socket.io>)
 */

Base64Id.prototype.generateId = function () {
  var rand = Buffer.alloc(15); // multiple of 3 for base64
  if (!rand.writeInt32BE) {
    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()
      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
  }
  this.sequenceNumber = (this.sequenceNumber + 1) | 0;
  rand.writeInt32BE(this.sequenceNumber, 11);
  if (crypto.randomBytes) {
    this.getRandomBytes(12).copy(rand);
  } else {
    // not secure for node 0.4
    [0, 4, 8].forEach(function(i) {
      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
    });
  }
  return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
};

/**
 * Export
 */

exports = module.exports = new Base64Id();


/***/ }),

/***/ "../../node_modules/cors/lib/index.js":
/*!********************************************!*\
  !*** ../../node_modules/cors/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function () {

  'use strict';

  var assign = __webpack_require__(/*! object-assign */ "../../node_modules/object-assign/index.js");
  var vary = __webpack_require__(/*! vary */ "../../node_modules/vary/index.js");

  var defaults = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204
  };

  function isString(s) {
    return typeof s === 'string' || s instanceof String;
  }

  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (isString(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }

  function configureOrigin(options, req) {
    var requestOrigin = req.headers.origin,
      headers = [],
      isAllowed;

    if (!options.origin || options.origin === '*') {
      // allow any origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: '*'
      }]);
    } else if (isString(options.origin)) {
      // fixed origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: options.origin
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options.origin);
      // reflect origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    }

    return headers;
  }

  function configureMethods(options) {
    var methods = options.methods;
    if (methods.join) {
      methods = options.methods.join(','); // .methods is an array, so turn it into a string
    }
    return {
      key: 'Access-Control-Allow-Methods',
      value: methods
    };
  }

  function configureCredentials(options) {
    if (options.credentials === true) {
      return {
        key: 'Access-Control-Allow-Credentials',
        value: 'true'
      };
    }
    return null;
  }

  function configureAllowedHeaders(options, req) {
    var allowedHeaders = options.allowedHeaders || options.headers;
    var headers = [];

    if (!allowedHeaders) {
      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
      headers.push([{
        key: 'Vary',
        value: 'Access-Control-Request-Headers'
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: 'Access-Control-Allow-Headers',
        value: allowedHeaders
      }]);
    }

    return headers;
  }

  function configureExposedHeaders(options) {
    var headers = options.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(','); // .headers is an array, so turn it into a string
    }
    if (headers && headers.length) {
      return {
        key: 'Access-Control-Expose-Headers',
        value: headers
      };
    }
    return null;
  }

  function configureMaxAge(options) {
    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString()
    if (maxAge && maxAge.length) {
      return {
        key: 'Access-Control-Max-Age',
        value: maxAge
      };
    }
    return null;
  }

  function applyHeaders(headers, res) {
    for (var i = 0, n = headers.length; i < n; i++) {
      var header = headers[i];
      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === 'Vary' && header.value) {
          vary(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }

  function cors(options, req, res, next) {
    var headers = [],
      method = req.method && req.method.toUpperCase && req.method.toUpperCase();

    if (method === 'OPTIONS') {
      // preflight
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureMethods(options, req));
      headers.push(configureAllowedHeaders(options, req));
      headers.push(configureMaxAge(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);

      if (options.preflightContinue) {
        next();
      } else {
        // Safari (and potentially other browsers) need content-length 0,
        //   for 204 or they just hang waiting for a body
        res.statusCode = options.optionsSuccessStatus;
        res.setHeader('Content-Length', '0');
        res.end();
      }
    } else {
      // actual response
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);
      next();
    }
  }

  function middlewareWrapper(o) {
    // if options are static (either via defaults or custom options passed in), wrap in a function
    var optionsCallback = null;
    if (typeof o === 'function') {
      optionsCallback = o;
    } else {
      optionsCallback = function (req, cb) {
        cb(null, o);
      };
    }

    return function corsMiddleware(req, res, next) {
      optionsCallback(req, function (err, options) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function (origin, cb) {
              cb(null, corsOptions.origin);
            };
          }

          if (originCallback) {
            originCallback(req.headers.origin, function (err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }

  // can pass either an options hash, an options delegate, or nothing
  module.exports = middlewareWrapper;

}());


/***/ }),

/***/ "../../node_modules/engine.io/node_modules/cookie/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/engine.io/node_modules/cookie/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var encode = encodeURIComponent;

/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {}
  var opt = options || {};
  var pairs = str.split(';')
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var index = pair.indexOf('=')

    // skip things that don't look like key=value
    if (index < 0) {
      continue;
    }

    var key = pair.substring(0, index).trim()

    // only assign once
    if (undefined == obj[key]) {
      var val = pair.substring(index + 1, pair.length).trim()

      // quoted values
      if (val[0] === '"') {
        val = val.slice(1, -1)
      }

      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */

function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;

  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;

    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid')
    }

    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}


/***/ }),

/***/ "../../node_modules/engine.io/node_modules/debug/src/browser.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/engine.io/node_modules/debug/src/browser.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/engine.io/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/engine.io/node_modules/debug/src/common.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/engine.io/node_modules/debug/src/common.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/engine.io/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../node_modules/engine.io/node_modules/debug/src/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/engine.io/node_modules/debug/src/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "../../node_modules/engine.io/node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "../../node_modules/engine.io/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "../../node_modules/engine.io/node_modules/debug/src/node.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/engine.io/node_modules/debug/src/node.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "../../node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/engine.io/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "../../node_modules/engine.io/node_modules/ms/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/engine.io/node_modules/ms/index.js ***!
  \*************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/flatbuffers/mjs/builder.js":
/*!*****************************************************!*\
  !*** ../../node_modules/flatbuffers/mjs/builder.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* binding */ Builder)
/* harmony export */ });
/* harmony import */ var _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-buffer.js */ "../../node_modules/flatbuffers/mjs/byte-buffer.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "../../node_modules/flatbuffers/mjs/constants.js");


class Builder {
    /**
     * Create a FlatBufferBuilder.
     */
    constructor(opt_initial_size) {
        /** Minimum alignment encountered so far. */
        this.minalign = 1;
        /** The vtable for the current table. */
        this.vtable = null;
        /** The amount of fields we're actually using. */
        this.vtable_in_use = 0;
        /** Whether we are currently serializing a table. */
        this.isNested = false;
        /** Starting offset of the current struct/table. */
        this.object_start = 0;
        /** List of offsets of all vtables. */
        this.vtables = [];
        /** For the current vector being built. */
        this.vector_num_elems = 0;
        /** False omits default values from the serialized data */
        this.force_defaults = false;
        this.string_maps = null;
        this.text_encoder = new TextEncoder();
        let initial_size;
        if (!opt_initial_size) {
            initial_size = 1024;
        }
        else {
            initial_size = opt_initial_size;
        }
        /**
         * @type {ByteBuffer}
         * @private
         */
        this.bb = _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__.ByteBuffer.allocate(initial_size);
        this.space = initial_size;
    }
    clear() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
        this.string_maps = null;
    }
    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param forceDefaults true always serializes default values
     */
    forceDefaults(forceDefaults) {
        this.force_defaults = forceDefaults;
    }
    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     */
    dataBuffer() {
        return this.bb;
    }
    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     */
    asUint8Array() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param size This is the of the new element to write
     * @param additional_bytes The padding size
     */
    prep(size, additional_bytes) {
        // Track the biggest thing we've ever aligned to.
        if (size > this.minalign) {
            this.minalign = size;
        }
        // Find the amount of alignment needed such that `size` is properly
        // aligned after `additional_bytes`
        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);
        // Reallocate the buffer if needed.
        while (this.space < align_size + size + additional_bytes) {
            const old_buf_size = this.bb.capacity();
            this.bb = Builder.growByteBuffer(this.bb);
            this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
    }
    pad(byte_size) {
        for (let i = 0; i < byte_size; i++) {
            this.bb.writeInt8(--this.space, 0);
        }
    }
    writeInt8(value) {
        this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
        this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
        this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
        this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
        this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
        this.bb.writeFloat64(this.space -= 8, value);
    }
    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int8` to add the buffer.
     */
    addInt8(value) {
        this.prep(1, 0);
        this.writeInt8(value);
    }
    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int16` to add the buffer.
     */
    addInt16(value) {
        this.prep(2, 0);
        this.writeInt16(value);
    }
    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int32` to add the buffer.
     */
    addInt32(value) {
        this.prep(4, 0);
        this.writeInt32(value);
    }
    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int64` to add the buffer.
     */
    addInt64(value) {
        this.prep(8, 0);
        this.writeInt64(value);
    }
    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float32` to add the buffer.
     */
    addFloat32(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
    }
    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float64` to add the buffer.
     */
    addFloat64(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt8(value);
            this.slot(voffset);
        }
    }
    addFieldInt16(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt16(value);
            this.slot(voffset);
        }
    }
    addFieldInt32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt32(value);
            this.slot(voffset);
        }
    }
    addFieldInt64(voffset, value, defaultValue) {
        if (this.force_defaults || value !== defaultValue) {
            this.addInt64(value);
            this.slot(voffset);
        }
    }
    addFieldFloat32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat32(value);
            this.slot(voffset);
        }
    }
    addFieldFloat64(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat64(value);
            this.slot(voffset);
        }
    }
    addFieldOffset(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addOffset(value);
            this.slot(voffset);
        }
    }
    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     */
    addFieldStruct(voffset, value, defaultValue) {
        if (value != defaultValue) {
            this.nested(value);
            this.slot(voffset);
        }
    }
    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     */
    nested(obj) {
        if (obj != this.offset()) {
            throw new TypeError('FlatBuffers: struct must be serialized inline.');
        }
    }
    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */
    notNested() {
        if (this.isNested) {
            throw new TypeError('FlatBuffers: object serialization must not be nested.');
        }
    }
    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     */
    slot(voffset) {
        if (this.vtable !== null)
            this.vtable[voffset] = this.offset();
    }
    /**
     * @returns Offset relative to the end of the buffer.
     */
    offset() {
        return this.bb.capacity() - this.space;
    }
    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param bb The current buffer with the existing data
     * @returns A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */
    static growByteBuffer(bb) {
        const old_buf_size = bb.capacity();
        // Ensure we don't grow beyond what fits in an int.
        if (old_buf_size & 0xC0000000) {
            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
        }
        const new_buf_size = old_buf_size << 1;
        const nbb = _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__.ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
    }
    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param offset The offset to add.
     */
    addOffset(offset) {
        this.prep(_constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT, 0); // Ensure alignment is already done.
        this.writeInt32(this.offset() - offset + _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT);
    }
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     */
    startObject(numfields) {
        this.notNested();
        if (this.vtable == null) {
            this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for (let i = 0; i < numfields; i++) {
            this.vtable[i] = 0; // This will push additional elements as needed
        }
        this.isNested = true;
        this.object_start = this.offset();
    }
    /**
     * Finish off writing the object that is under construction.
     *
     * @returns The offset to the object inside `dataBuffer`
     */
    endObject() {
        if (this.vtable == null || !this.isNested) {
            throw new Error('FlatBuffers: endObject called without startObject');
        }
        this.addInt32(0);
        const vtableloc = this.offset();
        // Trim trailing zeroes.
        let i = this.vtable_in_use - 1;
        // eslint-disable-next-line no-empty
        for (; i >= 0 && this.vtable[i] == 0; i--) { }
        const trimmed_size = i + 1;
        // Write out the current vtable.
        for (; i >= 0; i--) {
            // Offset relative to the start of the table.
            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        const standard_fields = 2; // The fields below:
        this.addInt16(vtableloc - this.object_start);
        const len = (trimmed_size + standard_fields) * _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT;
        this.addInt16(len);
        // Search for an existing vtable that matches the current one.
        let existing_vtable = 0;
        const vt1 = this.space;
        outer_loop: for (i = 0; i < this.vtables.length; i++) {
            const vt2 = this.bb.capacity() - this.vtables[i];
            if (len == this.bb.readInt16(vt2)) {
                for (let j = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT; j < len; j += _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT) {
                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                        continue outer_loop;
                    }
                }
                existing_vtable = this.vtables[i];
                break;
            }
        }
        if (existing_vtable) {
            // Found a match:
            // Remove the current vtable.
            this.space = this.bb.capacity() - vtableloc;
            // Point table to existing vtable.
            this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        }
        else {
            // No match:
            // Add the location of the current vtable to the list of vtables.
            this.vtables.push(this.offset());
            // Point table to current vtable.
            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
    }
    /**
     * Finalize a buffer, poiting to the given `root_table`.
     */
    finish(root_table, opt_file_identifier, opt_size_prefix) {
        const size_prefix = opt_size_prefix ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
            const file_identifier = opt_file_identifier;
            this.prep(this.minalign, _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT +
                _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH + size_prefix);
            if (file_identifier.length != _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH) {
                throw new TypeError('FlatBuffers: file identifier must be length ' +
                    _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH);
            }
            for (let i = _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
                this.writeInt8(file_identifier.charCodeAt(i));
            }
        }
        this.prep(this.minalign, _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
            this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
    }
    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     */
    finishSizePrefixed(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
    }
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     */
    requiredField(table, field) {
        const table_start = this.bb.capacity() - table;
        const vtable_start = table_start - this.bb.readInt32(table_start);
        const ok = field < this.bb.readInt16(vtable_start) &&
            this.bb.readInt16(vtable_start + field) != 0;
        // If this fails, the caller will show what field needs to be set.
        if (!ok) {
            throw new TypeError('FlatBuffers: field ' + field + ' must be set');
        }
    }
    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param elem_size The size of each element in the array
     * @param num_elems The number of elements in the array
     * @param alignment The alignment of the array
     */
    startVector(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(_constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
    }
    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns The offset at which the newly created array
     * starts.
     */
    endVector() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If the string passed has
     * already been seen, we return the offset of the already written string
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createSharedString(s) {
        if (!s) {
            return 0;
        }
        if (!this.string_maps) {
            this.string_maps = new Map();
        }
        if (this.string_maps.has(s)) {
            return this.string_maps.get(s);
        }
        const offset = this.createString(s);
        this.string_maps.set(s, offset);
        return offset;
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createString(s) {
        if (s === null || s === undefined) {
            return 0;
        }
        let utf8;
        if (s instanceof Uint8Array) {
            utf8 = s;
        }
        else {
            utf8 = this.text_encoder.encode(s);
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
            bytes[offset++] = utf8[i];
        }
        return this.endVector();
    }
    /**
     * A helper function to pack an object
     *
     * @returns offset of obj
     */
    createObjectOffset(obj) {
        if (obj === null) {
            return 0;
        }
        if (typeof obj === 'string') {
            return this.createString(obj);
        }
        else {
            return obj.pack(this);
        }
    }
    /**
     * A helper function to pack a list of object
     *
     * @returns list of offsets of each non null object
     */
    createObjectOffsetList(list) {
        const ret = [];
        for (let i = 0; i < list.length; ++i) {
            const val = list[i];
            if (val !== null) {
                ret.push(this.createObjectOffset(val));
            }
            else {
                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');
            }
        }
        return ret;
    }
    createStructOffsetList(list, startFunc) {
        startFunc(this, list.length);
        this.createObjectOffsetList(list.slice().reverse());
        return this.endVector();
    }
}


/***/ }),

/***/ "../../node_modules/flatbuffers/mjs/byte-buffer.js":
/*!*********************************************************!*\
  !*** ../../node_modules/flatbuffers/mjs/byte-buffer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ByteBuffer: () => (/* binding */ ByteBuffer)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "../../node_modules/flatbuffers/mjs/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "../../node_modules/flatbuffers/mjs/utils.js");
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "../../node_modules/flatbuffers/mjs/encoding.js");



class ByteBuffer {
    /**
     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
     */
    constructor(bytes_) {
        this.bytes_ = bytes_;
        this.position_ = 0;
        this.text_decoder_ = new TextDecoder();
    }
    /**
     * Create and allocate a new ByteBuffer with a given size.
     */
    static allocate(byte_size) {
        return new ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
        this.position_ = 0;
    }
    /**
     * Get the underlying `Uint8Array`.
     */
    bytes() {
        return this.bytes_;
    }
    /**
     * Get the buffer's position.
     */
    position() {
        return this.position_;
    }
    /**
     * Set the buffer's position.
     */
    setPosition(position) {
        this.position_ = position;
    }
    /**
     * Get the buffer's capacity.
     */
    capacity() {
        return this.bytes_.length;
    }
    readInt8(offset) {
        return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
        return this.bytes_[offset];
    }
    readInt16(offset) {
        return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
        return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readUint64(offset) {
        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readFloat32(offset) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[0] = this.readInt32(offset);
        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32[0];
    }
    readFloat64(offset) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 0 : 1] = this.readInt32(offset);
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64[0];
    }
    writeInt8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    }
    writeUint64(offset, value) {
        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    }
    writeFloat32(offset, value) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32[0] = value;
        this.writeInt32(offset, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[0]);
    }
    writeFloat64(offset, value) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64[0] = value;
        this.writeInt32(offset, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 1 : 0]);
    }
    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     */
    getBufferIdentifier() {
        if (this.bytes_.length < this.position_ + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT +
            _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');
        }
        let result = "";
        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH; i++) {
            result += String.fromCharCode(this.readInt8(this.position_ + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT + i));
        }
        return result;
    }
    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     */
    __offset(bb_pos, vtable_offset) {
        const vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     */
    __union(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
    }
    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
     * "optionalEncoding" argument. This is useful for avoiding conversion when
     * the data will just be packaged back up in another FlatBuffer later on.
     *
     * @param offset
     * @param opt_encoding Defaults to UTF16_STRING
     */
    __string(offset, opt_encoding) {
        offset += this.readInt32(offset);
        const length = this.readInt32(offset);
        offset += _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT;
        const utf8bytes = this.bytes_.subarray(offset, offset + length);
        if (opt_encoding === _encoding_js__WEBPACK_IMPORTED_MODULE_2__.Encoding.UTF8_BYTES)
            return utf8bytes;
        else
            return this.text_decoder_.decode(utf8bytes);
    }
    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
     * if a string then return a new one
     *
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
     * makes the behaviour of __union_with_string different compared to __union
     */
    __union_with_string(o, offset) {
        if (typeof o === 'string') {
            return this.__string(offset);
        }
        return this.__union(o, offset);
    }
    /**
     * Retrieve the relative offset stored at "offset"
     */
    __indirect(offset) {
        return offset + this.readInt32(offset);
    }
    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     */
    __vector(offset) {
        return offset + this.readInt32(offset) + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT; // data starts after the length
    }
    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     */
    __vector_len(offset) {
        return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
        if (ident.length != _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: file identifier must be length ' +
                _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH);
        }
        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH; i++) {
            if (ident.charCodeAt(i) != this.readInt8(this.position() + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT + i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * A helper function for generating list for obj api
     */
    createScalarList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val);
            }
        }
        return ret;
    }
    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength listLength
     * @param res result list
     */
    createObjList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val.unpack());
            }
        }
        return ret;
    }
}


/***/ }),

/***/ "../../node_modules/flatbuffers/mjs/constants.js":
/*!*******************************************************!*\
  !*** ../../node_modules/flatbuffers/mjs/constants.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FILE_IDENTIFIER_LENGTH: () => (/* binding */ FILE_IDENTIFIER_LENGTH),
/* harmony export */   SIZEOF_INT: () => (/* binding */ SIZEOF_INT),
/* harmony export */   SIZEOF_SHORT: () => (/* binding */ SIZEOF_SHORT),
/* harmony export */   SIZE_PREFIX_LENGTH: () => (/* binding */ SIZE_PREFIX_LENGTH)
/* harmony export */ });
const SIZEOF_SHORT = 2;
const SIZEOF_INT = 4;
const FILE_IDENTIFIER_LENGTH = 4;
const SIZE_PREFIX_LENGTH = 4;


/***/ }),

/***/ "../../node_modules/flatbuffers/mjs/encoding.js":
/*!******************************************************!*\
  !*** ../../node_modules/flatbuffers/mjs/encoding.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Encoding: () => (/* binding */ Encoding)
/* harmony export */ });
var Encoding;
(function (Encoding) {
    Encoding[Encoding["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding[Encoding["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));


/***/ }),

/***/ "../../node_modules/flatbuffers/mjs/flatbuffers.js":
/*!*********************************************************!*\
  !*** ../../node_modules/flatbuffers/mjs/flatbuffers.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* reexport safe */ _builder_js__WEBPACK_IMPORTED_MODULE_3__.Builder),
/* harmony export */   ByteBuffer: () => (/* reexport safe */ _byte_buffer_js__WEBPACK_IMPORTED_MODULE_4__.ByteBuffer),
/* harmony export */   Encoding: () => (/* reexport safe */ _encoding_js__WEBPACK_IMPORTED_MODULE_2__.Encoding),
/* harmony export */   FILE_IDENTIFIER_LENGTH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH),
/* harmony export */   SIZEOF_INT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT),
/* harmony export */   SIZEOF_SHORT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_SHORT),
/* harmony export */   SIZE_PREFIX_LENGTH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH),
/* harmony export */   float32: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32),
/* harmony export */   float64: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64),
/* harmony export */   int32: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32),
/* harmony export */   isLittleEndian: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "../../node_modules/flatbuffers/mjs/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "../../node_modules/flatbuffers/mjs/utils.js");
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "../../node_modules/flatbuffers/mjs/encoding.js");
/* harmony import */ var _builder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./builder.js */ "../../node_modules/flatbuffers/mjs/builder.js");
/* harmony import */ var _byte_buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./byte-buffer.js */ "../../node_modules/flatbuffers/mjs/byte-buffer.js");










/***/ }),

/***/ "../../node_modules/flatbuffers/mjs/utils.js":
/*!***************************************************!*\
  !*** ../../node_modules/flatbuffers/mjs/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   float32: () => (/* binding */ float32),
/* harmony export */   float64: () => (/* binding */ float64),
/* harmony export */   int32: () => (/* binding */ int32),
/* harmony export */   isLittleEndian: () => (/* binding */ isLittleEndian)
/* harmony export */ });
const int32 = new Int32Array(2);
const float32 = new Float32Array(int32.buffer);
const float64 = new Float64Array(int32.buffer);
const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;


/***/ }),

/***/ "../../node_modules/h264-profile-level-id/lib/Logger.js":
/*!**************************************************************!*\
  !*** ../../node_modules/h264-profile-level-id/lib/Logger.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "../../node_modules/h264-profile-level-id/node_modules/debug/src/index.js"));
const APP_NAME = 'h264-profile-level-id';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "../../node_modules/h264-profile-level-id/lib/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/h264-profile-level-id/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateProfileLevelIdStringForAnswer = exports.isSameProfile = exports.parseSdpProfileLevelId = exports.levelToString = exports.profileToString = exports.profileLevelIdToString = exports.parseProfileLevelId = exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/h264-profile-level-id/lib/Logger.js");
const logger = new Logger_1.Logger();
/**
 * Supported profiles.
 */
// ESLint absurdly complains about "'Profile' is already declared in
// the upper scope".
// eslint-disable-next-line no-shadow
var Profile;
(function (Profile) {
    Profile[Profile["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
    Profile[Profile["Baseline"] = 2] = "Baseline";
    Profile[Profile["Main"] = 3] = "Main";
    Profile[Profile["ConstrainedHigh"] = 4] = "ConstrainedHigh";
    Profile[Profile["High"] = 5] = "High";
    Profile[Profile["PredictiveHigh444"] = 6] = "PredictiveHigh444";
})(Profile || (exports.Profile = Profile = {}));
/**
 * Supported levels.
 */
// ESLint absurdly complains about "'Level' is already declared in
// the upper scope".
// eslint-disable-next-line no-shadow
var Level;
(function (Level) {
    Level[Level["L1_b"] = 0] = "L1_b";
    Level[Level["L1"] = 10] = "L1";
    Level[Level["L1_1"] = 11] = "L1_1";
    Level[Level["L1_2"] = 12] = "L1_2";
    Level[Level["L1_3"] = 13] = "L1_3";
    Level[Level["L2"] = 20] = "L2";
    Level[Level["L2_1"] = 21] = "L2_1";
    Level[Level["L2_2"] = 22] = "L2_2";
    Level[Level["L3"] = 30] = "L3";
    Level[Level["L3_1"] = 31] = "L3_1";
    Level[Level["L3_2"] = 32] = "L3_2";
    Level[Level["L4"] = 40] = "L4";
    Level[Level["L4_1"] = 41] = "L4_1";
    Level[Level["L4_2"] = 42] = "L4_2";
    Level[Level["L5"] = 50] = "L5";
    Level[Level["L5_1"] = 51] = "L5_1";
    Level[Level["L5_2"] = 52] = "L5_2";
})(Level || (exports.Level = Level = {}));
/**
 * Represents a parsed h264 profile-level-id value.
 */
class ProfileLevelId {
    constructor(profile, level) {
        this.profile = profile;
        this.level = level;
    }
}
exports.ProfileLevelId = ProfileLevelId;
// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
const DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
/**
 * Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to
 * be either 0 or 1.
 */
class BitPattern {
    constructor(str) {
        this.mask = ~byteMaskString('x', str);
        this.masked_value = byteMaskString('1', str);
    }
    isMatch(value) {
        return this.masked_value === (value & this.mask);
    }
}
/**
 * Class for converting between profile_idc/profile_iop to Profile.
 */
class ProfilePattern {
    constructor(profile_idc, profile_iop, profile) {
        this.profile_idc = profile_idc;
        this.profile_iop = profile_iop;
        this.profile = profile;
    }
}
// This is from https://tools.ietf.org/html/rfc6184#section-8.1.
const ProfilePatterns = [
    new ProfilePattern(0x42, new BitPattern('x1xx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x4D, new BitPattern('1xxx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x58, new BitPattern('11xx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x42, new BitPattern('x0xx0000'), Profile.Baseline),
    new ProfilePattern(0x58, new BitPattern('10xx0000'), Profile.Baseline),
    new ProfilePattern(0x4D, new BitPattern('0x0x0000'), Profile.Main),
    new ProfilePattern(0x64, new BitPattern('00000000'), Profile.High),
    new ProfilePattern(0x64, new BitPattern('00001100'), Profile.ConstrainedHigh),
    new ProfilePattern(0xF4, new BitPattern('00000000'), Profile.PredictiveHigh444)
];
/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 */
function parseProfileLevelId(str) {
    // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
    // flag specifies if level 1b or level 1.1 is used.
    const ConstraintSet3Flag = 0x10;
    // The string should consist of 3 bytes in hexadecimal format.
    if (typeof str !== 'string' || str.length !== 6) {
        return undefined;
    }
    const profile_level_id_numeric = parseInt(str, 16);
    if (profile_level_id_numeric === 0) {
        return undefined;
    }
    // Separate into three bytes.
    const level_idc = (profile_level_id_numeric & 0xFF);
    const profile_iop = (profile_level_id_numeric >> 8) & 0xFF;
    const profile_idc = (profile_level_id_numeric >> 16) & 0xFF;
    // Parse level based on level_idc and constraint set 3 flag.
    let level;
    switch (level_idc) {
        case Level.L1_1:
            {
                level = (profile_iop & ConstraintSet3Flag) !== 0
                    ? Level.L1_b
                    : Level.L1_1;
                break;
            }
        case Level.L1:
        case Level.L1_2:
        case Level.L1_3:
        case Level.L2:
        case Level.L2_1:
        case Level.L2_2:
        case Level.L3:
        case Level.L3_1:
        case Level.L3_2:
        case Level.L4:
        case Level.L4_1:
        case Level.L4_2:
        case Level.L5:
        case Level.L5_1:
        case Level.L5_2:
            {
                level = level_idc;
                break;
            }
        // Unrecognized level_idc.
        default:
            {
                logger.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
                return undefined;
            }
    }
    // Parse profile_idc/profile_iop into a Profile enum.
    for (const pattern of ProfilePatterns) {
        if (profile_idc === pattern.profile_idc &&
            pattern.profile_iop.isMatch(profile_iop)) {
            return new ProfileLevelId(pattern.profile, level);
        }
    }
    logger.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
    return undefined;
}
exports.parseProfileLevelId = parseProfileLevelId;
/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 */
function profileLevelIdToString(profile_level_id) {
    // Handle special case level == 1b.
    if (profile_level_id.level == Level.L1_b) {
        switch (profile_level_id.profile) {
            case Profile.ConstrainedBaseline:
                {
                    return '42f00b';
                }
            case Profile.Baseline:
                {
                    return '42100b';
                }
            case Profile.Main:
                {
                    return '4d100b';
                }
            // Level 1_b is not allowed for other profiles.
            default:
                {
                    logger.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
                    return undefined;
                }
        }
    }
    let profile_idc_iop_string;
    switch (profile_level_id.profile) {
        case Profile.ConstrainedBaseline:
            {
                profile_idc_iop_string = '42e0';
                break;
            }
        case Profile.Baseline:
            {
                profile_idc_iop_string = '4200';
                break;
            }
        case Profile.Main:
            {
                profile_idc_iop_string = '4d00';
                break;
            }
        case Profile.ConstrainedHigh:
            {
                profile_idc_iop_string = '640c';
                break;
            }
        case Profile.High:
            {
                profile_idc_iop_string = '6400';
                break;
            }
        case Profile.PredictiveHigh444:
            {
                profile_idc_iop_string = 'f400';
                break;
            }
        default:
            {
                logger.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
                return undefined;
            }
    }
    let levelStr = (profile_level_id.level).toString(16);
    if (levelStr.length === 1) {
        levelStr = `0${levelStr}`;
    }
    return `${profile_idc_iop_string}${levelStr}`;
}
exports.profileLevelIdToString = profileLevelIdToString;
/**
 * Returns a human friendly name for the given profile.
 */
function profileToString(profile) {
    switch (profile) {
        case Profile.ConstrainedBaseline:
            {
                return 'ConstrainedBaseline';
            }
        case Profile.Baseline:
            {
                return 'Baseline';
            }
        case Profile.Main:
            {
                return 'Main';
            }
        case Profile.ConstrainedHigh:
            {
                return 'ConstrainedHigh';
            }
        case Profile.High:
            {
                return 'High';
            }
        case Profile.PredictiveHigh444:
            {
                return 'PredictiveHigh444';
            }
        default:
            {
                logger.warn(`profileToString() | unrecognized profile ${profile}`);
                return undefined;
            }
    }
}
exports.profileToString = profileToString;
/**
 * Returns a human friendly name for the given level.
 */
function levelToString(level) {
    switch (level) {
        case Level.L1_b:
            {
                return '1b';
            }
        case Level.L1:
            {
                return '1';
            }
        case Level.L1_1:
            {
                return '1.1';
            }
        case Level.L1_2:
            {
                return '1.2';
            }
        case Level.L1_3:
            {
                return '1.3';
            }
        case Level.L2:
            {
                return '2';
            }
        case Level.L2_1:
            {
                return '2.1';
            }
        case Level.L2_2:
            {
                return '2.2';
            }
        case Level.L3:
            {
                return '3';
            }
        case Level.L3_1:
            {
                return '3.1';
            }
        case Level.L3_2:
            {
                return '3.2';
            }
        case Level.L4:
            {
                return '4';
            }
        case Level.L4_1:
            {
                return '4.1';
            }
        case Level.L4_2:
            {
                return '4.2';
            }
        case Level.L5:
            {
                return '5';
            }
        case Level.L5_1:
            {
                return '5.1';
            }
        case Level.L5_2:
            {
                return '5.2';
            }
        default:
            {
                logger.warn(`levelToString() | unrecognized level ${level}`);
                return undefined;
            }
    }
}
exports.levelToString = levelToString;
/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned
 * if the key is present but the string is invalid.
 */
function parseSdpProfileLevelId(params = {}) {
    const profile_level_id = params['profile-level-id'];
    return profile_level_id
        ? parseProfileLevelId(profile_level_id)
        : DefaultProfileLevelId;
}
exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
/**
 * Returns true if the parameters have the same H264 profile, i.e. the same
 * H264 profile (Baseline, High, etc).
 */
function isSameProfile(params1 = {}, params2 = {}) {
    const profile_level_id_1 = parseSdpProfileLevelId(params1);
    const profile_level_id_2 = parseSdpProfileLevelId(params2);
    // Compare H264 profiles, but not levels.
    return Boolean(profile_level_id_1 &&
        profile_level_id_2 &&
        profile_level_id_1.profile === profile_level_id_2.profile);
}
exports.isSameProfile = isSameProfile;
/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict
 * superset of the profile in remote_offered_params, we could limit the profile
 * in the answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and
 * level-asymmetry-allowed.
 */
function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
    // If both local and remote params do not contain profile-level-id, they are
    // both using the default profile. In this case, don't return anything.
    if (!local_supported_params['profile-level-id'] &&
        !remote_offered_params['profile-level-id']) {
        logger.warn('generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params');
        return undefined;
    }
    // Parse profile-level-ids.
    const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
    const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
    // The local and remote codec must have valid and equal H264 Profiles.
    if (!local_profile_level_id) {
        throw new TypeError('invalid local_profile_level_id');
    }
    if (!remote_profile_level_id) {
        throw new TypeError('invalid remote_profile_level_id');
    }
    if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
        throw new TypeError('H264 Profile mismatch');
    }
    // Parse level information.
    const level_asymmetry_allowed = (isLevelAsymmetryAllowed(local_supported_params) &&
        isLevelAsymmetryAllowed(remote_offered_params));
    const local_level = local_profile_level_id.level;
    const remote_level = remote_profile_level_id.level;
    const min_level = minLevel(local_level, remote_level);
    // Determine answer level. When level asymmetry is not allowed, level upgrade
    // is not allowed, i.e., the level in the answer must be equal to or lower
    // than the level in the offer.
    const answer_level = level_asymmetry_allowed
        ? local_level
        : min_level;
    logger.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
    // Return the resulting profile-level-id for the answer parameters.
    return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
}
exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
/**
 * Convert a string of 8 characters into a byte where the positions containing
 * character c will have their bit set. For example, c = 'x', str = "x1xx0000"
 * will return 0b10110000.
 */
function byteMaskString(c, str) {
    return ((Number(str[0] === c) << 7) | (Number(str[1] === c) << 6) |
        (Number(str[2] === c) << 5) | (Number(str[3] === c) << 4) |
        (Number(str[4] === c) << 3) | (Number(str[5] === c) << 2) |
        (Number(str[6] === c) << 1) | (Number(str[7] === c) << 0));
}
// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b) {
    if (a === Level.L1_b) {
        return b !== Level.L1 && b !== Level.L1_b;
    }
    if (b === Level.L1_b) {
        return a !== Level.L1;
    }
    return a < b;
}
function minLevel(a, b) {
    return isLessLevel(a, b) ? a : b;
}
function isLevelAsymmetryAllowed(params = {}) {
    const level_asymmetry_allowed = params['level-asymmetry-allowed'];
    return (level_asymmetry_allowed === true ||
        level_asymmetry_allowed === 1 ||
        level_asymmetry_allowed === '1');
}


/***/ }),

/***/ "../../node_modules/h264-profile-level-id/node_modules/debug/src/browser.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/h264-profile-level-id/node_modules/debug/src/browser.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/h264-profile-level-id/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/h264-profile-level-id/node_modules/debug/src/common.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/h264-profile-level-id/node_modules/debug/src/common.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/h264-profile-level-id/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../node_modules/h264-profile-level-id/node_modules/debug/src/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/h264-profile-level-id/node_modules/debug/src/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "../../node_modules/h264-profile-level-id/node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "../../node_modules/h264-profile-level-id/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "../../node_modules/h264-profile-level-id/node_modules/debug/src/node.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/h264-profile-level-id/node_modules/debug/src/node.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "../../node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/h264-profile-level-id/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "../../node_modules/h264-profile-level-id/node_modules/ms/index.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/h264-profile-level-id/node_modules/ms/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/has-flag/index.js":
/*!********************************************!*\
  !*** ../../node_modules/has-flag/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/ActiveSpeakerObserver.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/ActiveSpeakerObserver.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveSpeakerObserver = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const RtpObserver_1 = __webpack_require__(/*! ./RtpObserver */ "../../node_modules/mediasoup/node/lib/RtpObserver.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsActiveSpeakerObserver = __webpack_require__(/*! ./fbs/active-speaker-observer */ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer.js");
const logger = new Logger_1.Logger('ActiveSpeakerObserver');
class ActiveSpeakerObserver extends RtpObserver_1.RtpObserver {
    /**
     * @private
     */
    constructor(options) {
        super(options);
        this.handleWorkerNotifications();
    }
    /**
     * Observer.
     */
    get observer() {
        return super.observer;
    }
    handleWorkerNotifications() {
        this.channel.on(this.internal.rtpObserverId, (event, data) => {
            switch (event) {
                case notification_1.Event.ACTIVESPEAKEROBSERVER_DOMINANT_SPEAKER: {
                    const notification = new FbsActiveSpeakerObserver.DominantSpeakerNotification();
                    data.body(notification);
                    const producer = this.getProducerById(notification.producerId());
                    if (!producer) {
                        break;
                    }
                    const dominantSpeaker = {
                        producer,
                    };
                    this.safeEmit('dominantspeaker', dominantSpeaker);
                    this.observer.safeEmit('dominantspeaker', dominantSpeaker);
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s"', event);
                }
            }
        });
    }
}
exports.ActiveSpeakerObserver = ActiveSpeakerObserver;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/AudioLevelObserver.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/AudioLevelObserver.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioLevelObserver = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const RtpObserver_1 = __webpack_require__(/*! ./RtpObserver */ "../../node_modules/mediasoup/node/lib/RtpObserver.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsAudioLevelObserver = __webpack_require__(/*! ./fbs/audio-level-observer */ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer.js");
const logger = new Logger_1.Logger('AudioLevelObserver');
class AudioLevelObserver extends RtpObserver_1.RtpObserver {
    /**
     * @private
     */
    constructor(options) {
        super(options);
        this.handleWorkerNotifications();
    }
    /**
     * Observer.
     */
    get observer() {
        return super.observer;
    }
    handleWorkerNotifications() {
        this.channel.on(this.internal.rtpObserverId, (event, data) => {
            switch (event) {
                case notification_1.Event.AUDIOLEVELOBSERVER_VOLUMES: {
                    const notification = new FbsAudioLevelObserver.VolumesNotification();
                    data.body(notification);
                    // Get the corresponding Producer instance and remove entries with
                    // no Producer (it may have been closed in the meanwhile).
                    const volumes = utils
                        .parseVector(notification, 'volumes', parseVolume)
                        .map(({ producerId, volume, }) => ({
                        producer: this.getProducerById(producerId),
                        volume,
                    }))
                        .filter(({ producer }) => producer);
                    if (volumes.length > 0) {
                        this.safeEmit('volumes', volumes);
                        // Emit observer event.
                        this.observer.safeEmit('volumes', volumes);
                    }
                    break;
                }
                case notification_1.Event.AUDIOLEVELOBSERVER_SILENCE: {
                    this.safeEmit('silence');
                    // Emit observer event.
                    this.observer.safeEmit('silence');
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s"', event);
                }
            }
        });
    }
}
exports.AudioLevelObserver = AudioLevelObserver;
function parseVolume(binary) {
    return {
        producerId: binary.producerId(),
        volume: binary.volume(),
    };
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/Channel.js":
/*!********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/Channel.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Channel = void 0;
const os = __webpack_require__(/*! node:os */ "node:os");
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/mediasoup/node/lib/errors.js");
const request_1 = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const response_1 = __webpack_require__(/*! ./fbs/response */ "../../node_modules/mediasoup/node/lib/fbs/response.js");
const message_1 = __webpack_require__(/*! ./fbs/message */ "../../node_modules/mediasoup/node/lib/fbs/message.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const log_1 = __webpack_require__(/*! ./fbs/log */ "../../node_modules/mediasoup/node/lib/fbs/log.js");
const IS_LITTLE_ENDIAN = os.endianness() === 'LE';
const logger = new Logger_1.Logger('Channel');
// Binary length for a 4194304 bytes payload.
const MESSAGE_MAX_LEN = 4194308;
const PAYLOAD_MAX_LEN = 4194304;
class Channel extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Closed flag.
    #closed = false;
    // Unix Socket instance for sending messages to the worker process.
    #producerSocket;
    // Unix Socket instance for receiving messages to the worker process.
    #consumerSocket;
    // Next id for messages sent to the worker process.
    #nextId = 0;
    // Map of pending sent requests.
    #sents = new Map();
    // Buffer for reading messages from the worker.
    #recvBuffer = Buffer.alloc(0);
    // flatbuffers builder.
    #bufferBuilder = new flatbuffers.Builder(1024);
    /**
     * @private
     */
    constructor({ producerSocket, consumerSocket, pid, }) {
        super();
        logger.debug('constructor()');
        this.#producerSocket = producerSocket;
        this.#consumerSocket = consumerSocket;
        // Read Channel responses/notifications from the worker.
        this.#consumerSocket.on('data', (buffer) => {
            if (!this.#recvBuffer.length) {
                this.#recvBuffer = buffer;
            }
            else {
                this.#recvBuffer = Buffer.concat([this.#recvBuffer, buffer], this.#recvBuffer.length + buffer.length);
            }
            if (this.#recvBuffer.length > PAYLOAD_MAX_LEN) {
                logger.error('receiving buffer is full, discarding all data in it');
                // Reset the buffer and exit.
                this.#recvBuffer = Buffer.alloc(0);
                return;
            }
            let msgStart = 0;
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const readLen = this.#recvBuffer.length - msgStart;
                if (readLen < 4) {
                    // Incomplete data.
                    break;
                }
                const dataView = new DataView(this.#recvBuffer.buffer, this.#recvBuffer.byteOffset + msgStart);
                const msgLen = dataView.getUint32(0, IS_LITTLE_ENDIAN);
                if (readLen < 4 + msgLen) {
                    // Incomplete data.
                    break;
                }
                const payload = this.#recvBuffer.subarray(msgStart + 4, msgStart + 4 + msgLen);
                msgStart += 4 + msgLen;
                const buf = new flatbuffers.ByteBuffer(new Uint8Array(payload));
                const message = message_1.Message.getRootAsMessage(buf);
                try {
                    switch (message.dataType()) {
                        case message_1.Body.Response: {
                            const response = new response_1.Response();
                            message.data(response);
                            this.processResponse(response);
                            break;
                        }
                        case message_1.Body.Notification: {
                            const notification = new notification_1.Notification();
                            message.data(notification);
                            this.processNotification(notification);
                            break;
                        }
                        case message_1.Body.Log: {
                            const log = new log_1.Log();
                            message.data(log);
                            this.processLog(pid, log);
                            break;
                        }
                        default: {
                            // eslint-disable-next-line no-console
                            console.warn(`worker[pid:${pid}] unexpected data: ${payload.toString('utf8', 1)}`);
                        }
                    }
                }
                catch (error) {
                    logger.error(`received invalid message from the worker process: ${error}`);
                }
            }
            if (msgStart != 0) {
                this.#recvBuffer = this.#recvBuffer.slice(msgStart);
            }
        });
        this.#consumerSocket.on('end', () => logger.debug('Consumer Channel ended by the worker process'));
        this.#consumerSocket.on('error', error => logger.error(`Consumer Channel error: ${error}`));
        this.#producerSocket.on('end', () => logger.debug('Producer Channel ended by the worker process'));
        this.#producerSocket.on('error', error => logger.error(`Producer Channel error: ${error}`));
    }
    /**
     * flatbuffer builder.
     */
    get bufferBuilder() {
        return this.#bufferBuilder;
    }
    /**
     * @private
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Close every pending sent.
        for (const sent of this.#sents.values()) {
            sent.close();
        }
        // Remove event listeners but leave a fake 'error' hander to avoid
        // propagation.
        this.#consumerSocket.removeAllListeners('end');
        this.#consumerSocket.removeAllListeners('error');
        this.#consumerSocket.on('error', () => { });
        this.#producerSocket.removeAllListeners('end');
        this.#producerSocket.removeAllListeners('error');
        this.#producerSocket.on('error', () => { });
        // Destroy the sockets.
        try {
            this.#producerSocket.destroy();
        }
        catch (error) { }
        try {
            this.#consumerSocket.destroy();
        }
        catch (error) { }
    }
    /**
     * @private
     */
    notify(event, bodyType, bodyOffset, handlerId) {
        logger.debug(`notify() [event:${notification_1.Event[event]}]`);
        if (this.#closed) {
            throw new errors_1.InvalidStateError(`Channel closed, cannot send notification [event:${notification_1.Event[event]}]`);
        }
        const handlerIdOffset = this.#bufferBuilder.createString(handlerId);
        let notificationOffset;
        if (bodyType && bodyOffset) {
            notificationOffset = notification_1.Notification.createNotification(this.#bufferBuilder, handlerIdOffset, event, bodyType, bodyOffset);
        }
        else {
            notificationOffset = notification_1.Notification.createNotification(this.#bufferBuilder, handlerIdOffset, event, notification_1.Body.NONE, 0);
        }
        const messageOffset = message_1.Message.createMessage(this.#bufferBuilder, message_1.Body.Notification, notificationOffset);
        // Finalizes the buffer and adds a 4 byte prefix with the size of the buffer.
        this.#bufferBuilder.finishSizePrefixed(messageOffset);
        // Create a new buffer with this data so multiple contiguous flatbuffers
        // do not point to the builder buffer overriding others info.
        const buffer = new Uint8Array(this.#bufferBuilder.asUint8Array());
        // Clear the buffer builder so it's reused for the next request.
        this.#bufferBuilder.clear();
        if (buffer.byteLength > MESSAGE_MAX_LEN) {
            throw new Error(`notification too big [event:${notification_1.Event[event]}]`);
        }
        try {
            // This may throw if closed or remote side ended.
            this.#producerSocket.write(buffer, 'binary');
        }
        catch (error) {
            logger.warn(`notify() | sending notification failed: ${error}`);
            return;
        }
    }
    async request(method, bodyType, bodyOffset, handlerId) {
        logger.debug(`request() [method:${request_1.Method[method]}]`);
        if (this.#closed) {
            throw new errors_1.InvalidStateError(`Channel closed, cannot send request [method:${request_1.Method[method]}]`);
        }
        this.#nextId < 4294967295 ? ++this.#nextId : (this.#nextId = 1);
        const id = this.#nextId;
        const handlerIdOffset = this.#bufferBuilder.createString(handlerId ?? '');
        let requestOffset;
        if (bodyType && bodyOffset) {
            requestOffset = request_1.Request.createRequest(this.#bufferBuilder, id, method, handlerIdOffset, bodyType, bodyOffset);
        }
        else {
            requestOffset = request_1.Request.createRequest(this.#bufferBuilder, id, method, handlerIdOffset, request_1.Body.NONE, 0);
        }
        const messageOffset = message_1.Message.createMessage(this.#bufferBuilder, message_1.Body.Request, requestOffset);
        // Finalizes the buffer and adds a 4 byte prefix with the size of the buffer.
        this.#bufferBuilder.finishSizePrefixed(messageOffset);
        // Create a new buffer with this data so multiple contiguous flatbuffers
        // do not point to the builder buffer overriding others info.
        const buffer = new Uint8Array(this.#bufferBuilder.asUint8Array());
        // Clear the buffer builder so it's reused for the next request.
        this.#bufferBuilder.clear();
        if (buffer.byteLength > MESSAGE_MAX_LEN) {
            throw new Error(`request too big [method:${request_1.Method[method]}]`);
        }
        // This may throw if closed or remote side ended.
        this.#producerSocket.write(buffer, 'binary');
        return new Promise((pResolve, pReject) => {
            const sent = {
                id: id,
                method: request_1.Method[method],
                resolve: data2 => {
                    if (!this.#sents.delete(id)) {
                        return;
                    }
                    pResolve(data2);
                },
                reject: error => {
                    if (!this.#sents.delete(id)) {
                        return;
                    }
                    pReject(error);
                },
                close: () => {
                    pReject(new errors_1.InvalidStateError(`Channel closed, pending request aborted [method:${request_1.Method[method]}, id:${id}]`));
                },
            };
            // Add sent stuff to the map.
            this.#sents.set(id, sent);
        });
    }
    processResponse(response) {
        const sent = this.#sents.get(response.id());
        if (!sent) {
            logger.error(`received response does not match any sent request [id:${response.id}]`);
            return;
        }
        if (response.accepted()) {
            logger.debug(`request succeeded [method:${sent.method}, id:${sent.id}]`);
            sent.resolve(response);
        }
        else if (response.error()) {
            logger.warn(`request failed [method:${sent.method}, id:${sent.id}]: ${response.reason()}`);
            switch (response.error()) {
                case 'TypeError': {
                    sent.reject(new TypeError(response.reason()));
                    break;
                }
                default: {
                    sent.reject(new Error(response.reason()));
                }
            }
        }
        else {
            logger.error(`received response is not accepted nor rejected [method:${sent.method}, id:${sent.id}]`);
        }
    }
    processNotification(notification) {
        // Due to how Promises work, it may happen that we receive a response
        // from the worker followed by a notification from the worker. If we
        // emit the notification immediately it may reach its target **before**
        // the response, destroying the ordered delivery. So we must wait a bit
        // here.
        // See https://github.com/versatica/mediasoup/issues/510
        setImmediate(() => this.emit(notification.handlerId(), notification.event(), notification));
    }
    processLog(pid, log) {
        const logData = log.data();
        switch (logData[0]) {
            // 'D' (a debug log).
            case 'D': {
                logger.debug(`[pid:${pid}] ${logData.slice(1)}`);
                break;
            }
            // 'W' (a warn log).
            case 'W': {
                logger.warn(`[pid:${pid}] ${logData.slice(1)}`);
                break;
            }
            // 'E' (a error log).
            case 'E': {
                logger.error(`[pid:${pid}] ${logData.slice(1)}`);
                break;
            }
            // 'X' (a dump log).
            case 'X': {
                // eslint-disable-next-line no-console
                console.log(logData.slice(1));
                break;
            }
        }
    }
}
exports.Channel = Channel;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/Consumer.js":
/*!*********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/Consumer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseTraceEventData = exports.Consumer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const RtpParameters_1 = __webpack_require__(/*! ./RtpParameters */ "../../node_modules/mediasoup/node/lib/RtpParameters.js");
const RtpStream_1 = __webpack_require__(/*! ./RtpStream */ "../../node_modules/mediasoup/node/lib/RtpStream.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const common_1 = __webpack_require__(/*! ./fbs/common */ "../../node_modules/mediasoup/node/lib/fbs/common.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsConsumer = __webpack_require__(/*! ./fbs/consumer */ "../../node_modules/mediasoup/node/lib/fbs/consumer.js");
const FbsConsumerTraceInfo = __webpack_require__(/*! ./fbs/consumer/trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-info.js");
const rtp_parameters_1 = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
const FbsRtpParameters = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
const logger = new Logger_1.Logger('Consumer');
class Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Internal data.
    #internal;
    // Consumer data.
    #data;
    // Channel instance.
    #channel;
    // Closed flag.
    #closed = false;
    // Custom app data.
    #appData;
    // Paused flag.
    #paused = false;
    // Associated Producer paused flag.
    #producerPaused = false;
    // Current priority.
    #priority = 1;
    // Current score.
    #score;
    // Preferred layers.
    #preferredLayers;
    // Curent layers.
    #currentLayers;
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     */
    constructor({ internal, data, channel, appData, paused, producerPaused, score = { score: 10, producerScore: 10, producerScores: [] }, preferredLayers, }) {
        super();
        logger.debug('constructor()');
        this.#internal = internal;
        this.#data = data;
        this.#channel = channel;
        this.#paused = paused;
        this.#producerPaused = producerPaused;
        this.#score = score;
        this.#preferredLayers = preferredLayers;
        this.#appData = appData || {};
        this.handleWorkerNotifications();
    }
    /**
     * Consumer id.
     */
    get id() {
        return this.#internal.consumerId;
    }
    /**
     * Associated Producer id.
     */
    get producerId() {
        return this.#data.producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this.#data.kind;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this.#data.rtpParameters;
    }
    /**
     * Consumer type.
     */
    get type() {
        return this.#data.type;
    }
    /**
     * Whether the Consumer is paused.
     */
    get paused() {
        return this.#paused;
    }
    /**
     * Whether the associate Producer is paused.
     */
    get producerPaused() {
        return this.#producerPaused;
    }
    /**
     * Current priority.
     */
    get priority() {
        return this.#priority;
    }
    /**
     * Consumer score.
     */
    get score() {
        return this.#score;
    }
    /**
     * Preferred video layers.
     */
    get preferredLayers() {
        return this.#preferredLayers;
    }
    /**
     * Current video layers.
     */
    get currentLayers() {
        return this.#currentLayers;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * @private
     * Just for testing purposes.
     */
    get channelForTesting() {
        return this.#channel;
    }
    /**
     * Close the Consumer.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.#channel.removeAllListeners(this.#internal.consumerId);
        /* Build Request. */
        const requestOffset = new FbsTransport.CloseConsumerRequestT(this.#internal.consumerId).pack(this.#channel.bufferBuilder);
        this.#channel
            .request(FbsRequest.Method.TRANSPORT_CLOSE_CONSUMER, FbsRequest.Body.Transport_CloseConsumerRequest, requestOffset, this.#internal.transportId)
            .catch(() => { });
        this.emit('@close');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     *
     * @private
     */
    transportClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('transportClosed()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.#channel.removeAllListeners(this.#internal.consumerId);
        this.safeEmit('transportclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Dump Consumer.
     */
    async dump() {
        logger.debug('dump()');
        const response = await this.#channel.request(FbsRequest.Method.CONSUMER_DUMP, undefined, undefined, this.#internal.consumerId);
        /* Decode Response. */
        const data = new FbsConsumer.DumpResponse();
        response.body(data);
        return parseConsumerDumpResponse(data);
    }
    /**
     * Get Consumer stats.
     */
    async getStats() {
        logger.debug('getStats()');
        const response = await this.#channel.request(FbsRequest.Method.CONSUMER_GET_STATS, undefined, undefined, this.#internal.consumerId);
        /* Decode Response. */
        const data = new FbsConsumer.GetStatsResponse();
        response.body(data);
        return parseConsumerStats(data);
    }
    /**
     * Pause the Consumer.
     */
    async pause() {
        logger.debug('pause()');
        await this.#channel.request(FbsRequest.Method.CONSUMER_PAUSE, undefined, undefined, this.#internal.consumerId);
        const wasPaused = this.#paused;
        this.#paused = true;
        // Emit observer event.
        if (!wasPaused && !this.#producerPaused) {
            this.#observer.safeEmit('pause');
        }
    }
    /**
     * Resume the Consumer.
     */
    async resume() {
        logger.debug('resume()');
        await this.#channel.request(FbsRequest.Method.CONSUMER_RESUME, undefined, undefined, this.#internal.consumerId);
        const wasPaused = this.#paused;
        this.#paused = false;
        // Emit observer event.
        if (wasPaused && !this.#producerPaused) {
            this.#observer.safeEmit('resume');
        }
    }
    /**
     * Set preferred video layers.
     */
    async setPreferredLayers({ spatialLayer, temporalLayer, }) {
        logger.debug('setPreferredLayers()');
        if (typeof spatialLayer !== 'number') {
            throw new TypeError('spatialLayer must be a number');
        }
        if (temporalLayer && typeof temporalLayer !== 'number') {
            throw new TypeError('if given, temporalLayer must be a number');
        }
        const builder = this.#channel.bufferBuilder;
        const preferredLayersOffset = FbsConsumer.ConsumerLayers.createConsumerLayers(builder, spatialLayer, temporalLayer !== undefined ? temporalLayer : null);
        const requestOffset = FbsConsumer.SetPreferredLayersRequest.createSetPreferredLayersRequest(builder, preferredLayersOffset);
        const response = await this.#channel.request(FbsRequest.Method.CONSUMER_SET_PREFERRED_LAYERS, FbsRequest.Body.Consumer_SetPreferredLayersRequest, requestOffset, this.#internal.consumerId);
        /* Decode Response. */
        const data = new FbsConsumer.SetPreferredLayersResponse();
        let preferredLayers;
        // Response is empty for non Simulcast Consumers.
        if (response.body(data)) {
            const status = data.unpack();
            if (status.preferredLayers) {
                preferredLayers = {
                    spatialLayer: status.preferredLayers.spatialLayer,
                    temporalLayer: status.preferredLayers.temporalLayer !== null
                        ? status.preferredLayers.temporalLayer
                        : undefined,
                };
            }
        }
        this.#preferredLayers = preferredLayers;
    }
    /**
     * Set priority.
     */
    async setPriority(priority) {
        logger.debug('setPriority()');
        if (typeof priority !== 'number' || priority < 0) {
            throw new TypeError('priority must be a positive number');
        }
        const requestOffset = FbsConsumer.SetPriorityRequest.createSetPriorityRequest(this.#channel.bufferBuilder, priority);
        const response = await this.#channel.request(FbsRequest.Method.CONSUMER_SET_PRIORITY, FbsRequest.Body.Consumer_SetPriorityRequest, requestOffset, this.#internal.consumerId);
        const data = new FbsConsumer.SetPriorityResponse();
        response.body(data);
        const status = data.unpack();
        this.#priority = status.priority;
    }
    /**
     * Unset priority.
     */
    async unsetPriority() {
        logger.debug('unsetPriority()');
        await this.setPriority(1);
    }
    /**
     * Request a key frame to the Producer.
     */
    async requestKeyFrame() {
        logger.debug('requestKeyFrame()');
        await this.#channel.request(FbsRequest.Method.CONSUMER_REQUEST_KEY_FRAME, undefined, undefined, this.#internal.consumerId);
    }
    /**
     * Enable 'trace' event.
     */
    async enableTraceEvent(types = []) {
        logger.debug('enableTraceEvent()');
        if (!Array.isArray(types)) {
            throw new TypeError('types must be an array');
        }
        if (types.find(type => typeof type !== 'string')) {
            throw new TypeError('every type must be a string');
        }
        // Convert event types.
        const fbsEventTypes = [];
        for (const eventType of types) {
            try {
                fbsEventTypes.push(consumerTraceEventTypeToFbs(eventType));
            }
            catch (error) {
                logger.warn('enableTraceEvent() | [error:${error}]');
            }
        }
        /* Build Request. */
        const requestOffset = new FbsConsumer.EnableTraceEventRequestT(fbsEventTypes).pack(this.#channel.bufferBuilder);
        await this.#channel.request(FbsRequest.Method.CONSUMER_ENABLE_TRACE_EVENT, FbsRequest.Body.Consumer_EnableTraceEventRequest, requestOffset, this.#internal.consumerId);
    }
    handleWorkerNotifications() {
        this.#channel.on(this.#internal.consumerId, (event, data) => {
            switch (event) {
                case notification_1.Event.CONSUMER_PRODUCER_CLOSE: {
                    if (this.#closed) {
                        break;
                    }
                    this.#closed = true;
                    // Remove notification subscriptions.
                    this.#channel.removeAllListeners(this.#internal.consumerId);
                    this.emit('@producerclose');
                    this.safeEmit('producerclose');
                    // Emit observer event.
                    this.#observer.safeEmit('close');
                    break;
                }
                case notification_1.Event.CONSUMER_PRODUCER_PAUSE: {
                    if (this.#producerPaused) {
                        break;
                    }
                    this.#producerPaused = true;
                    this.safeEmit('producerpause');
                    // Emit observer event.
                    if (!this.#paused) {
                        this.#observer.safeEmit('pause');
                    }
                    break;
                }
                case notification_1.Event.CONSUMER_PRODUCER_RESUME: {
                    if (!this.#producerPaused) {
                        break;
                    }
                    this.#producerPaused = false;
                    this.safeEmit('producerresume');
                    // Emit observer event.
                    if (!this.#paused) {
                        this.#observer.safeEmit('resume');
                    }
                    break;
                }
                case notification_1.Event.CONSUMER_SCORE: {
                    const notification = new FbsConsumer.ScoreNotification();
                    data.body(notification);
                    const score = notification.score().unpack();
                    this.#score = score;
                    this.safeEmit('score', score);
                    // Emit observer event.
                    this.#observer.safeEmit('score', score);
                    break;
                }
                case notification_1.Event.CONSUMER_LAYERS_CHANGE: {
                    const notification = new FbsConsumer.LayersChangeNotification();
                    data.body(notification);
                    const layers = notification.layers()
                        ? parseConsumerLayers(notification.layers())
                        : undefined;
                    this.#currentLayers = layers;
                    this.safeEmit('layerschange', layers);
                    // Emit observer event.
                    this.#observer.safeEmit('layerschange', layers);
                    break;
                }
                case notification_1.Event.CONSUMER_TRACE: {
                    const notification = new FbsConsumer.TraceNotification();
                    data.body(notification);
                    const trace = parseTraceEventData(notification);
                    this.safeEmit('trace', trace);
                    // Emit observer event.
                    this.observer.safeEmit('trace', trace);
                    this.safeEmit('trace', trace);
                    // Emit observer event.
                    this.#observer.safeEmit('trace', trace);
                    break;
                }
                case notification_1.Event.CONSUMER_RTP: {
                    if (this.#closed) {
                        break;
                    }
                    const notification = new FbsConsumer.RtpNotification();
                    data.body(notification);
                    this.safeEmit('rtp', Buffer.from(notification.dataArray()));
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s"', event);
                }
            }
        });
    }
}
exports.Consumer = Consumer;
function parseTraceEventData(trace) {
    let info;
    if (trace.infoType() !== FbsConsumer.TraceInfo.NONE) {
        const accessor = trace.info.bind(trace);
        info = FbsConsumerTraceInfo.unionToTraceInfo(trace.infoType(), accessor);
        trace.info(info);
    }
    return {
        type: consumerTraceEventTypeFromFbs(trace.type()),
        timestamp: Number(trace.timestamp()),
        direction: trace.direction() === common_1.TraceDirection.DIRECTION_IN ? 'in' : 'out',
        info: info ? info.unpack() : undefined,
    };
}
exports.parseTraceEventData = parseTraceEventData;
function consumerTraceEventTypeToFbs(eventType) {
    switch (eventType) {
        case 'keyframe': {
            return FbsConsumer.TraceEventType.KEYFRAME;
        }
        case 'fir': {
            return FbsConsumer.TraceEventType.FIR;
        }
        case 'nack': {
            return FbsConsumer.TraceEventType.NACK;
        }
        case 'pli': {
            return FbsConsumer.TraceEventType.PLI;
        }
        case 'rtp': {
            return FbsConsumer.TraceEventType.RTP;
        }
        default: {
            throw new TypeError(`invalid ConsumerTraceEventType: ${eventType}`);
        }
    }
}
function consumerTraceEventTypeFromFbs(traceType) {
    switch (traceType) {
        case FbsConsumer.TraceEventType.KEYFRAME: {
            return 'keyframe';
        }
        case FbsConsumer.TraceEventType.FIR: {
            return 'fir';
        }
        case FbsConsumer.TraceEventType.NACK: {
            return 'nack';
        }
        case FbsConsumer.TraceEventType.PLI: {
            return 'pli';
        }
        case FbsConsumer.TraceEventType.RTP: {
            return 'rtp';
        }
        default: {
            throw new TypeError(`invalid FbsConsumer.TraceEventType: ${traceType}`);
        }
    }
}
function parseConsumerLayers(data) {
    const spatialLayer = data.spatialLayer();
    const temporalLayer = data.temporalLayer() !== null ? data.temporalLayer() : undefined;
    return {
        spatialLayer,
        temporalLayer,
    };
}
function parseRtpStreamParameters(data) {
    return {
        encodingIdx: data.encodingIdx(),
        ssrc: data.ssrc(),
        payloadType: data.payloadType(),
        mimeType: data.mimeType(),
        clockRate: data.clockRate(),
        rid: data.rid().length > 0 ? data.rid() : undefined,
        cname: data.cname(),
        rtxSsrc: data.rtxSsrc() !== null ? data.rtxSsrc() : undefined,
        rtxPayloadType: data.rtxPayloadType() !== null ? data.rtxPayloadType() : undefined,
        useNack: data.useNack(),
        usePli: data.usePli(),
        useFir: data.useFir(),
        useInBandFec: data.useInBandFec(),
        useDtx: data.useDtx(),
        spatialLayers: data.spatialLayers(),
        temporalLayers: data.temporalLayers(),
    };
}
function parseRtxStreamParameters(data) {
    return {
        ssrc: data.ssrc(),
        payloadType: data.payloadType(),
        mimeType: data.mimeType(),
        clockRate: data.clockRate(),
        rrid: data.rrid().length > 0 ? data.rrid() : undefined,
        cname: data.cname(),
    };
}
function parseRtxStream(data) {
    const params = parseRtxStreamParameters(data.params());
    return {
        params,
    };
}
function parseRtpStream(data) {
    const params = parseRtpStreamParameters(data.params());
    let rtxStream;
    if (data.rtxStream()) {
        rtxStream = parseRtxStream(data.rtxStream());
    }
    return {
        params,
        score: data.score(),
        rtxStream,
    };
}
function parseBaseConsumerDump(data) {
    return {
        id: data.id(),
        producerId: data.producerId(),
        kind: data.kind() === FbsRtpParameters.MediaKind.AUDIO ? 'audio' : 'video',
        rtpParameters: (0, RtpParameters_1.parseRtpParameters)(data.rtpParameters()),
        consumableRtpEncodings: data.consumableRtpEncodingsLength() > 0
            ? utils.parseVector(data, 'consumableRtpEncodings', RtpParameters_1.parseRtpEncodingParameters)
            : undefined,
        traceEventTypes: utils.parseVector(data, 'traceEventTypes', consumerTraceEventTypeFromFbs),
        supportedCodecPayloadTypes: utils.parseVector(data, 'supportedCodecPayloadTypes'),
        paused: data.paused(),
        producerPaused: data.producerPaused(),
        priority: data.priority(),
    };
}
function parseSimpleConsumerDump(data) {
    const base = parseBaseConsumerDump(data.base());
    const rtpStream = parseRtpStream(data.rtpStreams(0));
    return {
        ...base,
        type: 'simple',
        rtpStream,
    };
}
function parseSimulcastConsumerDump(data) {
    const base = parseBaseConsumerDump(data.base());
    const rtpStream = parseRtpStream(data.rtpStreams(0));
    return {
        ...base,
        type: 'simulcast',
        rtpStream,
        preferredSpatialLayer: data.preferredSpatialLayer(),
        targetSpatialLayer: data.targetSpatialLayer(),
        currentSpatialLayer: data.currentSpatialLayer(),
        preferredTemporalLayer: data.preferredTemporalLayer(),
        targetTemporalLayer: data.targetTemporalLayer(),
        currentTemporalLayer: data.currentTemporalLayer(),
    };
}
function parseSvcConsumerDump(data) {
    const dump = parseSimulcastConsumerDump(data);
    dump.type = 'svc';
    return dump;
}
function parsePipeConsumerDump(data) {
    const base = parseBaseConsumerDump(data.base());
    const rtpStreams = utils.parseVector(data, 'rtpStreams', parseRtpStream);
    return {
        ...base,
        type: 'pipe',
        rtpStreams,
    };
}
function parseConsumerDumpResponse(data) {
    const type = data.data().base().type();
    switch (type) {
        case rtp_parameters_1.Type.SIMPLE: {
            const dump = new FbsConsumer.ConsumerDump();
            data.data(dump);
            return parseSimpleConsumerDump(dump);
        }
        case rtp_parameters_1.Type.SIMULCAST: {
            const dump = new FbsConsumer.ConsumerDump();
            data.data(dump);
            return parseSimulcastConsumerDump(dump);
        }
        case rtp_parameters_1.Type.SVC: {
            const dump = new FbsConsumer.ConsumerDump();
            data.data(dump);
            return parseSvcConsumerDump(dump);
        }
        case rtp_parameters_1.Type.PIPE: {
            const dump = new FbsConsumer.ConsumerDump();
            data.data(dump);
            return parsePipeConsumerDump(dump);
        }
        default: {
            throw new TypeError(`invalid Consumer type: ${type}`);
        }
    }
}
function parseConsumerStats(binary) {
    return utils.parseVector(binary, 'stats', RtpStream_1.parseRtpStreamStats);
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/DataConsumer.js":
/*!*************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/DataConsumer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseDataConsumerDumpResponse = exports.dataConsumerTypeFromFbs = exports.dataConsumerTypeToFbs = exports.DataConsumer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const SctpParameters_1 = __webpack_require__(/*! ./SctpParameters */ "../../node_modules/mediasoup/node/lib/SctpParameters.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsDataConsumer = __webpack_require__(/*! ./fbs/data-consumer */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer.js");
const FbsDataProducer = __webpack_require__(/*! ./fbs/data-producer */ "../../node_modules/mediasoup/node/lib/fbs/data-producer.js");
const logger = new Logger_1.Logger('DataConsumer');
class DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Internal data.
    #internal;
    // DataConsumer data.
    #data;
    // Channel instance.
    #channel;
    // Closed flag.
    #closed = false;
    // Paused flag.
    #paused = false;
    // Associated DataProducer paused flag.
    #dataProducerPaused = false;
    // Subchannels subscribed to.
    #subchannels;
    // Custom app data.
    #appData;
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     */
    constructor({ internal, data, channel, paused, dataProducerPaused, subchannels, appData, }) {
        super();
        logger.debug('constructor()');
        this.#internal = internal;
        this.#data = data;
        this.#channel = channel;
        this.#paused = paused;
        this.#dataProducerPaused = dataProducerPaused;
        this.#subchannels = subchannels;
        this.#appData = appData || {};
        this.handleWorkerNotifications();
    }
    /**
     * DataConsumer id.
     */
    get id() {
        return this.#internal.dataConsumerId;
    }
    /**
     * Associated DataProducer id.
     */
    get dataProducerId() {
        return this.#data.dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * DataConsumer type.
     */
    get type() {
        return this.#data.type;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this.#data.sctpStreamParameters;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this.#data.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this.#data.protocol;
    }
    /**
     * Whether the DataConsumer is paused.
     */
    get paused() {
        return this.#paused;
    }
    /**
     * Whether the associate DataProducer is paused.
     */
    get dataProducerPaused() {
        return this.#dataProducerPaused;
    }
    /**
     * Get current subchannels this data consumer is subscribed to.
     */
    get subchannels() {
        return Array.from(this.#subchannels);
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * Close the DataConsumer.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.#channel.removeAllListeners(this.#internal.dataConsumerId);
        /* Build Request. */
        const requestOffset = new FbsTransport.CloseDataConsumerRequestT(this.#internal.dataConsumerId).pack(this.#channel.bufferBuilder);
        this.#channel
            .request(FbsRequest.Method.TRANSPORT_CLOSE_DATACONSUMER, FbsRequest.Body.Transport_CloseDataConsumerRequest, requestOffset, this.#internal.transportId)
            .catch(() => { });
        this.emit('@close');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     *
     * @private
     */
    transportClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('transportClosed()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.#channel.removeAllListeners(this.#internal.dataConsumerId);
        this.safeEmit('transportclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Dump DataConsumer.
     */
    async dump() {
        logger.debug('dump()');
        const response = await this.#channel.request(FbsRequest.Method.DATACONSUMER_DUMP, undefined, undefined, this.#internal.dataConsumerId);
        /* Decode Response. */
        const dumpResponse = new FbsDataConsumer.DumpResponse();
        response.body(dumpResponse);
        return parseDataConsumerDumpResponse(dumpResponse);
    }
    /**
     * Get DataConsumer stats.
     */
    async getStats() {
        logger.debug('getStats()');
        const response = await this.#channel.request(FbsRequest.Method.DATACONSUMER_GET_STATS, undefined, undefined, this.#internal.dataConsumerId);
        /* Decode Response. */
        const data = new FbsDataConsumer.GetStatsResponse();
        response.body(data);
        return [parseDataConsumerStats(data)];
    }
    /**
     * Pause the DataConsumer.
     */
    async pause() {
        logger.debug('pause()');
        await this.#channel.request(FbsRequest.Method.DATACONSUMER_PAUSE, undefined, undefined, this.#internal.dataConsumerId);
        const wasPaused = this.#paused;
        this.#paused = true;
        // Emit observer event.
        if (!wasPaused && !this.#dataProducerPaused) {
            this.#observer.safeEmit('pause');
        }
    }
    /**
     * Resume the DataConsumer.
     */
    async resume() {
        logger.debug('resume()');
        await this.#channel.request(FbsRequest.Method.DATACONSUMER_RESUME, undefined, undefined, this.#internal.dataConsumerId);
        const wasPaused = this.#paused;
        this.#paused = false;
        // Emit observer event.
        if (wasPaused && !this.#dataProducerPaused) {
            this.#observer.safeEmit('resume');
        }
    }
    /**
     * Set buffered amount low threshold.
     */
    async setBufferedAmountLowThreshold(threshold) {
        logger.debug('setBufferedAmountLowThreshold() [threshold:%s]', threshold);
        /* Build Request. */
        const requestOffset = FbsDataConsumer.SetBufferedAmountLowThresholdRequest.createSetBufferedAmountLowThresholdRequest(this.#channel.bufferBuilder, threshold);
        await this.#channel.request(FbsRequest.Method.DATACONSUMER_SET_BUFFERED_AMOUNT_LOW_THRESHOLD, FbsRequest.Body.DataConsumer_SetBufferedAmountLowThresholdRequest, requestOffset, this.#internal.dataConsumerId);
    }
    /**
     * Send data.
     */
    async send(message, ppid) {
        if (typeof message !== 'string' && !Buffer.isBuffer(message)) {
            throw new TypeError('message must be a string or a Buffer');
        }
        /*
         * +-------------------------------+----------+
         * | Value                         | SCTP     |
         * |                               | PPID     |
         * +-------------------------------+----------+
         * | WebRTC String                 | 51       |
         * | WebRTC Binary Partial         | 52       |
         * | (Deprecated)                  |          |
         * | WebRTC Binary                 | 53       |
         * | WebRTC String Partial         | 54       |
         * | (Deprecated)                  |          |
         * | WebRTC String Empty           | 56       |
         * | WebRTC Binary Empty           | 57       |
         * +-------------------------------+----------+
         */
        if (typeof ppid !== 'number') {
            ppid =
                typeof message === 'string'
                    ? message.length > 0
                        ? 51
                        : 56
                    : message.length > 0
                        ? 53
                        : 57;
        }
        // Ensure we honor PPIDs.
        if (ppid === 56) {
            message = ' ';
        }
        else if (ppid === 57) {
            message = Buffer.alloc(1);
        }
        const builder = this.#channel.bufferBuilder;
        let dataOffset = 0;
        if (typeof message === 'string') {
            message = Buffer.from(message);
        }
        dataOffset = FbsDataConsumer.SendRequest.createDataVector(builder, message);
        const requestOffset = FbsDataConsumer.SendRequest.createSendRequest(builder, ppid, dataOffset);
        await this.#channel.request(FbsRequest.Method.DATACONSUMER_SEND, FbsRequest.Body.DataConsumer_SendRequest, requestOffset, this.#internal.dataConsumerId);
    }
    /**
     * Get buffered amount size.
     */
    async getBufferedAmount() {
        logger.debug('getBufferedAmount()');
        const response = await this.#channel.request(FbsRequest.Method.DATACONSUMER_GET_BUFFERED_AMOUNT, undefined, undefined, this.#internal.dataConsumerId);
        const data = new FbsDataConsumer.GetBufferedAmountResponse();
        response.body(data);
        return data.bufferedAmount();
    }
    /**
     * Set subchannels.
     */
    async setSubchannels(subchannels) {
        logger.debug('setSubchannels()');
        /* Build Request. */
        const requestOffset = new FbsDataConsumer.SetSubchannelsRequestT(subchannels).pack(this.#channel.bufferBuilder);
        const response = await this.#channel.request(FbsRequest.Method.DATACONSUMER_SET_SUBCHANNELS, FbsRequest.Body.DataConsumer_SetSubchannelsRequest, requestOffset, this.#internal.dataConsumerId);
        /* Decode Response. */
        const data = new FbsDataConsumer.SetSubchannelsResponse();
        response.body(data);
        // Update subchannels.
        this.#subchannels = utils.parseVector(data, 'subchannels');
    }
    /**
     * Add a subchannel.
     */
    async addSubchannel(subchannel) {
        logger.debug('addSubchannel()');
        /* Build Request. */
        const requestOffset = FbsDataConsumer.AddSubchannelRequest.createAddSubchannelRequest(this.#channel.bufferBuilder, subchannel);
        const response = await this.#channel.request(FbsRequest.Method.DATACONSUMER_ADD_SUBCHANNEL, FbsRequest.Body.DataConsumer_AddSubchannelRequest, requestOffset, this.#internal.dataConsumerId);
        /* Decode Response. */
        const data = new FbsDataConsumer.AddSubchannelResponse();
        response.body(data);
        // Update subchannels.
        this.#subchannels = utils.parseVector(data, 'subchannels');
    }
    /**
     * Remove a subchannel.
     */
    async removeSubchannel(subchannel) {
        logger.debug('removeSubchannel()');
        /* Build Request. */
        const requestOffset = FbsDataConsumer.RemoveSubchannelRequest.createRemoveSubchannelRequest(this.#channel.bufferBuilder, subchannel);
        const response = await this.#channel.request(FbsRequest.Method.DATACONSUMER_REMOVE_SUBCHANNEL, FbsRequest.Body.DataConsumer_RemoveSubchannelRequest, requestOffset, this.#internal.dataConsumerId);
        /* Decode Response. */
        const data = new FbsDataConsumer.RemoveSubchannelResponse();
        response.body(data);
        // Update subchannels.
        this.#subchannels = utils.parseVector(data, 'subchannels');
    }
    handleWorkerNotifications() {
        this.#channel.on(this.#internal.dataConsumerId, (event, data) => {
            switch (event) {
                case notification_1.Event.DATACONSUMER_DATAPRODUCER_CLOSE: {
                    if (this.#closed) {
                        break;
                    }
                    this.#closed = true;
                    // Remove notification subscriptions.
                    this.#channel.removeAllListeners(this.#internal.dataConsumerId);
                    this.emit('@dataproducerclose');
                    this.safeEmit('dataproducerclose');
                    // Emit observer event.
                    this.#observer.safeEmit('close');
                    break;
                }
                case notification_1.Event.DATACONSUMER_DATAPRODUCER_PAUSE: {
                    if (this.#dataProducerPaused) {
                        break;
                    }
                    this.#dataProducerPaused = true;
                    this.safeEmit('dataproducerpause');
                    // Emit observer event.
                    if (!this.#paused) {
                        this.#observer.safeEmit('pause');
                    }
                    break;
                }
                case notification_1.Event.DATACONSUMER_DATAPRODUCER_RESUME: {
                    if (!this.#dataProducerPaused) {
                        break;
                    }
                    this.#dataProducerPaused = false;
                    this.safeEmit('dataproducerresume');
                    // Emit observer event.
                    if (!this.#paused) {
                        this.#observer.safeEmit('resume');
                    }
                    break;
                }
                case notification_1.Event.DATACONSUMER_SCTP_SENDBUFFER_FULL: {
                    this.safeEmit('sctpsendbufferfull');
                    break;
                }
                case notification_1.Event.DATACONSUMER_BUFFERED_AMOUNT_LOW: {
                    const notification = new FbsDataConsumer.BufferedAmountLowNotification();
                    data.body(notification);
                    const bufferedAmount = notification.bufferedAmount();
                    this.safeEmit('bufferedamountlow', bufferedAmount);
                    break;
                }
                case notification_1.Event.DATACONSUMER_MESSAGE: {
                    if (this.#closed) {
                        break;
                    }
                    const notification = new FbsDataConsumer.MessageNotification();
                    data.body(notification);
                    this.safeEmit('message', Buffer.from(notification.dataArray()), notification.ppid());
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s" in channel listener', event);
                }
            }
        });
    }
}
exports.DataConsumer = DataConsumer;
function dataConsumerTypeToFbs(type) {
    switch (type) {
        case 'sctp': {
            return FbsDataProducer.Type.SCTP;
        }
        case 'direct': {
            return FbsDataProducer.Type.DIRECT;
        }
        default: {
            throw new TypeError('invalid DataConsumerType: ${type}');
        }
    }
}
exports.dataConsumerTypeToFbs = dataConsumerTypeToFbs;
function dataConsumerTypeFromFbs(type) {
    switch (type) {
        case FbsDataProducer.Type.SCTP: {
            return 'sctp';
        }
        case FbsDataProducer.Type.DIRECT: {
            return 'direct';
        }
    }
}
exports.dataConsumerTypeFromFbs = dataConsumerTypeFromFbs;
function parseDataConsumerDumpResponse(data) {
    return {
        id: data.id(),
        dataProducerId: data.dataProducerId(),
        type: dataConsumerTypeFromFbs(data.type()),
        sctpStreamParameters: data.sctpStreamParameters() !== null
            ? (0, SctpParameters_1.parseSctpStreamParameters)(data.sctpStreamParameters())
            : undefined,
        label: data.label(),
        protocol: data.protocol(),
        bufferedAmountLowThreshold: data.bufferedAmountLowThreshold(),
        paused: data.paused(),
        dataProducerPaused: data.dataProducerPaused(),
        subchannels: utils.parseVector(data, 'subchannels'),
    };
}
exports.parseDataConsumerDumpResponse = parseDataConsumerDumpResponse;
function parseDataConsumerStats(binary) {
    return {
        type: 'data-consumer',
        timestamp: Number(binary.timestamp()),
        label: binary.label(),
        protocol: binary.protocol(),
        messagesSent: Number(binary.messagesSent()),
        bytesSent: Number(binary.bytesSent()),
        bufferedAmount: binary.bufferedAmount(),
    };
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/DataProducer.js":
/*!*************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/DataProducer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseDataProducerDumpResponse = exports.dataProducerTypeFromFbs = exports.dataProducerTypeToFbs = exports.DataProducer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const SctpParameters_1 = __webpack_require__(/*! ./SctpParameters */ "../../node_modules/mediasoup/node/lib/SctpParameters.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsNotification = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsDataProducer = __webpack_require__(/*! ./fbs/data-producer */ "../../node_modules/mediasoup/node/lib/fbs/data-producer.js");
const logger = new Logger_1.Logger('DataProducer');
class DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Internal data.
    #internal;
    // DataProducer data.
    #data;
    // Channel instance.
    #channel;
    // Closed flag.
    #closed = false;
    // Paused flag.
    #paused = false;
    // Custom app data.
    #appData;
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     */
    constructor({ internal, data, channel, paused, appData, }) {
        super();
        logger.debug('constructor()');
        this.#internal = internal;
        this.#data = data;
        this.#channel = channel;
        this.#paused = paused;
        this.#appData = appData || {};
        this.handleWorkerNotifications();
    }
    /**
     * DataProducer id.
     */
    get id() {
        return this.#internal.dataProducerId;
    }
    /**
     * Whether the DataProducer is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * DataProducer type.
     */
    get type() {
        return this.#data.type;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this.#data.sctpStreamParameters;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this.#data.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this.#data.protocol;
    }
    /**
     * Whether the DataProducer is paused.
     */
    get paused() {
        return this.#paused;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * Close the DataProducer.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.#channel.removeAllListeners(this.#internal.dataProducerId);
        /* Build Request. */
        const requestOffset = new FbsTransport.CloseDataProducerRequestT(this.#internal.dataProducerId).pack(this.#channel.bufferBuilder);
        this.#channel
            .request(FbsRequest.Method.TRANSPORT_CLOSE_DATAPRODUCER, FbsRequest.Body.Transport_CloseDataProducerRequest, requestOffset, this.#internal.transportId)
            .catch(() => { });
        this.emit('@close');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     *
     * @private
     */
    transportClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('transportClosed()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.#channel.removeAllListeners(this.#internal.dataProducerId);
        this.safeEmit('transportclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Dump DataProducer.
     */
    async dump() {
        logger.debug('dump()');
        const response = await this.#channel.request(FbsRequest.Method.DATAPRODUCER_DUMP, undefined, undefined, this.#internal.dataProducerId);
        /* Decode Response. */
        const produceResponse = new FbsDataProducer.DumpResponse();
        response.body(produceResponse);
        return parseDataProducerDumpResponse(produceResponse);
    }
    /**
     * Get DataProducer stats.
     */
    async getStats() {
        logger.debug('getStats()');
        const response = await this.#channel.request(FbsRequest.Method.DATAPRODUCER_GET_STATS, undefined, undefined, this.#internal.dataProducerId);
        /* Decode Response. */
        const data = new FbsDataProducer.GetStatsResponse();
        response.body(data);
        return [parseDataProducerStats(data)];
    }
    /**
     * Pause the DataProducer.
     */
    async pause() {
        logger.debug('pause()');
        await this.#channel.request(FbsRequest.Method.DATAPRODUCER_PAUSE, undefined, undefined, this.#internal.dataProducerId);
        const wasPaused = this.#paused;
        this.#paused = true;
        // Emit observer event.
        if (!wasPaused) {
            this.#observer.safeEmit('pause');
        }
    }
    /**
     * Resume the DataProducer.
     */
    async resume() {
        logger.debug('resume()');
        await this.#channel.request(FbsRequest.Method.DATAPRODUCER_RESUME, undefined, undefined, this.#internal.dataProducerId);
        const wasPaused = this.#paused;
        this.#paused = false;
        // Emit observer event.
        if (wasPaused) {
            this.#observer.safeEmit('resume');
        }
    }
    /**
     * Send data (just valid for DataProducers created on a DirectTransport).
     */
    send(message, ppid, subchannels, requiredSubchannel) {
        if (typeof message !== 'string' && !Buffer.isBuffer(message)) {
            throw new TypeError('message must be a string or a Buffer');
        }
        /*
         * +-------------------------------+----------+
         * | Value                         | SCTP     |
         * |                               | PPID     |
         * +-------------------------------+----------+
         * | WebRTC String                 | 51       |
         * | WebRTC Binary Partial         | 52       |
         * | (Deprecated)                  |          |
         * | WebRTC Binary                 | 53       |
         * | WebRTC String Partial         | 54       |
         * | (Deprecated)                  |          |
         * | WebRTC String Empty           | 56       |
         * | WebRTC Binary Empty           | 57       |
         * +-------------------------------+----------+
         */
        if (typeof ppid !== 'number') {
            ppid =
                typeof message === 'string'
                    ? message.length > 0
                        ? 51
                        : 56
                    : message.length > 0
                        ? 53
                        : 57;
        }
        // Ensure we honor PPIDs.
        if (ppid === 56) {
            message = ' ';
        }
        else if (ppid === 57) {
            message = Buffer.alloc(1);
        }
        const builder = this.#channel.bufferBuilder;
        let dataOffset = 0;
        const subchannelsOffset = FbsDataProducer.SendNotification.createSubchannelsVector(builder, subchannels ?? []);
        if (typeof message === 'string') {
            message = Buffer.from(message);
        }
        dataOffset = FbsDataProducer.SendNotification.createDataVector(builder, message);
        const notificationOffset = FbsDataProducer.SendNotification.createSendNotification(builder, ppid, dataOffset, subchannelsOffset, requiredSubchannel ?? null);
        this.#channel.notify(FbsNotification.Event.DATAPRODUCER_SEND, FbsNotification.Body.DataProducer_SendNotification, notificationOffset, this.#internal.dataProducerId);
    }
    handleWorkerNotifications() {
        // No need to subscribe to any event.
    }
}
exports.DataProducer = DataProducer;
function dataProducerTypeToFbs(type) {
    switch (type) {
        case 'sctp': {
            return FbsDataProducer.Type.SCTP;
        }
        case 'direct': {
            return FbsDataProducer.Type.DIRECT;
        }
        default: {
            throw new TypeError('invalid DataConsumerType: ${type}');
        }
    }
}
exports.dataProducerTypeToFbs = dataProducerTypeToFbs;
function dataProducerTypeFromFbs(type) {
    switch (type) {
        case FbsDataProducer.Type.SCTP: {
            return 'sctp';
        }
        case FbsDataProducer.Type.DIRECT: {
            return 'direct';
        }
    }
}
exports.dataProducerTypeFromFbs = dataProducerTypeFromFbs;
function parseDataProducerDumpResponse(data) {
    return {
        id: data.id(),
        type: dataProducerTypeFromFbs(data.type()),
        sctpStreamParameters: data.sctpStreamParameters() !== null
            ? (0, SctpParameters_1.parseSctpStreamParameters)(data.sctpStreamParameters())
            : undefined,
        label: data.label(),
        protocol: data.protocol(),
        paused: data.paused(),
    };
}
exports.parseDataProducerDumpResponse = parseDataProducerDumpResponse;
function parseDataProducerStats(binary) {
    return {
        type: 'data-producer',
        timestamp: Number(binary.timestamp()),
        label: binary.label(),
        protocol: binary.protocol(),
        messagesReceived: Number(binary.messagesReceived()),
        bytesReceived: Number(binary.bytesReceived()),
    };
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/DirectTransport.js":
/*!****************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/DirectTransport.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseDirectTransportDumpResponse = exports.DirectTransport = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/mediasoup/node/lib/errors.js");
const Transport_1 = __webpack_require__(/*! ./Transport */ "../../node_modules/mediasoup/node/lib/Transport.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsDirectTransport = __webpack_require__(/*! ./fbs/direct-transport */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsNotification = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const logger = new Logger_1.Logger('DirectTransport');
class DirectTransport extends Transport_1.Transport {
    // DirectTransport data.
    #data;
    /**
     * @private
     */
    constructor(options) {
        super(options);
        logger.debug('constructor()');
        this.#data = {
        // Nothing.
        };
        this.handleWorkerNotifications();
    }
    /**
     * Close the DirectTransport.
     *
     * @override
     */
    close() {
        if (this.closed) {
            return;
        }
        super.close();
    }
    /**
     * Router was closed.
     *
     * @private
     * @override
     */
    routerClosed() {
        if (this.closed) {
            return;
        }
        super.routerClosed();
    }
    /**
     * Dump Transport.
     */
    async dump() {
        logger.debug('dump()');
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_DUMP, undefined, undefined, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsDirectTransport.DumpResponse();
        response.body(data);
        return parseDirectTransportDumpResponse(data);
    }
    /**
     * Get DirectTransport stats.
     *
     * @override
     */
    async getStats() {
        logger.debug('getStats()');
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_GET_STATS, undefined, undefined, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsDirectTransport.GetStatsResponse();
        response.body(data);
        return [parseGetStatsResponse(data)];
    }
    /**
     * NO-OP method in DirectTransport.
     *
     * @override
     */
    async connect() {
        logger.debug('connect()');
    }
    /**
     * @override
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setMaxIncomingBitrate(bitrate) {
        throw new errors_1.UnsupportedError('setMaxIncomingBitrate() not implemented in DirectTransport');
    }
    /**
     * @override
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setMaxOutgoingBitrate(bitrate) {
        throw new errors_1.UnsupportedError('setMaxOutgoingBitrate() not implemented in DirectTransport');
    }
    /**
     * @override
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setMinOutgoingBitrate(bitrate) {
        throw new errors_1.UnsupportedError('setMinOutgoingBitrate() not implemented in DirectTransport');
    }
    /**
     * Send RTCP packet.
     */
    sendRtcp(rtcpPacket) {
        if (!Buffer.isBuffer(rtcpPacket)) {
            throw new TypeError('rtcpPacket must be a Buffer');
        }
        const builder = this.channel.bufferBuilder;
        const dataOffset = FbsTransport.SendRtcpNotification.createDataVector(builder, rtcpPacket);
        const notificationOffset = FbsTransport.SendRtcpNotification.createSendRtcpNotification(builder, dataOffset);
        this.channel.notify(FbsNotification.Event.TRANSPORT_SEND_RTCP, FbsNotification.Body.Transport_SendRtcpNotification, notificationOffset, this.internal.transportId);
    }
    handleWorkerNotifications() {
        this.channel.on(this.internal.transportId, (event, data) => {
            switch (event) {
                case notification_1.Event.TRANSPORT_TRACE: {
                    const notification = new FbsTransport.TraceNotification();
                    data.body(notification);
                    const trace = (0, Transport_1.parseTransportTraceEventData)(notification);
                    this.safeEmit('trace', trace);
                    // Emit observer event.
                    this.observer.safeEmit('trace', trace);
                    break;
                }
                case notification_1.Event.DIRECTTRANSPORT_RTCP: {
                    if (this.closed) {
                        break;
                    }
                    const notification = new FbsDirectTransport.RtcpNotification();
                    data.body(notification);
                    this.safeEmit('rtcp', Buffer.from(notification.dataArray()));
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s"', event);
                }
            }
        });
    }
}
exports.DirectTransport = DirectTransport;
function parseDirectTransportDumpResponse(binary) {
    return (0, Transport_1.parseBaseTransportDump)(binary.base());
}
exports.parseDirectTransportDumpResponse = parseDirectTransportDumpResponse;
function parseGetStatsResponse(binary) {
    const base = (0, Transport_1.parseBaseTransportStats)(binary.base());
    return {
        ...base,
        type: 'direct-transport',
    };
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnhancedEventEmitter = void 0;
const node_events_1 = __webpack_require__(/*! node:events */ "node:events");
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const logger = new Logger_1.Logger('EnhancedEventEmitter');
class EnhancedEventEmitter extends node_events_1.EventEmitter {
    constructor() {
        super();
        this.setMaxListeners(Infinity);
    }
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * Special addition to the EventEmitter API.
     */
    safeEmit(eventName, ...args) {
        try {
            return super.emit(eventName, ...args);
        }
        catch (error) {
            logger.error('safeEmit() | event listener threw an error [eventName:%s]:%o', eventName, error);
            try {
                super.emit('listenererror', eventName, error);
            }
            catch (error2) {
                // Ignore it.
            }
            return Boolean(super.listenerCount(eventName));
        }
    }
    on(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    off(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    addListener(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    prependListener(eventName, listener) {
        super.prependListener(eventName, listener);
        return this;
    }
    once(eventName, listener) {
        super.once(eventName, listener);
        return this;
    }
    prependOnceListener(eventName, listener) {
        super.prependOnceListener(eventName, listener);
        return this;
    }
    removeListener(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    removeAllListeners(eventName) {
        super.removeAllListeners(eventName);
        return this;
    }
    listenerCount(eventName) {
        return super.listenerCount(eventName);
    }
    listeners(eventName) {
        return super.listeners(eventName);
    }
    rawListeners(eventName) {
        return super.rawListeners(eventName);
    }
}
exports.EnhancedEventEmitter = EnhancedEventEmitter;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/Logger.js":
/*!*******************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/Logger.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/mediasoup/node_modules/debug/src/index.js");
const APP_NAME = 'mediasoup';
class Logger {
    #debug;
    #warn;
    #error;
    constructor(prefix) {
        if (prefix) {
            this.#debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this.#warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this.#error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this.#debug = (0, debug_1.default)(APP_NAME);
            this.#warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this.#error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this.#debug.log = console.info.bind(console);
        this.#warn.log = console.warn.bind(console);
        this.#error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this.#debug;
    }
    get warn() {
        return this.#warn;
    }
    get error() {
        return this.#error;
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/PipeTransport.js":
/*!**************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/PipeTransport.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parsePipeTransportDumpResponse = exports.PipeTransport = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const ortc = __webpack_require__(/*! ./ortc */ "../../node_modules/mediasoup/node/lib/ortc.js");
const Transport_1 = __webpack_require__(/*! ./Transport */ "../../node_modules/mediasoup/node/lib/Transport.js");
const Consumer_1 = __webpack_require__(/*! ./Consumer */ "../../node_modules/mediasoup/node/lib/Consumer.js");
const RtpParameters_1 = __webpack_require__(/*! ./RtpParameters */ "../../node_modules/mediasoup/node/lib/RtpParameters.js");
const SrtpParameters_1 = __webpack_require__(/*! ./SrtpParameters */ "../../node_modules/mediasoup/node/lib/SrtpParameters.js");
const utils_1 = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const media_kind_1 = __webpack_require__(/*! ./fbs/rtp-parameters/media-kind */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js");
const FbsRtpParameters = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsPipeTransport = __webpack_require__(/*! ./fbs/pipe-transport */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport.js");
const logger = new Logger_1.Logger('PipeTransport');
class PipeTransport extends Transport_1.Transport {
    // PipeTransport data.
    #data;
    /**
     * @private
     */
    constructor(options) {
        super(options);
        logger.debug('constructor()');
        const { data } = options;
        this.#data = {
            tuple: data.tuple,
            sctpParameters: data.sctpParameters,
            sctpState: data.sctpState,
            rtx: data.rtx,
            srtpParameters: data.srtpParameters,
        };
        this.handleWorkerNotifications();
    }
    /**
     * Transport tuple.
     */
    get tuple() {
        return this.#data.tuple;
    }
    /**
     * SCTP parameters.
     */
    get sctpParameters() {
        return this.#data.sctpParameters;
    }
    /**
     * SCTP state.
     */
    get sctpState() {
        return this.#data.sctpState;
    }
    /**
     * SRTP parameters.
     */
    get srtpParameters() {
        return this.#data.srtpParameters;
    }
    /**
     * Close the PipeTransport.
     *
     * @override
     */
    close() {
        if (this.closed) {
            return;
        }
        if (this.#data.sctpState) {
            this.#data.sctpState = 'closed';
        }
        super.close();
    }
    /**
     * Router was closed.
     *
     * @private
     * @override
     */
    routerClosed() {
        if (this.closed) {
            return;
        }
        if (this.#data.sctpState) {
            this.#data.sctpState = 'closed';
        }
        super.routerClosed();
    }
    /**
     * Get PipeTransport stats.
     *
     * @override
     */
    async getStats() {
        logger.debug('getStats()');
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_GET_STATS, undefined, undefined, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsPipeTransport.GetStatsResponse();
        response.body(data);
        return [parseGetStatsResponse(data)];
    }
    /**
     * Provide the PipeTransport remote parameters.
     *
     * @override
     */
    async connect({ ip, port, srtpParameters, }) {
        logger.debug('connect()');
        const requestOffset = createConnectRequest({
            builder: this.channel.bufferBuilder,
            ip,
            port,
            srtpParameters,
        });
        // Wait for response.
        const response = await this.channel.request(FbsRequest.Method.PIPETRANSPORT_CONNECT, FbsRequest.Body.PipeTransport_ConnectRequest, requestOffset, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsPipeTransport.ConnectResponse();
        response.body(data);
        // Update data.
        if (data.tuple()) {
            this.#data.tuple = (0, Transport_1.parseTuple)(data.tuple());
        }
    }
    /**
     * Create a pipe Consumer.
     *
     * @override
     */
    async consume({ producerId, appData, }) {
        logger.debug('consume()');
        if (!producerId || typeof producerId !== 'string') {
            throw new TypeError('missing producerId');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        const producer = this.getProducerById(producerId);
        if (!producer) {
            throw Error(`Producer with id "${producerId}" not found`);
        }
        // This may throw.
        const rtpParameters = ortc.getPipeConsumerRtpParameters({
            consumableRtpParameters: producer.consumableRtpParameters,
            enableRtx: this.#data.rtx,
        });
        const consumerId = (0, utils_1.generateUUIDv4)();
        const consumeRequestOffset = createConsumeRequest({
            builder: this.channel.bufferBuilder,
            consumerId,
            producer,
            rtpParameters,
        });
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_CONSUME, FbsRequest.Body.Transport_ConsumeRequest, consumeRequestOffset, this.internal.transportId);
        /* Decode Response. */
        const consumeResponse = new FbsTransport.ConsumeResponse();
        response.body(consumeResponse);
        const status = consumeResponse.unpack();
        const data = {
            producerId,
            kind: producer.kind,
            rtpParameters,
            type: 'pipe',
        };
        const consumer = new Consumer_1.Consumer({
            internal: {
                ...this.internal,
                consumerId,
            },
            data,
            channel: this.channel,
            appData,
            paused: status.paused,
            producerPaused: status.producerPaused,
        });
        this.consumers.set(consumer.id, consumer);
        consumer.on('@close', () => this.consumers.delete(consumer.id));
        consumer.on('@producerclose', () => this.consumers.delete(consumer.id));
        // Emit observer event.
        this.observer.safeEmit('newconsumer', consumer);
        return consumer;
    }
    handleWorkerNotifications() {
        this.channel.on(this.internal.transportId, (event, data) => {
            switch (event) {
                case notification_1.Event.TRANSPORT_SCTP_STATE_CHANGE: {
                    const notification = new FbsTransport.SctpStateChangeNotification();
                    data.body(notification);
                    const sctpState = (0, Transport_1.parseSctpState)(notification.sctpState());
                    this.#data.sctpState = sctpState;
                    this.safeEmit('sctpstatechange', sctpState);
                    // Emit observer event.
                    this.observer.safeEmit('sctpstatechange', sctpState);
                    break;
                }
                case notification_1.Event.TRANSPORT_TRACE: {
                    const notification = new FbsTransport.TraceNotification();
                    data.body(notification);
                    const trace = (0, Transport_1.parseTransportTraceEventData)(notification);
                    this.safeEmit('trace', trace);
                    // Emit observer event.
                    this.observer.safeEmit('trace', trace);
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s"', event);
                }
            }
        });
    }
}
exports.PipeTransport = PipeTransport;
/*
 * flatbuffers helpers.
 */
function parsePipeTransportDumpResponse(binary) {
    // Retrieve BaseTransportDump.
    const baseTransportDump = (0, Transport_1.parseBaseTransportDump)(binary.base());
    // Retrieve RTP Tuple.
    const tuple = (0, Transport_1.parseTuple)(binary.tuple());
    // Retrieve SRTP Parameters.
    let srtpParameters;
    if (binary.srtpParameters()) {
        srtpParameters = (0, SrtpParameters_1.parseSrtpParameters)(binary.srtpParameters());
    }
    return {
        ...baseTransportDump,
        tuple: tuple,
        rtx: binary.rtx(),
        srtpParameters: srtpParameters,
    };
}
exports.parsePipeTransportDumpResponse = parsePipeTransportDumpResponse;
function parseGetStatsResponse(binary) {
    const base = (0, Transport_1.parseBaseTransportStats)(binary.base());
    return {
        ...base,
        type: 'pipe-transport',
        tuple: (0, Transport_1.parseTuple)(binary.tuple()),
    };
}
function createConsumeRequest({ builder, consumerId, producer, rtpParameters, }) {
    // Build the request.
    const producerIdOffset = builder.createString(producer.id);
    const consumerIdOffset = builder.createString(consumerId);
    const rtpParametersOffset = (0, RtpParameters_1.serializeRtpParameters)(builder, rtpParameters);
    let consumableRtpEncodingsOffset;
    if (producer.consumableRtpParameters.encodings) {
        consumableRtpEncodingsOffset = (0, RtpParameters_1.serializeRtpEncodingParameters)(builder, producer.consumableRtpParameters.encodings);
    }
    const ConsumeRequest = FbsTransport.ConsumeRequest;
    // Create Consume Request.
    ConsumeRequest.startConsumeRequest(builder);
    ConsumeRequest.addConsumerId(builder, consumerIdOffset);
    ConsumeRequest.addProducerId(builder, producerIdOffset);
    ConsumeRequest.addKind(builder, producer.kind === 'audio' ? media_kind_1.MediaKind.AUDIO : media_kind_1.MediaKind.VIDEO);
    ConsumeRequest.addRtpParameters(builder, rtpParametersOffset);
    ConsumeRequest.addType(builder, FbsRtpParameters.Type.PIPE);
    if (consumableRtpEncodingsOffset) {
        ConsumeRequest.addConsumableRtpEncodings(builder, consumableRtpEncodingsOffset);
    }
    return ConsumeRequest.endConsumeRequest(builder);
}
function createConnectRequest({ builder, ip, port, srtpParameters, }) {
    let ipOffset = 0;
    let srtpParametersOffset = 0;
    if (ip) {
        ipOffset = builder.createString(ip);
    }
    // Serialize SrtpParameters.
    if (srtpParameters) {
        srtpParametersOffset = (0, SrtpParameters_1.serializeSrtpParameters)(builder, srtpParameters);
    }
    // Create PlainTransportConnectData.
    FbsPipeTransport.ConnectRequest.startConnectRequest(builder);
    FbsPipeTransport.ConnectRequest.addIp(builder, ipOffset);
    if (typeof port === 'number') {
        FbsPipeTransport.ConnectRequest.addPort(builder, port);
    }
    if (srtpParameters) {
        FbsPipeTransport.ConnectRequest.addSrtpParameters(builder, srtpParametersOffset);
    }
    return FbsPipeTransport.ConnectRequest.endConnectRequest(builder);
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/PlainTransport.js":
/*!***************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/PlainTransport.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parsePlainTransportDumpResponse = exports.PlainTransport = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const Transport_1 = __webpack_require__(/*! ./Transport */ "../../node_modules/mediasoup/node/lib/Transport.js");
const SrtpParameters_1 = __webpack_require__(/*! ./SrtpParameters */ "../../node_modules/mediasoup/node/lib/SrtpParameters.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsPlainTransport = __webpack_require__(/*! ./fbs/plain-transport */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport.js");
const logger = new Logger_1.Logger('PlainTransport');
class PlainTransport extends Transport_1.Transport {
    // PlainTransport data.
    #data;
    /**
     * @private
     */
    constructor(options) {
        super(options);
        logger.debug('constructor()');
        const { data } = options;
        this.#data = {
            rtcpMux: data.rtcpMux,
            comedia: data.comedia,
            tuple: data.tuple,
            rtcpTuple: data.rtcpTuple,
            sctpParameters: data.sctpParameters,
            sctpState: data.sctpState,
            srtpParameters: data.srtpParameters,
        };
        this.handleWorkerNotifications();
    }
    /**
     * Transport tuple.
     */
    get tuple() {
        return this.#data.tuple;
    }
    /**
     * Transport RTCP tuple.
     */
    get rtcpTuple() {
        return this.#data.rtcpTuple;
    }
    /**
     * SCTP parameters.
     */
    get sctpParameters() {
        return this.#data.sctpParameters;
    }
    /**
     * SCTP state.
     */
    get sctpState() {
        return this.#data.sctpState;
    }
    /**
     * SRTP parameters.
     */
    get srtpParameters() {
        return this.#data.srtpParameters;
    }
    /**
     * Close the PlainTransport.
     *
     * @override
     */
    close() {
        if (this.closed) {
            return;
        }
        if (this.#data.sctpState) {
            this.#data.sctpState = 'closed';
        }
        super.close();
    }
    /**
     * Router was closed.
     *
     * @private
     * @override
     */
    routerClosed() {
        if (this.closed) {
            return;
        }
        if (this.#data.sctpState) {
            this.#data.sctpState = 'closed';
        }
        super.routerClosed();
    }
    /**
     * Dump Transport.
     */
    async dump() {
        logger.debug('dump()');
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_DUMP, undefined, undefined, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsPlainTransport.DumpResponse();
        response.body(data);
        return parsePlainTransportDumpResponse(data);
    }
    /**
     * Get PlainTransport stats.
     *
     * @override
     */
    async getStats() {
        logger.debug('getStats()');
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_GET_STATS, undefined, undefined, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsPlainTransport.GetStatsResponse();
        response.body(data);
        return [parseGetStatsResponse(data)];
    }
    /**
     * Provide the PlainTransport remote parameters.
     *
     * @override
     */
    async connect({ ip, port, rtcpPort, srtpParameters, }) {
        logger.debug('connect()');
        const requestOffset = createConnectRequest({
            builder: this.channel.bufferBuilder,
            ip,
            port,
            rtcpPort,
            srtpParameters,
        });
        // Wait for response.
        const response = await this.channel.request(FbsRequest.Method.PLAINTRANSPORT_CONNECT, FbsRequest.Body.PlainTransport_ConnectRequest, requestOffset, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsPlainTransport.ConnectResponse();
        response.body(data);
        // Update data.
        if (data.tuple()) {
            this.#data.tuple = (0, Transport_1.parseTuple)(data.tuple());
        }
        if (data.rtcpTuple()) {
            this.#data.rtcpTuple = (0, Transport_1.parseTuple)(data.rtcpTuple());
        }
        if (data.srtpParameters()) {
            this.#data.srtpParameters = (0, SrtpParameters_1.parseSrtpParameters)(data.srtpParameters());
        }
    }
    handleWorkerNotifications() {
        this.channel.on(this.internal.transportId, (event, data) => {
            switch (event) {
                case notification_1.Event.PLAINTRANSPORT_TUPLE: {
                    const notification = new FbsPlainTransport.TupleNotification();
                    data.body(notification);
                    const tuple = (0, Transport_1.parseTuple)(notification.tuple());
                    this.#data.tuple = tuple;
                    this.safeEmit('tuple', tuple);
                    // Emit observer event.
                    this.observer.safeEmit('tuple', tuple);
                    break;
                }
                case notification_1.Event.PLAINTRANSPORT_RTCP_TUPLE: {
                    const notification = new FbsPlainTransport.RtcpTupleNotification();
                    data.body(notification);
                    const rtcpTuple = (0, Transport_1.parseTuple)(notification.tuple());
                    this.#data.rtcpTuple = rtcpTuple;
                    this.safeEmit('rtcptuple', rtcpTuple);
                    // Emit observer event.
                    this.observer.safeEmit('rtcptuple', rtcpTuple);
                    break;
                }
                case notification_1.Event.TRANSPORT_SCTP_STATE_CHANGE: {
                    const notification = new FbsTransport.SctpStateChangeNotification();
                    data.body(notification);
                    const sctpState = (0, Transport_1.parseSctpState)(notification.sctpState());
                    this.#data.sctpState = sctpState;
                    this.safeEmit('sctpstatechange', sctpState);
                    // Emit observer event.
                    this.observer.safeEmit('sctpstatechange', sctpState);
                    break;
                }
                case notification_1.Event.TRANSPORT_TRACE: {
                    const notification = new FbsTransport.TraceNotification();
                    data.body(notification);
                    const trace = (0, Transport_1.parseTransportTraceEventData)(notification);
                    this.safeEmit('trace', trace);
                    // Emit observer event.
                    this.observer.safeEmit('trace', trace);
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s"', event);
                }
            }
        });
    }
}
exports.PlainTransport = PlainTransport;
function parsePlainTransportDumpResponse(binary) {
    // Retrieve BaseTransportDump.
    const baseTransportDump = (0, Transport_1.parseBaseTransportDump)(binary.base());
    // Retrieve RTP Tuple.
    const tuple = (0, Transport_1.parseTuple)(binary.tuple());
    // Retrieve RTCP Tuple.
    let rtcpTuple;
    if (binary.rtcpTuple()) {
        rtcpTuple = (0, Transport_1.parseTuple)(binary.rtcpTuple());
    }
    // Retrieve SRTP Parameters.
    let srtpParameters;
    if (binary.srtpParameters()) {
        srtpParameters = (0, SrtpParameters_1.parseSrtpParameters)(binary.srtpParameters());
    }
    return {
        ...baseTransportDump,
        rtcpMux: binary.rtcpMux(),
        comedia: binary.comedia(),
        tuple: tuple,
        rtcpTuple: rtcpTuple,
        srtpParameters: srtpParameters,
    };
}
exports.parsePlainTransportDumpResponse = parsePlainTransportDumpResponse;
function parseGetStatsResponse(binary) {
    const base = (0, Transport_1.parseBaseTransportStats)(binary.base());
    return {
        ...base,
        type: 'plain-rtp-transport',
        rtcpMux: binary.rtcpMux(),
        comedia: binary.comedia(),
        tuple: (0, Transport_1.parseTuple)(binary.tuple()),
        rtcpTuple: binary.rtcpTuple() ? (0, Transport_1.parseTuple)(binary.rtcpTuple()) : undefined,
    };
}
function createConnectRequest({ builder, ip, port, rtcpPort, srtpParameters, }) {
    let ipOffset = 0;
    let srtpParametersOffset = 0;
    if (ip) {
        ipOffset = builder.createString(ip);
    }
    // Serialize SrtpParameters.
    if (srtpParameters) {
        srtpParametersOffset = (0, SrtpParameters_1.serializeSrtpParameters)(builder, srtpParameters);
    }
    // Create PlainTransportConnectData.
    FbsPlainTransport.ConnectRequest.startConnectRequest(builder);
    FbsPlainTransport.ConnectRequest.addIp(builder, ipOffset);
    if (typeof port === 'number') {
        FbsPlainTransport.ConnectRequest.addPort(builder, port);
    }
    if (typeof rtcpPort === 'number') {
        FbsPlainTransport.ConnectRequest.addRtcpPort(builder, rtcpPort);
    }
    if (srtpParameters) {
        FbsPlainTransport.ConnectRequest.addSrtpParameters(builder, srtpParametersOffset);
    }
    return FbsPlainTransport.ConnectRequest.endConnectRequest(builder);
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/Producer.js":
/*!*********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/Producer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseProducerDump = exports.producerTypeToFbs = exports.producerTypeFromFbs = exports.Producer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const RtpParameters_1 = __webpack_require__(/*! ./RtpParameters */ "../../node_modules/mediasoup/node/lib/RtpParameters.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const RtpStream_1 = __webpack_require__(/*! ./RtpStream */ "../../node_modules/mediasoup/node/lib/RtpStream.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const common_1 = __webpack_require__(/*! ./fbs/common */ "../../node_modules/mediasoup/node/lib/fbs/common.js");
const FbsNotification = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsProducer = __webpack_require__(/*! ./fbs/producer */ "../../node_modules/mediasoup/node/lib/fbs/producer.js");
const FbsProducerTraceInfo = __webpack_require__(/*! ./fbs/producer/trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-info.js");
const FbsRtpParameters = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
const logger = new Logger_1.Logger('Producer');
class Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Internal data.
    #internal;
    // Producer data.
    #data;
    // Channel instance.
    #channel;
    // Closed flag.
    #closed = false;
    // Paused flag.
    #paused = false;
    // Custom app data.
    #appData;
    // Current score.
    #score = [];
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     */
    constructor({ internal, data, channel, appData, paused, }) {
        super();
        logger.debug('constructor()');
        this.#internal = internal;
        this.#data = data;
        this.#channel = channel;
        this.#paused = paused;
        this.#appData = appData || {};
        this.handleWorkerNotifications();
    }
    /**
     * Producer id.
     */
    get id() {
        return this.#internal.producerId;
    }
    /**
     * Whether the Producer is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this.#data.kind;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this.#data.rtpParameters;
    }
    /**
     * Producer type.
     */
    get type() {
        return this.#data.type;
    }
    /**
     * Consumable RTP parameters.
     *
     * @private
     */
    get consumableRtpParameters() {
        return this.#data.consumableRtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
    get paused() {
        return this.#paused;
    }
    /**
     * Producer score list.
     */
    get score() {
        return this.#score;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * @private
     * Just for testing purposes.
     */
    get channelForTesting() {
        return this.#channel;
    }
    /**
     * Close the Producer.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.#channel.removeAllListeners(this.#internal.producerId);
        /* Build Request. */
        const requestOffset = new FbsTransport.CloseProducerRequestT(this.#internal.producerId).pack(this.#channel.bufferBuilder);
        this.#channel
            .request(FbsRequest.Method.TRANSPORT_CLOSE_PRODUCER, FbsRequest.Body.Transport_CloseProducerRequest, requestOffset, this.#internal.transportId)
            .catch(() => { });
        this.emit('@close');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     *
     * @private
     */
    transportClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('transportClosed()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.#channel.removeAllListeners(this.#internal.producerId);
        this.safeEmit('transportclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Dump Producer.
     */
    async dump() {
        logger.debug('dump()');
        const response = await this.#channel.request(FbsRequest.Method.PRODUCER_DUMP, undefined, undefined, this.#internal.producerId);
        /* Decode Response. */
        const dumpResponse = new FbsProducer.DumpResponse();
        response.body(dumpResponse);
        return parseProducerDump(dumpResponse);
    }
    /**
     * Get Producer stats.
     */
    async getStats() {
        logger.debug('getStats()');
        const response = await this.#channel.request(FbsRequest.Method.PRODUCER_GET_STATS, undefined, undefined, this.#internal.producerId);
        /* Decode Response. */
        const data = new FbsProducer.GetStatsResponse();
        response.body(data);
        return parseProducerStats(data);
    }
    /**
     * Pause the Producer.
     */
    async pause() {
        logger.debug('pause()');
        await this.#channel.request(FbsRequest.Method.PRODUCER_PAUSE, undefined, undefined, this.#internal.producerId);
        const wasPaused = this.#paused;
        this.#paused = true;
        // Emit observer event.
        if (!wasPaused) {
            this.#observer.safeEmit('pause');
        }
    }
    /**
     * Resume the Producer.
     */
    async resume() {
        logger.debug('resume()');
        await this.#channel.request(FbsRequest.Method.PRODUCER_RESUME, undefined, undefined, this.#internal.producerId);
        const wasPaused = this.#paused;
        this.#paused = false;
        // Emit observer event.
        if (wasPaused) {
            this.#observer.safeEmit('resume');
        }
    }
    /**
     * Enable 'trace' event.
     */
    async enableTraceEvent(types = []) {
        logger.debug('enableTraceEvent()');
        if (!Array.isArray(types)) {
            throw new TypeError('types must be an array');
        }
        if (types.find(type => typeof type !== 'string')) {
            throw new TypeError('every type must be a string');
        }
        // Convert event types.
        const fbsEventTypes = [];
        for (const eventType of types) {
            try {
                fbsEventTypes.push(producerTraceEventTypeToFbs(eventType));
            }
            catch (error) {
                logger.warn('enableTraceEvent() | [error:${error}]');
            }
        }
        /* Build Request. */
        const requestOffset = new FbsProducer.EnableTraceEventRequestT(fbsEventTypes).pack(this.#channel.bufferBuilder);
        await this.#channel.request(FbsRequest.Method.PRODUCER_ENABLE_TRACE_EVENT, FbsRequest.Body.Producer_EnableTraceEventRequest, requestOffset, this.#internal.producerId);
    }
    /**
     * Send RTP packet (just valid for Producers created on a DirectTransport).
     */
    send(rtpPacket) {
        if (!Buffer.isBuffer(rtpPacket)) {
            throw new TypeError('rtpPacket must be a Buffer');
        }
        const builder = this.#channel.bufferBuilder;
        const dataOffset = FbsProducer.SendNotification.createDataVector(builder, rtpPacket);
        const notificationOffset = FbsProducer.SendNotification.createSendNotification(builder, dataOffset);
        this.#channel.notify(FbsNotification.Event.PRODUCER_SEND, FbsNotification.Body.Producer_SendNotification, notificationOffset, this.#internal.producerId);
    }
    handleWorkerNotifications() {
        this.#channel.on(this.#internal.producerId, (event, data) => {
            switch (event) {
                case notification_1.Event.PRODUCER_SCORE: {
                    const notification = new FbsProducer.ScoreNotification();
                    data.body(notification);
                    const score = utils.parseVector(notification, 'scores', parseProducerScore);
                    this.#score = score;
                    this.safeEmit('score', score);
                    // Emit observer event.
                    this.#observer.safeEmit('score', score);
                    break;
                }
                case notification_1.Event.PRODUCER_VIDEO_ORIENTATION_CHANGE: {
                    const notification = new FbsProducer.VideoOrientationChangeNotification();
                    data.body(notification);
                    const videoOrientation = notification.unpack();
                    this.safeEmit('videoorientationchange', videoOrientation);
                    // Emit observer event.
                    this.#observer.safeEmit('videoorientationchange', videoOrientation);
                    break;
                }
                case notification_1.Event.PRODUCER_TRACE: {
                    const notification = new FbsProducer.TraceNotification();
                    data.body(notification);
                    const trace = parseTraceEventData(notification);
                    this.safeEmit('trace', trace);
                    // Emit observer event.
                    this.#observer.safeEmit('trace', trace);
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s"', event);
                }
            }
        });
    }
}
exports.Producer = Producer;
function producerTypeFromFbs(type) {
    switch (type) {
        case FbsRtpParameters.Type.SIMPLE: {
            return 'simple';
        }
        case FbsRtpParameters.Type.SIMULCAST: {
            return 'simulcast';
        }
        case FbsRtpParameters.Type.SVC: {
            return 'svc';
        }
        default: {
            throw new TypeError(`invalid FbsRtpParameters.Type: ${type}`);
        }
    }
}
exports.producerTypeFromFbs = producerTypeFromFbs;
function producerTypeToFbs(type) {
    switch (type) {
        case 'simple': {
            return FbsRtpParameters.Type.SIMPLE;
        }
        case 'simulcast': {
            return FbsRtpParameters.Type.SIMULCAST;
        }
        case 'svc': {
            return FbsRtpParameters.Type.SVC;
        }
    }
}
exports.producerTypeToFbs = producerTypeToFbs;
function producerTraceEventTypeToFbs(eventType) {
    switch (eventType) {
        case 'keyframe': {
            return FbsProducer.TraceEventType.KEYFRAME;
        }
        case 'fir': {
            return FbsProducer.TraceEventType.FIR;
        }
        case 'nack': {
            return FbsProducer.TraceEventType.NACK;
        }
        case 'pli': {
            return FbsProducer.TraceEventType.PLI;
        }
        case 'rtp': {
            return FbsProducer.TraceEventType.RTP;
        }
        case 'sr': {
            return FbsProducer.TraceEventType.SR;
        }
        default: {
            throw new TypeError(`invalid ProducerTraceEventType: ${eventType}`);
        }
    }
}
function producerTraceEventTypeFromFbs(eventType) {
    switch (eventType) {
        case FbsProducer.TraceEventType.KEYFRAME: {
            return 'keyframe';
        }
        case FbsProducer.TraceEventType.FIR: {
            return 'fir';
        }
        case FbsProducer.TraceEventType.NACK: {
            return 'nack';
        }
        case FbsProducer.TraceEventType.PLI: {
            return 'pli';
        }
        case FbsProducer.TraceEventType.RTP: {
            return 'rtp';
        }
        case FbsProducer.TraceEventType.SR: {
            return 'sr';
        }
    }
}
function parseProducerDump(data) {
    return {
        id: data.id(),
        kind: data.kind() === FbsRtpParameters.MediaKind.AUDIO ? 'audio' : 'video',
        type: producerTypeFromFbs(data.type()),
        rtpParameters: (0, RtpParameters_1.parseRtpParameters)(data.rtpParameters()),
        // NOTE: optional values are represented with null instead of undefined.
        // TODO: Make flatbuffers TS return undefined instead of null.
        rtpMapping: data.rtpMapping() ? data.rtpMapping().unpack() : undefined,
        // NOTE: optional values are represented with null instead of undefined.
        // TODO: Make flatbuffers TS return undefined instead of null.
        rtpStreams: data.rtpStreamsLength() > 0
            ? utils.parseVector(data, 'rtpStreams', (rtpStream) => rtpStream.unpack())
            : undefined,
        traceEventTypes: utils.parseVector(data, 'traceEventTypes', producerTraceEventTypeFromFbs),
        paused: data.paused(),
    };
}
exports.parseProducerDump = parseProducerDump;
function parseProducerStats(binary) {
    return utils.parseVector(binary, 'stats', RtpStream_1.parseRtpStreamRecvStats);
}
function parseProducerScore(binary) {
    return {
        encodingIdx: binary.encodingIdx(),
        ssrc: binary.ssrc(),
        rid: binary.rid() ?? undefined,
        score: binary.score(),
    };
}
function parseTraceEventData(trace) {
    let info;
    if (trace.infoType() !== FbsProducer.TraceInfo.NONE) {
        const accessor = trace.info.bind(trace);
        info = FbsProducerTraceInfo.unionToTraceInfo(trace.infoType(), accessor);
        trace.info(info);
    }
    return {
        type: producerTraceEventTypeFromFbs(trace.type()),
        timestamp: Number(trace.timestamp()),
        direction: trace.direction() === common_1.TraceDirection.DIRECTION_IN ? 'in' : 'out',
        info: info ? info.unpack() : undefined,
    };
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/Router.js":
/*!*******************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/Router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.socketFlagsToFbs = exports.parseRouterDumpResponse = exports.Router = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const ortc = __webpack_require__(/*! ./ortc */ "../../node_modules/mediasoup/node/lib/ortc.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/mediasoup/node/lib/errors.js");
const WebRtcTransport_1 = __webpack_require__(/*! ./WebRtcTransport */ "../../node_modules/mediasoup/node/lib/WebRtcTransport.js");
const PlainTransport_1 = __webpack_require__(/*! ./PlainTransport */ "../../node_modules/mediasoup/node/lib/PlainTransport.js");
const PipeTransport_1 = __webpack_require__(/*! ./PipeTransport */ "../../node_modules/mediasoup/node/lib/PipeTransport.js");
const DirectTransport_1 = __webpack_require__(/*! ./DirectTransport */ "../../node_modules/mediasoup/node/lib/DirectTransport.js");
const ActiveSpeakerObserver_1 = __webpack_require__(/*! ./ActiveSpeakerObserver */ "../../node_modules/mediasoup/node/lib/ActiveSpeakerObserver.js");
const AudioLevelObserver_1 = __webpack_require__(/*! ./AudioLevelObserver */ "../../node_modules/mediasoup/node/lib/AudioLevelObserver.js");
const SrtpParameters_1 = __webpack_require__(/*! ./SrtpParameters */ "../../node_modules/mediasoup/node/lib/SrtpParameters.js");
const utils_1 = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const FbsActiveSpeakerObserver = __webpack_require__(/*! ./fbs/active-speaker-observer */ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer.js");
const FbsAudioLevelObserver = __webpack_require__(/*! ./fbs/audio-level-observer */ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsWorker = __webpack_require__(/*! ./fbs/worker */ "../../node_modules/mediasoup/node/lib/fbs/worker.js");
const FbsRouter = __webpack_require__(/*! ./fbs/router */ "../../node_modules/mediasoup/node/lib/fbs/router.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const protocol_1 = __webpack_require__(/*! ./fbs/transport/protocol */ "../../node_modules/mediasoup/node/lib/fbs/transport/protocol.js");
const FbsWebRtcTransport = __webpack_require__(/*! ./fbs/web-rtc-transport */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport.js");
const FbsPlainTransport = __webpack_require__(/*! ./fbs/plain-transport */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport.js");
const FbsPipeTransport = __webpack_require__(/*! ./fbs/pipe-transport */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport.js");
const FbsDirectTransport = __webpack_require__(/*! ./fbs/direct-transport */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport.js");
const FbsSctpParameters = __webpack_require__(/*! ./fbs/sctp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters.js");
const logger = new Logger_1.Logger('Router');
class Router extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Internal data.
    #internal;
    // Router data.
    #data;
    // Channel instance.
    #channel;
    // Closed flag.
    #closed = false;
    // Custom app data.
    #appData;
    // Transports map.
    #transports = new Map();
    // Producers map.
    #producers = new Map();
    // RtpObservers map.
    #rtpObservers = new Map();
    // DataProducers map.
    #dataProducers = new Map();
    // Map of PipeTransport pair Promises indexed by the id of the Router in
    // which pipeToRouter() was called.
    #mapRouterPairPipeTransportPairPromise = new Map();
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     */
    constructor({ internal, data, channel, appData, }) {
        super();
        logger.debug('constructor()');
        this.#internal = internal;
        this.#data = data;
        this.#channel = channel;
        this.#appData = appData || {};
    }
    /**
     * Router id.
     */
    get id() {
        return this.#internal.routerId;
    }
    /**
     * Whether the Router is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * RTP capabilities of the Router.
     */
    get rtpCapabilities() {
        return this.#data.rtpCapabilities;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * @private
     * Just for testing purposes.
     */
    get transportsForTesting() {
        return this.#transports;
    }
    /**
     * Close the Router.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        const requestOffset = new FbsWorker.CloseRouterRequestT(this.#internal.routerId).pack(this.#channel.bufferBuilder);
        this.#channel
            .request(FbsRequest.Method.WORKER_CLOSE_ROUTER, FbsRequest.Body.Worker_CloseRouterRequest, requestOffset)
            .catch(() => { });
        // Close every Transport.
        for (const transport of this.#transports.values()) {
            transport.routerClosed();
        }
        this.#transports.clear();
        // Clear the Producers map.
        this.#producers.clear();
        // Close every RtpObserver.
        for (const rtpObserver of this.#rtpObservers.values()) {
            rtpObserver.routerClosed();
        }
        this.#rtpObservers.clear();
        // Clear the DataProducers map.
        this.#dataProducers.clear();
        this.emit('@close');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Worker was closed.
     *
     * @private
     */
    workerClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('workerClosed()');
        this.#closed = true;
        // Close every Transport.
        for (const transport of this.#transports.values()) {
            transport.routerClosed();
        }
        this.#transports.clear();
        // Clear the Producers map.
        this.#producers.clear();
        // Close every RtpObserver.
        for (const rtpObserver of this.#rtpObservers.values()) {
            rtpObserver.routerClosed();
        }
        this.#rtpObservers.clear();
        // Clear the DataProducers map.
        this.#dataProducers.clear();
        this.safeEmit('workerclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Dump Router.
     */
    async dump() {
        logger.debug('dump()');
        // Send the request and wait for the response.
        const response = await this.#channel.request(FbsRequest.Method.ROUTER_DUMP, undefined, undefined, this.#internal.routerId);
        /* Decode Response. */
        const dump = new FbsRouter.DumpResponse();
        response.body(dump);
        return parseRouterDumpResponse(dump);
    }
    /**
     * Create a WebRtcTransport.
     */
    async createWebRtcTransport({ webRtcServer, listenInfos, listenIps, port, enableUdp, enableTcp, preferUdp = false, preferTcp = false, initialAvailableOutgoingBitrate = 600000, enableSctp = false, numSctpStreams = { OS: 1024, MIS: 1024 }, maxSctpMessageSize = 262144, sctpSendBufferSize = 262144, appData, }) {
        logger.debug('createWebRtcTransport()');
        if (!webRtcServer &&
            !Array.isArray(listenInfos) &&
            !Array.isArray(listenIps)) {
            throw new TypeError('missing webRtcServer, listenInfos and listenIps (one of them is mandatory)');
        }
        else if (webRtcServer && listenInfos && listenIps) {
            throw new TypeError('only one of webRtcServer, listenInfos and listenIps must be given');
        }
        else if (numSctpStreams &&
            (typeof numSctpStreams.OS !== 'number' ||
                typeof numSctpStreams.MIS !== 'number')) {
            throw new TypeError('if given, numSctpStreams must contain OS and MIS');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // If webRtcServer is given, then do not force default values for enableUdp
        // and enableTcp. Otherwise set them if unset.
        if (webRtcServer) {
            enableUdp ??= true;
            enableTcp ??= true;
        }
        else {
            enableUdp ??= true;
            enableTcp ??= false;
        }
        // Convert deprecated TransportListenIps to TransportListenInfos.
        if (listenIps) {
            // Normalize IP strings to TransportListenIp objects.
            listenIps = listenIps.map(listenIp => {
                if (typeof listenIp === 'string') {
                    return { ip: listenIp };
                }
                else {
                    return listenIp;
                }
            });
            listenInfos = [];
            const orderedProtocols = [];
            if (enableUdp && (preferUdp || !enableTcp || !preferTcp)) {
                orderedProtocols.push('udp');
                if (enableTcp) {
                    orderedProtocols.push('tcp');
                }
            }
            else if (enableTcp && ((preferTcp && !preferUdp) || !enableUdp)) {
                orderedProtocols.push('tcp');
                if (enableUdp) {
                    orderedProtocols.push('udp');
                }
            }
            for (const listenIp of listenIps) {
                for (const protocol of orderedProtocols) {
                    listenInfos.push({
                        protocol: protocol,
                        ip: listenIp.ip,
                        announcedAddress: listenIp.announcedIp,
                        port: port,
                    });
                }
            }
        }
        const transportId = (0, utils_1.generateUUIDv4)();
        /* Build Request. */
        let webRtcTransportListenServer;
        let webRtcTransportListenIndividual;
        if (webRtcServer) {
            webRtcTransportListenServer = new FbsWebRtcTransport.ListenServerT(webRtcServer.id);
        }
        else {
            const fbsListenInfos = [];
            for (const listenInfo of listenInfos) {
                fbsListenInfos.push(new FbsTransport.ListenInfoT(listenInfo.protocol === 'udp'
                    ? protocol_1.Protocol.UDP
                    : protocol_1.Protocol.TCP, listenInfo.ip, listenInfo.announcedAddress ?? listenInfo.announcedIp, listenInfo.port, socketFlagsToFbs(listenInfo.flags), listenInfo.sendBufferSize, listenInfo.recvBufferSize));
            }
            webRtcTransportListenIndividual =
                new FbsWebRtcTransport.ListenIndividualT(fbsListenInfos);
        }
        const baseTransportOptions = new FbsTransport.OptionsT(undefined /* direct */, undefined /* maxMessageSize */, initialAvailableOutgoingBitrate, enableSctp, new FbsSctpParameters.NumSctpStreamsT(numSctpStreams.OS, numSctpStreams.MIS), maxSctpMessageSize, sctpSendBufferSize, true /* isDataChannel */);
        const webRtcTransportOptions = new FbsWebRtcTransport.WebRtcTransportOptionsT(baseTransportOptions, webRtcServer
            ? FbsWebRtcTransport.Listen.ListenServer
            : FbsWebRtcTransport.Listen.ListenIndividual, webRtcServer
            ? webRtcTransportListenServer
            : webRtcTransportListenIndividual, enableUdp, enableTcp, preferUdp, preferTcp);
        const requestOffset = new FbsRouter.CreateWebRtcTransportRequestT(transportId, webRtcTransportOptions).pack(this.#channel.bufferBuilder);
        const response = await this.#channel.request(webRtcServer
            ? FbsRequest.Method.ROUTER_CREATE_WEBRTCTRANSPORT_WITH_SERVER
            : FbsRequest.Method.ROUTER_CREATE_WEBRTCTRANSPORT, FbsRequest.Body.Router_CreateWebRtcTransportRequest, requestOffset, this.#internal.routerId);
        /* Decode Response. */
        const data = new FbsWebRtcTransport.DumpResponse();
        response.body(data);
        const webRtcTransportData = (0, WebRtcTransport_1.parseWebRtcTransportDumpResponse)(data);
        const transport = new WebRtcTransport_1.WebRtcTransport({
            internal: {
                ...this.#internal,
                transportId: transportId,
            },
            data: webRtcTransportData,
            channel: this.#channel,
            appData,
            getRouterRtpCapabilities: () => this.#data.rtpCapabilities,
            getProducerById: (producerId) => this.#producers.get(producerId),
            getDataProducerById: (dataProducerId) => this.#dataProducers.get(dataProducerId),
        });
        this.#transports.set(transport.id, transport);
        transport.on('@close', () => this.#transports.delete(transport.id));
        transport.on('@listenserverclose', () => this.#transports.delete(transport.id));
        transport.on('@newproducer', (producer) => this.#producers.set(producer.id, producer));
        transport.on('@producerclose', (producer) => this.#producers.delete(producer.id));
        transport.on('@newdataproducer', (dataProducer) => this.#dataProducers.set(dataProducer.id, dataProducer));
        transport.on('@dataproducerclose', (dataProducer) => this.#dataProducers.delete(dataProducer.id));
        // Emit observer event.
        this.#observer.safeEmit('newtransport', transport);
        if (webRtcServer) {
            webRtcServer.handleWebRtcTransport(transport);
        }
        return transport;
    }
    /**
     * Create a PlainTransport.
     */
    async createPlainTransport({ listenInfo, rtcpListenInfo, listenIp, port, rtcpMux = true, comedia = false, enableSctp = false, numSctpStreams = { OS: 1024, MIS: 1024 }, maxSctpMessageSize = 262144, sctpSendBufferSize = 262144, enableSrtp = false, srtpCryptoSuite = 'AES_CM_128_HMAC_SHA1_80', appData, }) {
        logger.debug('createPlainTransport()');
        if (!listenInfo && !listenIp) {
            throw new TypeError('missing listenInfo and listenIp (one of them is mandatory)');
        }
        else if (listenInfo && listenIp) {
            throw new TypeError('only one of listenInfo and listenIp must be given');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // If rtcpMux is enabled, ignore rtcpListenInfo.
        if (rtcpMux && rtcpListenInfo) {
            logger.warn('createPlainTransport() | ignoring rtcpMux since rtcpListenInfo is given');
            rtcpMux = false;
        }
        // Convert deprecated TransportListenIps to TransportListenInfos.
        if (listenIp) {
            // Normalize IP string to TransportListenIp object.
            if (typeof listenIp === 'string') {
                listenIp = { ip: listenIp };
            }
            listenInfo = {
                protocol: 'udp',
                ip: listenIp.ip,
                announcedAddress: listenIp.announcedIp,
                port: port,
            };
        }
        const transportId = (0, utils_1.generateUUIDv4)();
        /* Build Request. */
        const baseTransportOptions = new FbsTransport.OptionsT(undefined /* direct */, undefined /* maxMessageSize */, undefined /* initialAvailableOutgoingBitrate */, enableSctp, new FbsSctpParameters.NumSctpStreamsT(numSctpStreams.OS, numSctpStreams.MIS), maxSctpMessageSize, sctpSendBufferSize, false /* isDataChannel */);
        const plainTransportOptions = new FbsPlainTransport.PlainTransportOptionsT(baseTransportOptions, new FbsTransport.ListenInfoT(listenInfo.protocol === 'udp'
            ? protocol_1.Protocol.UDP
            : protocol_1.Protocol.TCP, listenInfo.ip, listenInfo.announcedAddress ?? listenInfo.announcedIp, listenInfo.port, socketFlagsToFbs(listenInfo.flags), listenInfo.sendBufferSize, listenInfo.recvBufferSize), rtcpListenInfo
            ? new FbsTransport.ListenInfoT(rtcpListenInfo.protocol === 'udp'
                ? protocol_1.Protocol.UDP
                : protocol_1.Protocol.TCP, rtcpListenInfo.ip, rtcpListenInfo.announcedAddress ?? rtcpListenInfo.announcedIp, rtcpListenInfo.port, socketFlagsToFbs(rtcpListenInfo.flags), rtcpListenInfo.sendBufferSize, rtcpListenInfo.recvBufferSize)
            : undefined, rtcpMux, comedia, enableSrtp, (0, SrtpParameters_1.cryptoSuiteToFbs)(srtpCryptoSuite));
        const requestOffset = new FbsRouter.CreatePlainTransportRequestT(transportId, plainTransportOptions).pack(this.#channel.bufferBuilder);
        const response = await this.#channel.request(FbsRequest.Method.ROUTER_CREATE_PLAINTRANSPORT, FbsRequest.Body.Router_CreatePlainTransportRequest, requestOffset, this.#internal.routerId);
        /* Decode Response. */
        const data = new FbsPlainTransport.DumpResponse();
        response.body(data);
        const plainTransportData = (0, PlainTransport_1.parsePlainTransportDumpResponse)(data);
        const transport = new PlainTransport_1.PlainTransport({
            internal: {
                ...this.#internal,
                transportId: transportId,
            },
            data: plainTransportData,
            channel: this.#channel,
            appData,
            getRouterRtpCapabilities: () => this.#data.rtpCapabilities,
            getProducerById: (producerId) => this.#producers.get(producerId),
            getDataProducerById: (dataProducerId) => this.#dataProducers.get(dataProducerId),
        });
        this.#transports.set(transport.id, transport);
        transport.on('@close', () => this.#transports.delete(transport.id));
        transport.on('@listenserverclose', () => this.#transports.delete(transport.id));
        transport.on('@newproducer', (producer) => this.#producers.set(producer.id, producer));
        transport.on('@producerclose', (producer) => this.#producers.delete(producer.id));
        transport.on('@newdataproducer', (dataProducer) => this.#dataProducers.set(dataProducer.id, dataProducer));
        transport.on('@dataproducerclose', (dataProducer) => this.#dataProducers.delete(dataProducer.id));
        // Emit observer event.
        this.#observer.safeEmit('newtransport', transport);
        return transport;
    }
    /**
     * Create a PipeTransport.
     */
    async createPipeTransport({ listenInfo, listenIp, port, enableSctp = false, numSctpStreams = { OS: 1024, MIS: 1024 }, maxSctpMessageSize = 268435456, sctpSendBufferSize = 268435456, enableRtx = false, enableSrtp = false, appData, }) {
        logger.debug('createPipeTransport()');
        if (!listenInfo && !listenIp) {
            throw new TypeError('missing listenInfo and listenIp (one of them is mandatory)');
        }
        else if (listenInfo && listenIp) {
            throw new TypeError('only one of listenInfo and listenIp must be given');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Convert deprecated TransportListenIps to TransportListenInfos.
        if (listenIp) {
            // Normalize IP string to TransportListenIp object.
            if (typeof listenIp === 'string') {
                listenIp = { ip: listenIp };
            }
            listenInfo = {
                protocol: 'udp',
                ip: listenIp.ip,
                announcedAddress: listenIp.announcedIp,
                port: port,
            };
        }
        const transportId = (0, utils_1.generateUUIDv4)();
        /* Build Request. */
        const baseTransportOptions = new FbsTransport.OptionsT(undefined /* direct */, undefined /* maxMessageSize */, undefined /* initialAvailableOutgoingBitrate */, enableSctp, new FbsSctpParameters.NumSctpStreamsT(numSctpStreams.OS, numSctpStreams.MIS), maxSctpMessageSize, sctpSendBufferSize, false /* isDataChannel */);
        const pipeTransportOptions = new FbsPipeTransport.PipeTransportOptionsT(baseTransportOptions, new FbsTransport.ListenInfoT(listenInfo.protocol === 'udp'
            ? protocol_1.Protocol.UDP
            : protocol_1.Protocol.TCP, listenInfo.ip, listenInfo.announcedAddress ?? listenInfo.announcedIp, listenInfo.port, socketFlagsToFbs(listenInfo.flags), listenInfo.sendBufferSize, listenInfo.recvBufferSize), enableRtx, enableSrtp);
        const requestOffset = new FbsRouter.CreatePipeTransportRequestT(transportId, pipeTransportOptions).pack(this.#channel.bufferBuilder);
        const response = await this.#channel.request(FbsRequest.Method.ROUTER_CREATE_PIPETRANSPORT, FbsRequest.Body.Router_CreatePipeTransportRequest, requestOffset, this.#internal.routerId);
        /* Decode Response. */
        const data = new FbsPipeTransport.DumpResponse();
        response.body(data);
        const plainTransportData = (0, PipeTransport_1.parsePipeTransportDumpResponse)(data);
        const transport = new PipeTransport_1.PipeTransport({
            internal: {
                ...this.#internal,
                transportId,
            },
            data: plainTransportData,
            channel: this.#channel,
            appData,
            getRouterRtpCapabilities: () => this.#data.rtpCapabilities,
            getProducerById: (producerId) => this.#producers.get(producerId),
            getDataProducerById: (dataProducerId) => this.#dataProducers.get(dataProducerId),
        });
        this.#transports.set(transport.id, transport);
        transport.on('@close', () => this.#transports.delete(transport.id));
        transport.on('@listenserverclose', () => this.#transports.delete(transport.id));
        transport.on('@newproducer', (producer) => this.#producers.set(producer.id, producer));
        transport.on('@producerclose', (producer) => this.#producers.delete(producer.id));
        transport.on('@newdataproducer', (dataProducer) => this.#dataProducers.set(dataProducer.id, dataProducer));
        transport.on('@dataproducerclose', (dataProducer) => this.#dataProducers.delete(dataProducer.id));
        // Emit observer event.
        this.#observer.safeEmit('newtransport', transport);
        return transport;
    }
    /**
     * Create a DirectTransport.
     */
    async createDirectTransport({ maxMessageSize = 262144, appData, } = {
        maxMessageSize: 262144,
    }) {
        logger.debug('createDirectTransport()');
        if (typeof maxMessageSize !== 'number' || maxMessageSize < 0) {
            throw new TypeError('if given, maxMessageSize must be a positive number');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        const transportId = (0, utils_1.generateUUIDv4)();
        /* Build Request. */
        const baseTransportOptions = new FbsTransport.OptionsT(true /* direct */, maxMessageSize, undefined /* initialAvailableOutgoingBitrate */, undefined /* enableSctp */, undefined /* numSctpStreams */, undefined /* maxSctpMessageSize */, undefined /* sctpSendBufferSize */, undefined /* isDataChannel */);
        const directTransportOptions = new FbsDirectTransport.DirectTransportOptionsT(baseTransportOptions);
        const requestOffset = new FbsRouter.CreateDirectTransportRequestT(transportId, directTransportOptions).pack(this.#channel.bufferBuilder);
        const response = await this.#channel.request(FbsRequest.Method.ROUTER_CREATE_DIRECTTRANSPORT, FbsRequest.Body.Router_CreateDirectTransportRequest, requestOffset, this.#internal.routerId);
        /* Decode Response. */
        const data = new FbsDirectTransport.DumpResponse();
        response.body(data);
        const directTransportData = (0, DirectTransport_1.parseDirectTransportDumpResponse)(data);
        const transport = new DirectTransport_1.DirectTransport({
            internal: {
                ...this.#internal,
                transportId: transportId,
            },
            data: directTransportData,
            channel: this.#channel,
            appData,
            getRouterRtpCapabilities: () => this.#data.rtpCapabilities,
            getProducerById: (producerId) => this.#producers.get(producerId),
            getDataProducerById: (dataProducerId) => this.#dataProducers.get(dataProducerId),
        });
        this.#transports.set(transport.id, transport);
        transport.on('@close', () => this.#transports.delete(transport.id));
        transport.on('@listenserverclose', () => this.#transports.delete(transport.id));
        transport.on('@newproducer', (producer) => this.#producers.set(producer.id, producer));
        transport.on('@producerclose', (producer) => this.#producers.delete(producer.id));
        transport.on('@newdataproducer', (dataProducer) => this.#dataProducers.set(dataProducer.id, dataProducer));
        transport.on('@dataproducerclose', (dataProducer) => this.#dataProducers.delete(dataProducer.id));
        // Emit observer event.
        this.#observer.safeEmit('newtransport', transport);
        return transport;
    }
    /**
     * Pipes the given Producer or DataProducer into another Router in same host.
     */
    async pipeToRouter({ producerId, dataProducerId, router, listenInfo, listenIp, enableSctp = true, numSctpStreams = { OS: 1024, MIS: 1024 }, enableRtx = false, enableSrtp = false, }) {
        logger.debug('pipeToRouter()');
        if (!listenInfo && !listenIp) {
            listenInfo = {
                protocol: 'udp',
                ip: '127.0.0.1',
            };
        }
        if (listenInfo && listenIp) {
            throw new TypeError('only one of listenInfo and listenIp must be given');
        }
        else if (!producerId && !dataProducerId) {
            throw new TypeError('missing producerId or dataProducerId');
        }
        else if (producerId && dataProducerId) {
            throw new TypeError('just producerId or dataProducerId can be given');
        }
        else if (!router) {
            throw new TypeError('Router not found');
        }
        else if (router === this) {
            throw new TypeError('cannot use this Router as destination');
        }
        // Convert deprecated TransportListenIps to TransportListenInfos.
        if (listenIp) {
            // Normalize IP string to TransportListenIp object.
            if (typeof listenIp === 'string') {
                listenIp = { ip: listenIp };
            }
            listenInfo = {
                protocol: 'udp',
                ip: listenIp.ip,
                announcedAddress: listenIp.announcedIp,
            };
        }
        let producer;
        let dataProducer;
        if (producerId) {
            producer = this.#producers.get(producerId);
            if (!producer) {
                throw new TypeError('Producer not found');
            }
        }
        else if (dataProducerId) {
            dataProducer = this.#dataProducers.get(dataProducerId);
            if (!dataProducer) {
                throw new TypeError('DataProducer not found');
            }
        }
        const pipeTransportPairKey = router.id;
        let pipeTransportPairPromise = this.#mapRouterPairPipeTransportPairPromise.get(pipeTransportPairKey);
        let pipeTransportPair;
        let localPipeTransport;
        let remotePipeTransport;
        if (pipeTransportPairPromise) {
            pipeTransportPair = await pipeTransportPairPromise;
            localPipeTransport = pipeTransportPair[this.id];
            remotePipeTransport = pipeTransportPair[router.id];
        }
        else {
            pipeTransportPairPromise = new Promise((resolve, reject) => {
                Promise.all([
                    this.createPipeTransport({
                        listenInfo: listenInfo,
                        enableSctp,
                        numSctpStreams,
                        enableRtx,
                        enableSrtp,
                    }),
                    router.createPipeTransport({
                        listenInfo: listenInfo,
                        enableSctp,
                        numSctpStreams,
                        enableRtx,
                        enableSrtp,
                    }),
                ])
                    .then(pipeTransports => {
                    localPipeTransport = pipeTransports[0];
                    remotePipeTransport = pipeTransports[1];
                })
                    .then(() => {
                    return Promise.all([
                        localPipeTransport.connect({
                            ip: remotePipeTransport.tuple.localAddress,
                            port: remotePipeTransport.tuple.localPort,
                            srtpParameters: remotePipeTransport.srtpParameters,
                        }),
                        remotePipeTransport.connect({
                            ip: localPipeTransport.tuple.localAddress,
                            port: localPipeTransport.tuple.localPort,
                            srtpParameters: localPipeTransport.srtpParameters,
                        }),
                    ]);
                })
                    .then(() => {
                    localPipeTransport.observer.on('close', () => {
                        remotePipeTransport.close();
                        this.#mapRouterPairPipeTransportPairPromise.delete(pipeTransportPairKey);
                    });
                    remotePipeTransport.observer.on('close', () => {
                        localPipeTransport.close();
                        this.#mapRouterPairPipeTransportPairPromise.delete(pipeTransportPairKey);
                    });
                    resolve({
                        [this.id]: localPipeTransport,
                        [router.id]: remotePipeTransport,
                    });
                })
                    .catch(error => {
                    logger.error('pipeToRouter() | error creating PipeTransport pair:%o', error);
                    if (localPipeTransport) {
                        localPipeTransport.close();
                    }
                    if (remotePipeTransport) {
                        remotePipeTransport.close();
                    }
                    reject(error);
                });
            });
            this.#mapRouterPairPipeTransportPairPromise.set(pipeTransportPairKey, pipeTransportPairPromise);
            router.addPipeTransportPair(this.id, pipeTransportPairPromise);
            await pipeTransportPairPromise;
        }
        if (producer) {
            let pipeConsumer;
            let pipeProducer;
            try {
                pipeConsumer = await localPipeTransport.consume({
                    producerId: producerId,
                });
                pipeProducer = await remotePipeTransport.produce({
                    id: producer.id,
                    kind: pipeConsumer.kind,
                    rtpParameters: pipeConsumer.rtpParameters,
                    paused: pipeConsumer.producerPaused,
                    appData: producer.appData,
                });
                // Ensure that the producer has not been closed in the meanwhile.
                if (producer.closed) {
                    throw new errors_1.InvalidStateError('original Producer closed');
                }
                // Ensure that producer.paused has not changed in the meanwhile and, if
                // so, sync the pipeProducer.
                if (pipeProducer.paused !== producer.paused) {
                    if (producer.paused) {
                        await pipeProducer.pause();
                    }
                    else {
                        await pipeProducer.resume();
                    }
                }
                // Pipe events from the pipe Consumer to the pipe Producer.
                pipeConsumer.observer.on('close', () => pipeProducer.close());
                pipeConsumer.observer.on('pause', () => pipeProducer.pause());
                pipeConsumer.observer.on('resume', () => pipeProducer.resume());
                // Pipe events from the pipe Producer to the pipe Consumer.
                pipeProducer.observer.on('close', () => pipeConsumer.close());
                return { pipeConsumer, pipeProducer };
            }
            catch (error) {
                logger.error('pipeToRouter() | error creating pipe Consumer/Producer pair:%o', error);
                if (pipeConsumer) {
                    pipeConsumer.close();
                }
                if (pipeProducer) {
                    pipeProducer.close();
                }
                throw error;
            }
        }
        else if (dataProducer) {
            let pipeDataConsumer;
            let pipeDataProducer;
            try {
                pipeDataConsumer = await localPipeTransport.consumeData({
                    dataProducerId: dataProducerId,
                });
                pipeDataProducer = await remotePipeTransport.produceData({
                    id: dataProducer.id,
                    sctpStreamParameters: pipeDataConsumer.sctpStreamParameters,
                    label: pipeDataConsumer.label,
                    protocol: pipeDataConsumer.protocol,
                    appData: dataProducer.appData,
                });
                // Ensure that the dataProducer has not been closed in the meanwhile.
                if (dataProducer.closed) {
                    throw new errors_1.InvalidStateError('original DataProducer closed');
                }
                // Pipe events from the pipe DataConsumer to the pipe DataProducer.
                pipeDataConsumer.observer.on('close', () => pipeDataProducer.close());
                // Pipe events from the pipe DataProducer to the pipe DataConsumer.
                pipeDataProducer.observer.on('close', () => pipeDataConsumer.close());
                return { pipeDataConsumer, pipeDataProducer };
            }
            catch (error) {
                logger.error('pipeToRouter() | error creating pipe DataConsumer/DataProducer pair:%o', error);
                if (pipeDataConsumer) {
                    pipeDataConsumer.close();
                }
                if (pipeDataProducer) {
                    pipeDataProducer.close();
                }
                throw error;
            }
        }
        else {
            throw new Error('internal error');
        }
    }
    /**
     * @private
     */
    addPipeTransportPair(pipeTransportPairKey, pipeTransportPairPromise) {
        if (this.#mapRouterPairPipeTransportPairPromise.has(pipeTransportPairKey)) {
            throw new Error('given pipeTransportPairKey already exists in this Router');
        }
        this.#mapRouterPairPipeTransportPairPromise.set(pipeTransportPairKey, pipeTransportPairPromise);
        pipeTransportPairPromise
            .then(pipeTransportPair => {
            const localPipeTransport = pipeTransportPair[this.id];
            // NOTE: No need to do any other cleanup here since that is done by the
            // Router calling this method on us.
            localPipeTransport.observer.on('close', () => {
                this.#mapRouterPairPipeTransportPairPromise.delete(pipeTransportPairKey);
            });
        })
            .catch(() => {
            this.#mapRouterPairPipeTransportPairPromise.delete(pipeTransportPairKey);
        });
    }
    /**
     * Create an ActiveSpeakerObserver
     */
    async createActiveSpeakerObserver({ interval = 300, appData, } = {}) {
        logger.debug('createActiveSpeakerObserver()');
        if (typeof interval !== 'number') {
            throw new TypeError('if given, interval must be an number');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        const rtpObserverId = (0, utils_1.generateUUIDv4)();
        /* Build Request. */
        const activeRtpObserverOptions = new FbsActiveSpeakerObserver.ActiveSpeakerObserverOptionsT(interval);
        const requestOffset = new FbsRouter.CreateActiveSpeakerObserverRequestT(rtpObserverId, activeRtpObserverOptions).pack(this.#channel.bufferBuilder);
        await this.#channel.request(FbsRequest.Method.ROUTER_CREATE_ACTIVESPEAKEROBSERVER, FbsRequest.Body.Router_CreateActiveSpeakerObserverRequest, requestOffset, this.#internal.routerId);
        const activeSpeakerObserver = new ActiveSpeakerObserver_1.ActiveSpeakerObserver({
            internal: {
                ...this.#internal,
                rtpObserverId: rtpObserverId,
            },
            channel: this.#channel,
            appData,
            getProducerById: (producerId) => this.#producers.get(producerId),
        });
        this.#rtpObservers.set(activeSpeakerObserver.id, activeSpeakerObserver);
        activeSpeakerObserver.on('@close', () => {
            this.#rtpObservers.delete(activeSpeakerObserver.id);
        });
        // Emit observer event.
        this.#observer.safeEmit('newrtpobserver', activeSpeakerObserver);
        return activeSpeakerObserver;
    }
    /**
     * Create an AudioLevelObserver.
     */
    async createAudioLevelObserver({ maxEntries = 1, threshold = -80, interval = 1000, appData, } = {}) {
        logger.debug('createAudioLevelObserver()');
        if (typeof maxEntries !== 'number' || maxEntries <= 0) {
            throw new TypeError('if given, maxEntries must be a positive number');
        }
        else if (typeof threshold !== 'number' ||
            threshold < -127 ||
            threshold > 0) {
            throw new TypeError('if given, threshole must be a negative number greater than -127');
        }
        else if (typeof interval !== 'number') {
            throw new TypeError('if given, interval must be an number');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        const rtpObserverId = (0, utils_1.generateUUIDv4)();
        /* Build Request. */
        const audioLevelObserverOptions = new FbsAudioLevelObserver.AudioLevelObserverOptionsT(maxEntries, threshold, interval);
        const requestOffset = new FbsRouter.CreateAudioLevelObserverRequestT(rtpObserverId, audioLevelObserverOptions).pack(this.#channel.bufferBuilder);
        await this.#channel.request(FbsRequest.Method.ROUTER_CREATE_AUDIOLEVELOBSERVER, FbsRequest.Body.Router_CreateAudioLevelObserverRequest, requestOffset, this.#internal.routerId);
        const audioLevelObserver = new AudioLevelObserver_1.AudioLevelObserver({
            internal: {
                ...this.#internal,
                rtpObserverId: rtpObserverId,
            },
            channel: this.#channel,
            appData,
            getProducerById: (producerId) => this.#producers.get(producerId),
        });
        this.#rtpObservers.set(audioLevelObserver.id, audioLevelObserver);
        audioLevelObserver.on('@close', () => {
            this.#rtpObservers.delete(audioLevelObserver.id);
        });
        // Emit observer event.
        this.#observer.safeEmit('newrtpobserver', audioLevelObserver);
        return audioLevelObserver;
    }
    /**
     * Check whether the given RTP capabilities can consume the given Producer.
     */
    canConsume({ producerId, rtpCapabilities, }) {
        const producer = this.#producers.get(producerId);
        if (!producer) {
            logger.error('canConsume() | Producer with id "%s" not found', producerId);
            return false;
        }
        // Clone given RTP capabilities to not modify input data.
        const clonedRtpCapabilities = (0, utils_1.clone)(rtpCapabilities);
        try {
            return ortc.canConsume(producer.consumableRtpParameters, clonedRtpCapabilities);
        }
        catch (error) {
            logger.error('canConsume() | unexpected error: %s', String(error));
            return false;
        }
    }
}
exports.Router = Router;
function parseRouterDumpResponse(binary) {
    return {
        id: binary.id(),
        transportIds: (0, utils_1.parseVector)(binary, 'transportIds'),
        rtpObserverIds: (0, utils_1.parseVector)(binary, 'rtpObserverIds'),
        mapProducerIdConsumerIds: (0, utils_1.parseStringStringArrayVector)(binary, 'mapProducerIdConsumerIds'),
        mapConsumerIdProducerId: (0, utils_1.parseStringStringVector)(binary, 'mapConsumerIdProducerId'),
        mapProducerIdObserverIds: (0, utils_1.parseStringStringArrayVector)(binary, 'mapProducerIdObserverIds'),
        mapDataProducerIdDataConsumerIds: (0, utils_1.parseStringStringArrayVector)(binary, 'mapDataProducerIdDataConsumerIds'),
        mapDataConsumerIdDataProducerId: (0, utils_1.parseStringStringVector)(binary, 'mapDataConsumerIdDataProducerId'),
    };
}
exports.parseRouterDumpResponse = parseRouterDumpResponse;
function socketFlagsToFbs(flags = {}) {
    return new FbsTransport.SocketFlagsT(Boolean(flags.ipv6Only), Boolean(flags.udpReusePort));
}
exports.socketFlagsToFbs = socketFlagsToFbs;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/RtpObserver.js":
/*!************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/RtpObserver.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpObserver = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsRouter = __webpack_require__(/*! ./fbs/router */ "../../node_modules/mediasoup/node/lib/fbs/router.js");
const FbsRtpObserver = __webpack_require__(/*! ./fbs/rtp-observer */ "../../node_modules/mediasoup/node/lib/fbs/rtp-observer.js");
const logger = new Logger_1.Logger('RtpObserver');
class RtpObserver extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Internal data.
    internal;
    // Channel instance.
    channel;
    // Closed flag.
    #closed = false;
    // Paused flag.
    #paused = false;
    // Custom app data.
    #appData;
    // Method to retrieve a Producer.
    getProducerById;
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     * @interface
     */
    constructor({ internal, channel, appData, getProducerById, }) {
        super();
        logger.debug('constructor()');
        this.internal = internal;
        this.channel = channel;
        this.#appData = appData || {};
        this.getProducerById = getProducerById;
    }
    /**
     * RtpObserver id.
     */
    get id() {
        return this.internal.rtpObserverId;
    }
    /**
     * Whether the RtpObserver is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * Whether the RtpObserver is paused.
     */
    get paused() {
        return this.#paused;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * Close the RtpObserver.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.channel.removeAllListeners(this.internal.rtpObserverId);
        /* Build Request. */
        const requestOffset = new FbsRouter.CloseRtpObserverRequestT(this.internal.rtpObserverId).pack(this.channel.bufferBuilder);
        this.channel
            .request(FbsRequest.Method.ROUTER_CLOSE_RTPOBSERVER, FbsRequest.Body.Router_CloseRtpObserverRequest, requestOffset, this.internal.routerId)
            .catch(() => { });
        this.emit('@close');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Router was closed.
     *
     * @private
     */
    routerClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('routerClosed()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.channel.removeAllListeners(this.internal.rtpObserverId);
        this.safeEmit('routerclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Pause the RtpObserver.
     */
    async pause() {
        logger.debug('pause()');
        const wasPaused = this.#paused;
        await this.channel.request(FbsRequest.Method.RTPOBSERVER_PAUSE, undefined, undefined, this.internal.rtpObserverId);
        this.#paused = true;
        // Emit observer event.
        if (!wasPaused) {
            this.#observer.safeEmit('pause');
        }
    }
    /**
     * Resume the RtpObserver.
     */
    async resume() {
        logger.debug('resume()');
        const wasPaused = this.#paused;
        await this.channel.request(FbsRequest.Method.RTPOBSERVER_RESUME, undefined, undefined, this.internal.rtpObserverId);
        this.#paused = false;
        // Emit observer event.
        if (wasPaused) {
            this.#observer.safeEmit('resume');
        }
    }
    /**
     * Add a Producer to the RtpObserver.
     */
    async addProducer({ producerId, }) {
        logger.debug('addProducer()');
        const producer = this.getProducerById(producerId);
        if (!producer) {
            throw Error(`Producer with id "${producerId}" not found`);
        }
        const requestOffset = new FbsRtpObserver.AddProducerRequestT(producerId).pack(this.channel.bufferBuilder);
        await this.channel.request(FbsRequest.Method.RTPOBSERVER_ADD_PRODUCER, FbsRequest.Body.RtpObserver_AddProducerRequest, requestOffset, this.internal.rtpObserverId);
        // Emit observer event.
        this.#observer.safeEmit('addproducer', producer);
    }
    /**
     * Remove a Producer from the RtpObserver.
     */
    async removeProducer({ producerId, }) {
        logger.debug('removeProducer()');
        const producer = this.getProducerById(producerId);
        if (!producer) {
            throw Error(`Producer with id "${producerId}" not found`);
        }
        const requestOffset = new FbsRtpObserver.RemoveProducerRequestT(producerId).pack(this.channel.bufferBuilder);
        await this.channel.request(FbsRequest.Method.RTPOBSERVER_REMOVE_PRODUCER, FbsRequest.Body.RtpObserver_RemoveProducerRequest, requestOffset, this.internal.rtpObserverId);
        // Emit observer event.
        this.#observer.safeEmit('removeproducer', producer);
    }
}
exports.RtpObserver = RtpObserver;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/RtpParameters.js":
/*!**************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/RtpParameters.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseRtpParameters = exports.parseRtpEncodingParameters = exports.parseRtpHeaderExtensionParameters = exports.rtpHeaderExtensionUriToFbs = exports.rtpHeaderExtensionUriFromFbs = exports.parseRtpCodecParameters = exports.parseParameters = exports.parseRtcpFeedback = exports.serializeParameters = exports.serializeRtpEncodingParameters = exports.serializeRtpParameters = void 0;
const rtp_parameters_1 = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
function serializeRtpParameters(builder, rtpParameters) {
    const codecs = [];
    const headerExtensions = [];
    for (const codec of rtpParameters.codecs) {
        const mimeTypeOffset = builder.createString(codec.mimeType);
        const parameters = serializeParameters(builder, codec.parameters);
        const parametersOffset = rtp_parameters_1.RtpCodecParameters.createParametersVector(builder, parameters);
        const rtcpFeedback = [];
        for (const rtcp of codec.rtcpFeedback ?? []) {
            const typeOffset = builder.createString(rtcp.type);
            const rtcpParametersOffset = builder.createString(rtcp.parameter);
            rtcpFeedback.push(rtp_parameters_1.RtcpFeedback.createRtcpFeedback(builder, typeOffset, rtcpParametersOffset));
        }
        const rtcpFeedbackOffset = rtp_parameters_1.RtpCodecParameters.createRtcpFeedbackVector(builder, rtcpFeedback);
        codecs.push(rtp_parameters_1.RtpCodecParameters.createRtpCodecParameters(builder, mimeTypeOffset, codec.payloadType, codec.clockRate, Number(codec.channels), parametersOffset, rtcpFeedbackOffset));
    }
    const codecsOffset = rtp_parameters_1.RtpParameters.createCodecsVector(builder, codecs);
    // RtpHeaderExtensionParameters.
    for (const headerExtension of rtpParameters.headerExtensions ?? []) {
        const uri = rtpHeaderExtensionUriToFbs(headerExtension.uri);
        const parameters = serializeParameters(builder, headerExtension.parameters);
        const parametersOffset = rtp_parameters_1.RtpCodecParameters.createParametersVector(builder, parameters);
        headerExtensions.push(rtp_parameters_1.RtpHeaderExtensionParameters.createRtpHeaderExtensionParameters(builder, uri, headerExtension.id, Boolean(headerExtension.encrypt), parametersOffset));
    }
    const headerExtensionsOffset = rtp_parameters_1.RtpParameters.createHeaderExtensionsVector(builder, headerExtensions);
    // RtpEncodingParameters.
    const encodingsOffset = serializeRtpEncodingParameters(builder, rtpParameters.encodings ?? []);
    // RtcpParameters.
    const { cname, reducedSize } = rtpParameters.rtcp ?? { reducedSize: true };
    const cnameOffset = builder.createString(cname);
    const rtcpOffset = rtp_parameters_1.RtcpParameters.createRtcpParameters(builder, cnameOffset, Boolean(reducedSize));
    const midOffset = builder.createString(rtpParameters.mid);
    rtp_parameters_1.RtpParameters.startRtpParameters(builder);
    rtp_parameters_1.RtpParameters.addMid(builder, midOffset);
    rtp_parameters_1.RtpParameters.addCodecs(builder, codecsOffset);
    rtp_parameters_1.RtpParameters.addHeaderExtensions(builder, headerExtensionsOffset);
    rtp_parameters_1.RtpParameters.addEncodings(builder, encodingsOffset);
    rtp_parameters_1.RtpParameters.addRtcp(builder, rtcpOffset);
    return rtp_parameters_1.RtpParameters.endRtpParameters(builder);
}
exports.serializeRtpParameters = serializeRtpParameters;
function serializeRtpEncodingParameters(builder, rtpEncodingParameters = []) {
    const encodings = [];
    for (const encoding of rtpEncodingParameters) {
        // Prepare Rid.
        const ridOffset = builder.createString(encoding.rid);
        // Prepare Rtx.
        let rtxOffset;
        if (encoding.rtx) {
            rtxOffset = rtp_parameters_1.Rtx.createRtx(builder, encoding.rtx.ssrc);
        }
        // Prepare scalability mode.
        let scalabilityModeOffset;
        if (encoding.scalabilityMode) {
            scalabilityModeOffset = builder.createString(encoding.scalabilityMode);
        }
        // Start serialization.
        rtp_parameters_1.RtpEncodingParameters.startRtpEncodingParameters(builder);
        // Add SSRC.
        if (encoding.ssrc) {
            rtp_parameters_1.RtpEncodingParameters.addSsrc(builder, encoding.ssrc);
        }
        // Add Rid.
        rtp_parameters_1.RtpEncodingParameters.addRid(builder, ridOffset);
        // Add payload type.
        if (encoding.codecPayloadType) {
            rtp_parameters_1.RtpEncodingParameters.addCodecPayloadType(builder, encoding.codecPayloadType);
        }
        // Add RTX.
        if (rtxOffset) {
            rtp_parameters_1.RtpEncodingParameters.addRtx(builder, rtxOffset);
        }
        // Add DTX.
        if (encoding.dtx !== undefined) {
            rtp_parameters_1.RtpEncodingParameters.addDtx(builder, encoding.dtx);
        }
        // Add scalability ode.
        if (scalabilityModeOffset) {
            rtp_parameters_1.RtpEncodingParameters.addScalabilityMode(builder, scalabilityModeOffset);
        }
        // Add max bitrate.
        if (encoding.maxBitrate !== undefined) {
            rtp_parameters_1.RtpEncodingParameters.addMaxBitrate(builder, encoding.maxBitrate);
        }
        // End serialization.
        encodings.push(rtp_parameters_1.RtpEncodingParameters.endRtpEncodingParameters(builder));
    }
    return rtp_parameters_1.RtpParameters.createEncodingsVector(builder, encodings);
}
exports.serializeRtpEncodingParameters = serializeRtpEncodingParameters;
function serializeParameters(builder, parameters) {
    const fbsParameters = [];
    for (const key of Object.keys(parameters)) {
        const value = parameters[key];
        const keyOffset = builder.createString(key);
        let parameterOffset;
        if (typeof value === 'boolean') {
            parameterOffset = rtp_parameters_1.Parameter.createParameter(builder, keyOffset, rtp_parameters_1.Value.Boolean, value === true ? 1 : 0);
        }
        else if (typeof value === 'number') {
            // Integer.
            if (value % 1 === 0) {
                const valueOffset = rtp_parameters_1.Integer32.createInteger32(builder, value);
                parameterOffset = rtp_parameters_1.Parameter.createParameter(builder, keyOffset, rtp_parameters_1.Value.Integer32, valueOffset);
            }
            // Float.
            else {
                const valueOffset = rtp_parameters_1.Double.createDouble(builder, value);
                parameterOffset = rtp_parameters_1.Parameter.createParameter(builder, keyOffset, rtp_parameters_1.Value.Double, valueOffset);
            }
        }
        else if (typeof value === 'string') {
            const valueOffset = rtp_parameters_1.String.createString(builder, builder.createString(value));
            parameterOffset = rtp_parameters_1.Parameter.createParameter(builder, keyOffset, rtp_parameters_1.Value.String, valueOffset);
        }
        else if (Array.isArray(value)) {
            const valueOffset = rtp_parameters_1.Integer32Array.createValueVector(builder, value);
            parameterOffset = rtp_parameters_1.Parameter.createParameter(builder, keyOffset, rtp_parameters_1.Value.Integer32Array, valueOffset);
        }
        else {
            throw new Error(`invalid parameter type [key:'${key}', value:${value}]`);
        }
        fbsParameters.push(parameterOffset);
    }
    return fbsParameters;
}
exports.serializeParameters = serializeParameters;
function parseRtcpFeedback(data) {
    return {
        type: data.type(),
        parameter: data.parameter() ?? undefined,
    };
}
exports.parseRtcpFeedback = parseRtcpFeedback;
function parseParameters(data) {
    const parameters = {};
    for (let i = 0; i < data.parametersLength(); i++) {
        const fbsParameter = data.parameters(i);
        switch (fbsParameter.valueType()) {
            case rtp_parameters_1.Value.Boolean: {
                const value = new rtp_parameters_1.Boolean();
                fbsParameter.value(value);
                parameters[String(fbsParameter.name())] = value.value();
                break;
            }
            case rtp_parameters_1.Value.Integer32: {
                const value = new rtp_parameters_1.Integer32();
                fbsParameter.value(value);
                parameters[String(fbsParameter.name())] = value.value();
                break;
            }
            case rtp_parameters_1.Value.Double: {
                const value = new rtp_parameters_1.Double();
                fbsParameter.value(value);
                parameters[String(fbsParameter.name())] = value.value();
                break;
            }
            case rtp_parameters_1.Value.String: {
                const value = new rtp_parameters_1.String();
                fbsParameter.value(value);
                parameters[String(fbsParameter.name())] = value.value();
                break;
            }
            case rtp_parameters_1.Value.Integer32Array: {
                const value = new rtp_parameters_1.Integer32Array();
                fbsParameter.value(value);
                parameters[String(fbsParameter.name())] = value.valueArray();
                break;
            }
        }
    }
    return parameters;
}
exports.parseParameters = parseParameters;
function parseRtpCodecParameters(data) {
    const parameters = parseParameters(data);
    let rtcpFeedback = [];
    if (data.rtcpFeedbackLength() > 0) {
        rtcpFeedback = utils.parseVector(data, 'rtcpFeedback', parseRtcpFeedback);
    }
    return {
        mimeType: data.mimeType(),
        payloadType: data.payloadType(),
        clockRate: data.clockRate(),
        channels: data.channels() ?? undefined,
        parameters,
        rtcpFeedback,
    };
}
exports.parseRtpCodecParameters = parseRtpCodecParameters;
function rtpHeaderExtensionUriFromFbs(uri) {
    switch (uri) {
        case rtp_parameters_1.RtpHeaderExtensionUri.Mid: {
            return 'urn:ietf:params:rtp-hdrext:sdes:mid';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.RtpStreamId: {
            return 'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.RepairRtpStreamId: {
            return 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.FrameMarkingDraft07: {
            return 'http://tools.ietf.org/html/draft-ietf-avtext-framemarking-07';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.FrameMarking: {
            return 'urn:ietf:params:rtp-hdrext:framemarking';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.AudioLevel: {
            return 'urn:ietf:params:rtp-hdrext:ssrc-audio-level';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.VideoOrientation: {
            return 'urn:3gpp:video-orientation';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.TimeOffset: {
            return 'urn:ietf:params:rtp-hdrext:toffset';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.TransportWideCcDraft01: {
            return 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.AbsSendTime: {
            return 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time';
        }
        case rtp_parameters_1.RtpHeaderExtensionUri.AbsCaptureTime: {
            return 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time';
        }
    }
}
exports.rtpHeaderExtensionUriFromFbs = rtpHeaderExtensionUriFromFbs;
function rtpHeaderExtensionUriToFbs(uri) {
    switch (uri) {
        case 'urn:ietf:params:rtp-hdrext:sdes:mid': {
            return rtp_parameters_1.RtpHeaderExtensionUri.Mid;
        }
        case 'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id': {
            return rtp_parameters_1.RtpHeaderExtensionUri.RtpStreamId;
        }
        case 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id': {
            return rtp_parameters_1.RtpHeaderExtensionUri.RepairRtpStreamId;
        }
        case 'http://tools.ietf.org/html/draft-ietf-avtext-framemarking-07': {
            return rtp_parameters_1.RtpHeaderExtensionUri.FrameMarkingDraft07;
        }
        case 'urn:ietf:params:rtp-hdrext:framemarking': {
            return rtp_parameters_1.RtpHeaderExtensionUri.FrameMarking;
        }
        case 'urn:ietf:params:rtp-hdrext:ssrc-audio-level': {
            return rtp_parameters_1.RtpHeaderExtensionUri.AudioLevel;
        }
        case 'urn:3gpp:video-orientation': {
            return rtp_parameters_1.RtpHeaderExtensionUri.VideoOrientation;
        }
        case 'urn:ietf:params:rtp-hdrext:toffset': {
            return rtp_parameters_1.RtpHeaderExtensionUri.TimeOffset;
        }
        case 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01': {
            return rtp_parameters_1.RtpHeaderExtensionUri.TransportWideCcDraft01;
        }
        case 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time': {
            return rtp_parameters_1.RtpHeaderExtensionUri.AbsSendTime;
        }
        case 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time': {
            return rtp_parameters_1.RtpHeaderExtensionUri.AbsCaptureTime;
        }
        default: {
            throw new TypeError(`invalid RtpHeaderExtensionUri: ${uri}`);
        }
    }
}
exports.rtpHeaderExtensionUriToFbs = rtpHeaderExtensionUriToFbs;
function parseRtpHeaderExtensionParameters(data) {
    return {
        uri: rtpHeaderExtensionUriFromFbs(data.uri()),
        id: data.id(),
        encrypt: data.encrypt(),
        parameters: parseParameters(data),
    };
}
exports.parseRtpHeaderExtensionParameters = parseRtpHeaderExtensionParameters;
function parseRtpEncodingParameters(data) {
    return {
        ssrc: data.ssrc() ?? undefined,
        rid: data.rid() ?? undefined,
        codecPayloadType: data.codecPayloadType() !== null ? data.codecPayloadType() : undefined,
        rtx: data.rtx() ? { ssrc: data.rtx().ssrc() } : undefined,
        dtx: data.dtx(),
        scalabilityMode: data.scalabilityMode() ?? undefined,
        maxBitrate: data.maxBitrate() !== null ? data.maxBitrate() : undefined,
    };
}
exports.parseRtpEncodingParameters = parseRtpEncodingParameters;
function parseRtpParameters(data) {
    const codecs = utils.parseVector(data, 'codecs', parseRtpCodecParameters);
    let headerExtensions = [];
    if (data.headerExtensionsLength() > 0) {
        headerExtensions = utils.parseVector(data, 'headerExtensions', parseRtpHeaderExtensionParameters);
    }
    let encodings = [];
    if (data.encodingsLength() > 0) {
        encodings = utils.parseVector(data, 'encodings', parseRtpEncodingParameters);
    }
    let rtcp;
    if (data.rtcp()) {
        const fbsRtcp = data.rtcp();
        rtcp = {
            cname: fbsRtcp.cname() ?? undefined,
            reducedSize: fbsRtcp.reducedSize(),
        };
    }
    return {
        mid: data.mid() ?? undefined,
        codecs,
        headerExtensions,
        encodings,
        rtcp,
    };
}
exports.parseRtpParameters = parseRtpParameters;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/RtpStream.js":
/*!**********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/RtpStream.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSendStreamStats = exports.parseRtpStreamRecvStats = exports.parseRtpStreamStats = void 0;
const FbsRtpStream = __webpack_require__(/*! ./fbs/rtp-stream */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream.js");
const FbsRtpParameters = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
function parseRtpStreamStats(binary) {
    if (binary.dataType() === FbsRtpStream.StatsData.RecvStats) {
        return parseRtpStreamRecvStats(binary);
    }
    else {
        return parseSendStreamStats(binary);
    }
}
exports.parseRtpStreamStats = parseRtpStreamStats;
function parseRtpStreamRecvStats(binary) {
    const recvStats = new FbsRtpStream.RecvStats();
    const baseStats = new FbsRtpStream.BaseStats();
    binary.data(recvStats);
    recvStats.base().data(baseStats);
    const base = parseBaseStreamStats(baseStats);
    return {
        ...base,
        type: 'inbound-rtp',
        jitter: recvStats.jitter(),
        byteCount: Number(recvStats.byteCount()),
        packetCount: Number(recvStats.packetCount()),
        bitrate: Number(recvStats.bitrate()),
        bitrateByLayer: parseBitrateByLayer(recvStats),
    };
}
exports.parseRtpStreamRecvStats = parseRtpStreamRecvStats;
function parseSendStreamStats(binary) {
    const sendStats = new FbsRtpStream.SendStats();
    const baseStats = new FbsRtpStream.BaseStats();
    binary.data(sendStats);
    sendStats.base().data(baseStats);
    const base = parseBaseStreamStats(baseStats);
    return {
        ...base,
        type: 'outbound-rtp',
        byteCount: Number(sendStats.byteCount()),
        packetCount: Number(sendStats.packetCount()),
        bitrate: Number(sendStats.bitrate()),
    };
}
exports.parseSendStreamStats = parseSendStreamStats;
function parseBaseStreamStats(binary) {
    return {
        timestamp: Number(binary.timestamp()),
        ssrc: binary.ssrc(),
        rtxSsrc: binary.rtxSsrc() ?? undefined,
        rid: binary.rid() ?? undefined,
        kind: binary.kind() === FbsRtpParameters.MediaKind.AUDIO ? 'audio' : 'video',
        mimeType: binary.mimeType(),
        packetsLost: Number(binary.packetsLost()),
        fractionLost: Number(binary.fractionLost()),
        packetsDiscarded: Number(binary.packetsDiscarded()),
        packetsRetransmitted: Number(binary.packetsRetransmitted()),
        packetsRepaired: Number(binary.packetsRepaired()),
        nackCount: Number(binary.nackCount()),
        nackPacketCount: Number(binary.nackPacketCount()),
        pliCount: Number(binary.pliCount()),
        firCount: Number(binary.firCount()),
        score: binary.score(),
        roundTripTime: binary.roundTripTime(),
        rtxPacketsDiscarded: binary.rtxPacketsDiscarded()
            ? Number(binary.rtxPacketsDiscarded())
            : undefined,
    };
}
function parseBitrateByLayer(binary) {
    if (binary.bitrateByLayerLength() === 0) {
        return {};
    }
    const bitRateByLayer = {};
    for (let i = 0; i < binary.bitrateByLayerLength(); ++i) {
        const layer = binary.bitrateByLayer(i).layer();
        const bitrate = binary.bitrateByLayer(i).bitrate();
        bitRateByLayer[layer] = Number(bitrate);
    }
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/SctpParameters.js":
/*!***************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/SctpParameters.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSctpStreamParameters = exports.serializeSctpStreamParameters = exports.parseSctpParametersDump = void 0;
const FbsSctpParameters = __webpack_require__(/*! ./fbs/sctp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters.js");
function parseSctpParametersDump(binary) {
    return {
        port: binary.port(),
        OS: binary.os(),
        MIS: binary.mis(),
        maxMessageSize: binary.maxMessageSize(),
        sendBufferSize: binary.sendBufferSize(),
        sctpBufferedAmount: binary.sctpBufferedAmount(),
        isDataChannel: binary.isDataChannel(),
    };
}
exports.parseSctpParametersDump = parseSctpParametersDump;
function serializeSctpStreamParameters(builder, parameters) {
    return FbsSctpParameters.SctpStreamParameters.createSctpStreamParameters(builder, parameters.streamId, parameters.ordered, typeof parameters.maxPacketLifeTime === 'number'
        ? parameters.maxPacketLifeTime
        : null, typeof parameters.maxRetransmits === 'number'
        ? parameters.maxRetransmits
        : null);
}
exports.serializeSctpStreamParameters = serializeSctpStreamParameters;
function parseSctpStreamParameters(parameters) {
    return {
        streamId: parameters.streamId(),
        ordered: parameters.ordered(),
        maxPacketLifeTime: parameters.maxPacketLifeTime() !== null
            ? parameters.maxPacketLifeTime()
            : undefined,
        maxRetransmits: parameters.maxRetransmits() !== null
            ? parameters.maxRetransmits()
            : undefined,
    };
}
exports.parseSctpStreamParameters = parseSctpStreamParameters;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/SrtpParameters.js":
/*!***************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/SrtpParameters.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeSrtpParameters = exports.parseSrtpParameters = exports.cryptoSuiteToFbs = exports.cryptoSuiteFromFbs = void 0;
const FbsSrtpParameters = __webpack_require__(/*! ./fbs/srtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters.js");
function cryptoSuiteFromFbs(binary) {
    switch (binary) {
        case FbsSrtpParameters.SrtpCryptoSuite.AEAD_AES_256_GCM: {
            return 'AEAD_AES_256_GCM';
        }
        case FbsSrtpParameters.SrtpCryptoSuite.AEAD_AES_128_GCM: {
            return 'AEAD_AES_128_GCM';
        }
        case FbsSrtpParameters.SrtpCryptoSuite.AES_CM_128_HMAC_SHA1_80: {
            return 'AES_CM_128_HMAC_SHA1_80';
        }
        case FbsSrtpParameters.SrtpCryptoSuite.AES_CM_128_HMAC_SHA1_32: {
            return 'AES_CM_128_HMAC_SHA1_32';
        }
    }
}
exports.cryptoSuiteFromFbs = cryptoSuiteFromFbs;
function cryptoSuiteToFbs(cryptoSuite) {
    switch (cryptoSuite) {
        case 'AEAD_AES_256_GCM': {
            return FbsSrtpParameters.SrtpCryptoSuite.AEAD_AES_256_GCM;
        }
        case 'AEAD_AES_128_GCM': {
            return FbsSrtpParameters.SrtpCryptoSuite.AEAD_AES_128_GCM;
        }
        case 'AES_CM_128_HMAC_SHA1_80': {
            return FbsSrtpParameters.SrtpCryptoSuite.AES_CM_128_HMAC_SHA1_80;
        }
        case 'AES_CM_128_HMAC_SHA1_32': {
            return FbsSrtpParameters.SrtpCryptoSuite.AES_CM_128_HMAC_SHA1_32;
        }
        default: {
            throw new TypeError(`invalid SrtpCryptoSuite: ${cryptoSuite}`);
        }
    }
}
exports.cryptoSuiteToFbs = cryptoSuiteToFbs;
function parseSrtpParameters(binary) {
    return {
        cryptoSuite: cryptoSuiteFromFbs(binary.cryptoSuite()),
        keyBase64: binary.keyBase64(),
    };
}
exports.parseSrtpParameters = parseSrtpParameters;
function serializeSrtpParameters(builder, srtpParameters) {
    const keyBase64Offset = builder.createString(srtpParameters.keyBase64);
    return FbsSrtpParameters.SrtpParameters.createSrtpParameters(builder, cryptoSuiteToFbs(srtpParameters.cryptoSuite), keyBase64Offset);
}
exports.serializeSrtpParameters = serializeSrtpParameters;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/Transport.js":
/*!**********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/Transport.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseTransportTraceEventData = exports.parseBaseTransportStats = exports.parseBaseTransportDump = exports.parseTuple = exports.serializeProtocol = exports.parseProtocol = exports.parseSctpState = exports.Transport = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const ortc = __webpack_require__(/*! ./ortc */ "../../node_modules/mediasoup/node/lib/ortc.js");
const Producer_1 = __webpack_require__(/*! ./Producer */ "../../node_modules/mediasoup/node/lib/Producer.js");
const Consumer_1 = __webpack_require__(/*! ./Consumer */ "../../node_modules/mediasoup/node/lib/Consumer.js");
const DataProducer_1 = __webpack_require__(/*! ./DataProducer */ "../../node_modules/mediasoup/node/lib/DataProducer.js");
const DataConsumer_1 = __webpack_require__(/*! ./DataConsumer */ "../../node_modules/mediasoup/node/lib/DataConsumer.js");
const RtpParameters_1 = __webpack_require__(/*! ./RtpParameters */ "../../node_modules/mediasoup/node/lib/RtpParameters.js");
const SctpParameters_1 = __webpack_require__(/*! ./SctpParameters */ "../../node_modules/mediasoup/node/lib/SctpParameters.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const common_1 = __webpack_require__(/*! ./fbs/common */ "../../node_modules/mediasoup/node/lib/fbs/common.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const media_kind_1 = __webpack_require__(/*! ./fbs/rtp-parameters/media-kind */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js");
const FbsConsumer = __webpack_require__(/*! ./fbs/consumer */ "../../node_modules/mediasoup/node/lib/fbs/consumer.js");
const FbsDataConsumer = __webpack_require__(/*! ./fbs/data-consumer */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer.js");
const FbsDataProducer = __webpack_require__(/*! ./fbs/data-producer */ "../../node_modules/mediasoup/node/lib/fbs/data-producer.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsRouter = __webpack_require__(/*! ./fbs/router */ "../../node_modules/mediasoup/node/lib/fbs/router.js");
const FbsRtpParameters = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
const sctp_state_1 = __webpack_require__(/*! ./fbs/sctp-association/sctp-state */ "../../node_modules/mediasoup/node/lib/fbs/sctp-association/sctp-state.js");
const logger = new Logger_1.Logger('Transport');
class Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Internal data.
    internal;
    // Transport data. This is set by the subclass.
    #data;
    // Channel instance.
    channel;
    // Close flag.
    #closed = false;
    // Custom app data.
    #appData;
    // Method to retrieve Router RTP capabilities.
    #getRouterRtpCapabilities;
    // Method to retrieve a Producer.
    getProducerById;
    // Method to retrieve a DataProducer.
    getDataProducerById;
    // Producers map.
    #producers = new Map();
    // Consumers map.
    consumers = new Map();
    // DataProducers map.
    dataProducers = new Map();
    // DataConsumers map.
    dataConsumers = new Map();
    // RTCP CNAME for Producers.
    #cnameForProducers;
    // Next MID for Consumers. It's converted into string when used.
    #nextMidForConsumers = 0;
    // Buffer with available SCTP stream ids.
    #sctpStreamIds;
    // Next SCTP stream id.
    #nextSctpStreamId = 0;
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     * @interface
     */
    constructor({ internal, data, channel, appData, getRouterRtpCapabilities, getProducerById, getDataProducerById, }) {
        super();
        logger.debug('constructor()');
        this.internal = internal;
        this.#data = data;
        this.channel = channel;
        this.#appData = appData || {};
        this.#getRouterRtpCapabilities = getRouterRtpCapabilities;
        this.getProducerById = getProducerById;
        this.getDataProducerById = getDataProducerById;
    }
    /**
     * Transport id.
     */
    get id() {
        return this.internal.transportId;
    }
    /**
     * Whether the Transport is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * @private
     * Just for testing purposes.
     */
    get channelForTesting() {
        return this.channel;
    }
    /**
     * Close the Transport.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.channel.removeAllListeners(this.internal.transportId);
        /* Build Request. */
        const requestOffset = new FbsRouter.CloseTransportRequestT(this.internal.transportId).pack(this.channel.bufferBuilder);
        this.channel
            .request(FbsRequest.Method.ROUTER_CLOSE_TRANSPORT, FbsRequest.Body.Router_CloseTransportRequest, requestOffset, this.internal.routerId)
            .catch(() => { });
        // Close every Producer.
        for (const producer of this.#producers.values()) {
            producer.transportClosed();
            // Must tell the Router.
            this.emit('@producerclose', producer);
        }
        this.#producers.clear();
        // Close every Consumer.
        for (const consumer of this.consumers.values()) {
            consumer.transportClosed();
        }
        this.consumers.clear();
        // Close every DataProducer.
        for (const dataProducer of this.dataProducers.values()) {
            dataProducer.transportClosed();
            // Must tell the Router.
            this.emit('@dataproducerclose', dataProducer);
        }
        this.dataProducers.clear();
        // Close every DataConsumer.
        for (const dataConsumer of this.dataConsumers.values()) {
            dataConsumer.transportClosed();
        }
        this.dataConsumers.clear();
        this.emit('@close');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Router was closed.
     *
     * @private
     * @virtual
     */
    routerClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('routerClosed()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.channel.removeAllListeners(this.internal.transportId);
        // Close every Producer.
        for (const producer of this.#producers.values()) {
            producer.transportClosed();
            // NOTE: No need to tell the Router since it already knows (it has
            // been closed in fact).
        }
        this.#producers.clear();
        // Close every Consumer.
        for (const consumer of this.consumers.values()) {
            consumer.transportClosed();
        }
        this.consumers.clear();
        // Close every DataProducer.
        for (const dataProducer of this.dataProducers.values()) {
            dataProducer.transportClosed();
            // NOTE: No need to tell the Router since it already knows (it has
            // been closed in fact).
        }
        this.dataProducers.clear();
        // Close every DataConsumer.
        for (const dataConsumer of this.dataConsumers.values()) {
            dataConsumer.transportClosed();
        }
        this.dataConsumers.clear();
        this.safeEmit('routerclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Listen server was closed (this just happens in WebRtcTransports when their
     * associated WebRtcServer is closed).
     *
     * @private
     */
    listenServerClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('listenServerClosed()');
        this.#closed = true;
        // Remove notification subscriptions.
        this.channel.removeAllListeners(this.internal.transportId);
        // Close every Producer.
        for (const producer of this.#producers.values()) {
            producer.transportClosed();
            // NOTE: No need to tell the Router since it already knows (it has
            // been closed in fact).
        }
        this.#producers.clear();
        // Close every Consumer.
        for (const consumer of this.consumers.values()) {
            consumer.transportClosed();
        }
        this.consumers.clear();
        // Close every DataProducer.
        for (const dataProducer of this.dataProducers.values()) {
            dataProducer.transportClosed();
            // NOTE: No need to tell the Router since it already knows (it has
            // been closed in fact).
        }
        this.dataProducers.clear();
        // Close every DataConsumer.
        for (const dataConsumer of this.dataConsumers.values()) {
            dataConsumer.transportClosed();
        }
        this.dataConsumers.clear();
        // Need to emit this event to let the parent Router know since
        // transport.listenServerClosed() is called by the listen server.
        // NOTE: Currently there is just WebRtcServer for WebRtcTransports.
        this.emit('@listenserverclose');
        this.safeEmit('listenserverclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Dump Transport.
     *
     * @abstract
     */
    async dump() {
        // Should not happen.
        throw new Error('method implemented in the subclass');
    }
    /**
     * Get Transport stats.
     *
     * @abstract
     */
    async getStats() {
        // Should not happen.
        throw new Error('method implemented in the subclass');
    }
    /**
     * Provide the Transport remote parameters.
     *
     * @abstract
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async connect(params) {
        // Should not happen.
        throw new Error('method implemented in the subclass');
    }
    /**
     * Set maximum incoming bitrate for receiving media.
     */
    async setMaxIncomingBitrate(bitrate) {
        logger.debug('setMaxIncomingBitrate() [bitrate:%s]', bitrate);
        /* Build Request. */
        const requestOffset = FbsTransport.SetMaxIncomingBitrateRequest.createSetMaxIncomingBitrateRequest(this.channel.bufferBuilder, bitrate);
        await this.channel.request(FbsRequest.Method.TRANSPORT_SET_MAX_INCOMING_BITRATE, FbsRequest.Body.Transport_SetMaxIncomingBitrateRequest, requestOffset, this.internal.transportId);
    }
    /**
     * Set maximum outgoing bitrate for sending media.
     */
    async setMaxOutgoingBitrate(bitrate) {
        logger.debug('setMaxOutgoingBitrate() [bitrate:%s]', bitrate);
        /* Build Request. */
        const requestOffset = new FbsTransport.SetMaxOutgoingBitrateRequestT(bitrate).pack(this.channel.bufferBuilder);
        await this.channel.request(FbsRequest.Method.TRANSPORT_SET_MAX_OUTGOING_BITRATE, FbsRequest.Body.Transport_SetMaxOutgoingBitrateRequest, requestOffset, this.internal.transportId);
    }
    /**
     * Set minimum outgoing bitrate for sending media.
     */
    async setMinOutgoingBitrate(bitrate) {
        logger.debug('setMinOutgoingBitrate() [bitrate:%s]', bitrate);
        /* Build Request. */
        const requestOffset = new FbsTransport.SetMinOutgoingBitrateRequestT(bitrate).pack(this.channel.bufferBuilder);
        await this.channel.request(FbsRequest.Method.TRANSPORT_SET_MIN_OUTGOING_BITRATE, FbsRequest.Body.Transport_SetMinOutgoingBitrateRequest, requestOffset, this.internal.transportId);
    }
    /**
     * Create a Producer.
     */
    async produce({ id = undefined, kind, rtpParameters, paused = false, keyFrameRequestDelay, appData, }) {
        logger.debug('produce()');
        if (id && this.#producers.has(id)) {
            throw new TypeError(`a Producer with same id "${id}" already exists`);
        }
        else if (!['audio', 'video'].includes(kind)) {
            throw new TypeError(`invalid kind "${kind}"`);
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Clone given RTP parameters to not modify input data.
        const clonedRtpParameters = utils.clone(rtpParameters);
        // This may throw.
        ortc.validateRtpParameters(clonedRtpParameters);
        // If missing or empty encodings, add one.
        if (!clonedRtpParameters.encodings ||
            !Array.isArray(clonedRtpParameters.encodings) ||
            clonedRtpParameters.encodings.length === 0) {
            clonedRtpParameters.encodings = [{}];
        }
        // Don't do this in PipeTransports since there we must keep CNAME value in
        // each Producer.
        if (this.constructor.name !== 'PipeTransport') {
            // If CNAME is given and we don't have yet a CNAME for Producers in this
            // Transport, take it.
            if (!this.#cnameForProducers &&
                clonedRtpParameters.rtcp &&
                clonedRtpParameters.rtcp.cname) {
                this.#cnameForProducers = clonedRtpParameters.rtcp.cname;
            }
            // Otherwise if we don't have yet a CNAME for Producers and the RTP
            // parameters do not include CNAME, create a random one.
            else if (!this.#cnameForProducers) {
                this.#cnameForProducers = utils.generateUUIDv4().substr(0, 8);
            }
            // Override Producer's CNAME.
            clonedRtpParameters.rtcp = clonedRtpParameters.rtcp ?? {};
            clonedRtpParameters.rtcp.cname = this.#cnameForProducers;
        }
        const routerRtpCapabilities = this.#getRouterRtpCapabilities();
        // This may throw.
        const rtpMapping = ortc.getProducerRtpParametersMapping(clonedRtpParameters, routerRtpCapabilities);
        // This may throw.
        const consumableRtpParameters = ortc.getConsumableRtpParameters(kind, clonedRtpParameters, routerRtpCapabilities, rtpMapping);
        const producerId = id || utils.generateUUIDv4();
        const requestOffset = createProduceRequest({
            builder: this.channel.bufferBuilder,
            producerId,
            kind,
            rtpParameters: clonedRtpParameters,
            rtpMapping,
            keyFrameRequestDelay,
            paused,
        });
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_PRODUCE, FbsRequest.Body.Transport_ProduceRequest, requestOffset, this.internal.transportId);
        /* Decode Response. */
        const produceResponse = new FbsTransport.ProduceResponse();
        response.body(produceResponse);
        const status = produceResponse.unpack();
        const data = {
            kind,
            rtpParameters: clonedRtpParameters,
            type: (0, Producer_1.producerTypeFromFbs)(status.type),
            consumableRtpParameters,
        };
        const producer = new Producer_1.Producer({
            internal: {
                ...this.internal,
                producerId,
            },
            data,
            channel: this.channel,
            appData,
            paused,
        });
        this.#producers.set(producer.id, producer);
        producer.on('@close', () => {
            this.#producers.delete(producer.id);
            this.emit('@producerclose', producer);
        });
        this.emit('@newproducer', producer);
        // Emit observer event.
        this.#observer.safeEmit('newproducer', producer);
        return producer;
    }
    /**
     * Create a Consumer.
     *
     * @virtual
     */
    async consume({ producerId, rtpCapabilities, paused = false, mid, preferredLayers, ignoreDtx = false, enableRtx, pipe = false, appData, }) {
        logger.debug('consume()');
        if (!producerId || typeof producerId !== 'string') {
            throw new TypeError('missing producerId');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        else if (mid && (typeof mid !== 'string' || mid.length === 0)) {
            throw new TypeError('if given, mid must be non empty string');
        }
        // Clone given RTP capabilities to not modify input data.
        const clonedRtpCapabilities = utils.clone(rtpCapabilities);
        // This may throw.
        ortc.validateRtpCapabilities(clonedRtpCapabilities);
        const producer = this.getProducerById(producerId);
        if (!producer) {
            throw Error(`Producer with id "${producerId}" not found`);
        }
        // If enableRtx is not given, set it to true if video and false if audio.
        if (enableRtx === undefined) {
            enableRtx = producer.kind === 'video';
        }
        // This may throw.
        const rtpParameters = ortc.getConsumerRtpParameters({
            consumableRtpParameters: producer.consumableRtpParameters,
            remoteRtpCapabilities: clonedRtpCapabilities,
            pipe,
            enableRtx,
        });
        // Set MID.
        if (!pipe) {
            if (mid) {
                rtpParameters.mid = mid;
            }
            else {
                rtpParameters.mid = `${this.#nextMidForConsumers++}`;
                // We use up to 8 bytes for MID (string).
                if (this.#nextMidForConsumers === 100000000) {
                    logger.error(`consume() | reaching max MID value "${this.#nextMidForConsumers}"`);
                    this.#nextMidForConsumers = 0;
                }
            }
        }
        const consumerId = utils.generateUUIDv4();
        const requestOffset = createConsumeRequest({
            builder: this.channel.bufferBuilder,
            producer,
            consumerId,
            rtpParameters,
            paused,
            preferredLayers,
            ignoreDtx,
            pipe,
        });
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_CONSUME, FbsRequest.Body.Transport_ConsumeRequest, requestOffset, this.internal.transportId);
        /* Decode Response. */
        const consumeResponse = new FbsTransport.ConsumeResponse();
        response.body(consumeResponse);
        const status = consumeResponse.unpack();
        const data = {
            producerId,
            kind: producer.kind,
            rtpParameters,
            type: pipe ? 'pipe' : producer.type,
        };
        const consumer = new Consumer_1.Consumer({
            internal: {
                ...this.internal,
                consumerId,
            },
            data,
            channel: this.channel,
            appData,
            paused: status.paused,
            producerPaused: status.producerPaused,
            score: status.score ?? undefined,
            preferredLayers: status.preferredLayers
                ? {
                    spatialLayer: status.preferredLayers.spatialLayer,
                    temporalLayer: status.preferredLayers.temporalLayer !== null
                        ? status.preferredLayers.temporalLayer
                        : undefined,
                }
                : undefined,
        });
        this.consumers.set(consumer.id, consumer);
        consumer.on('@close', () => this.consumers.delete(consumer.id));
        consumer.on('@producerclose', () => this.consumers.delete(consumer.id));
        // Emit observer event.
        this.#observer.safeEmit('newconsumer', consumer);
        return consumer;
    }
    /**
     * Create a DataProducer.
     */
    async produceData({ id = undefined, sctpStreamParameters, label = '', protocol = '', paused = false, appData, } = {}) {
        logger.debug('produceData()');
        if (id && this.dataProducers.has(id)) {
            throw new TypeError(`a DataProducer with same id "${id}" already exists`);
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        let type;
        // Clone given SCTP stream parameters to not modify input data.
        let clonedSctpStreamParameters = utils.clone(sctpStreamParameters);
        // If this is not a DirectTransport, sctpStreamParameters are required.
        if (this.constructor.name !== 'DirectTransport') {
            type = 'sctp';
            // This may throw.
            ortc.validateSctpStreamParameters(clonedSctpStreamParameters);
        }
        // If this is a DirectTransport, sctpStreamParameters must not be given.
        else {
            type = 'direct';
            if (sctpStreamParameters) {
                logger.warn('produceData() | sctpStreamParameters are ignored when producing data on a DirectTransport');
                clonedSctpStreamParameters = undefined;
            }
        }
        const dataProducerId = id || utils.generateUUIDv4();
        const requestOffset = createProduceDataRequest({
            builder: this.channel.bufferBuilder,
            dataProducerId,
            type,
            sctpStreamParameters: clonedSctpStreamParameters,
            label,
            protocol,
            paused,
        });
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_PRODUCE_DATA, FbsRequest.Body.Transport_ProduceDataRequest, requestOffset, this.internal.transportId);
        /* Decode Response. */
        const produceDataResponse = new FbsDataProducer.DumpResponse();
        response.body(produceDataResponse);
        const dump = (0, DataProducer_1.parseDataProducerDumpResponse)(produceDataResponse);
        const dataProducer = new DataProducer_1.DataProducer({
            internal: {
                ...this.internal,
                dataProducerId,
            },
            data: {
                type: dump.type,
                sctpStreamParameters: dump.sctpStreamParameters,
                label: dump.label,
                protocol: dump.protocol,
            },
            channel: this.channel,
            paused,
            appData,
        });
        this.dataProducers.set(dataProducer.id, dataProducer);
        dataProducer.on('@close', () => {
            this.dataProducers.delete(dataProducer.id);
            this.emit('@dataproducerclose', dataProducer);
        });
        this.emit('@newdataproducer', dataProducer);
        // Emit observer event.
        this.#observer.safeEmit('newdataproducer', dataProducer);
        return dataProducer;
    }
    /**
     * Create a DataConsumer.
     */
    async consumeData({ dataProducerId, ordered, maxPacketLifeTime, maxRetransmits, paused = false, subchannels, appData, }) {
        logger.debug('consumeData()');
        if (!dataProducerId || typeof dataProducerId !== 'string') {
            throw new TypeError('missing dataProducerId');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        const dataProducer = this.getDataProducerById(dataProducerId);
        if (!dataProducer) {
            throw Error(`DataProducer with id "${dataProducerId}" not found`);
        }
        let type;
        let sctpStreamParameters;
        let sctpStreamId;
        // If this is not a DirectTransport, use sctpStreamParameters from the
        // DataProducer (if type 'sctp') unless they are given in method parameters.
        if (this.constructor.name !== 'DirectTransport') {
            type = 'sctp';
            sctpStreamParameters =
                utils.clone(dataProducer.sctpStreamParameters) ?? {};
            // Override if given.
            if (ordered !== undefined) {
                sctpStreamParameters.ordered = ordered;
            }
            if (maxPacketLifeTime !== undefined) {
                sctpStreamParameters.maxPacketLifeTime = maxPacketLifeTime;
            }
            if (maxRetransmits !== undefined) {
                sctpStreamParameters.maxRetransmits = maxRetransmits;
            }
            // This may throw.
            sctpStreamId = this.getNextSctpStreamId();
            this.#sctpStreamIds[sctpStreamId] = 1;
            sctpStreamParameters.streamId = sctpStreamId;
        }
        // If this is a DirectTransport, sctpStreamParameters must not be used.
        else {
            type = 'direct';
            if (ordered !== undefined ||
                maxPacketLifeTime !== undefined ||
                maxRetransmits !== undefined) {
                logger.warn('consumeData() | ordered, maxPacketLifeTime and maxRetransmits are ignored when consuming data on a DirectTransport');
            }
        }
        const { label, protocol } = dataProducer;
        const dataConsumerId = utils.generateUUIDv4();
        const requestOffset = createConsumeDataRequest({
            builder: this.channel.bufferBuilder,
            dataConsumerId,
            dataProducerId,
            type,
            sctpStreamParameters,
            label,
            protocol,
            paused,
            subchannels,
        });
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_CONSUME_DATA, FbsRequest.Body.Transport_ConsumeDataRequest, requestOffset, this.internal.transportId);
        /* Decode Response. */
        const consumeDataResponse = new FbsDataConsumer.DumpResponse();
        response.body(consumeDataResponse);
        const dump = (0, DataConsumer_1.parseDataConsumerDumpResponse)(consumeDataResponse);
        const dataConsumer = new DataConsumer_1.DataConsumer({
            internal: {
                ...this.internal,
                dataConsumerId,
            },
            data: {
                dataProducerId: dump.dataProducerId,
                type: dump.type,
                sctpStreamParameters: dump.sctpStreamParameters,
                label: dump.label,
                protocol: dump.protocol,
                bufferedAmountLowThreshold: dump.bufferedAmountLowThreshold,
            },
            channel: this.channel,
            paused: dump.paused,
            subchannels: dump.subchannels,
            dataProducerPaused: dump.dataProducerPaused,
            appData,
        });
        this.dataConsumers.set(dataConsumer.id, dataConsumer);
        dataConsumer.on('@close', () => {
            this.dataConsumers.delete(dataConsumer.id);
            if (this.#sctpStreamIds) {
                this.#sctpStreamIds[sctpStreamId] = 0;
            }
        });
        dataConsumer.on('@dataproducerclose', () => {
            this.dataConsumers.delete(dataConsumer.id);
            if (this.#sctpStreamIds) {
                this.#sctpStreamIds[sctpStreamId] = 0;
            }
        });
        // Emit observer event.
        this.#observer.safeEmit('newdataconsumer', dataConsumer);
        return dataConsumer;
    }
    /**
     * Enable 'trace' event.
     */
    async enableTraceEvent(types = []) {
        logger.debug('enableTraceEvent()');
        if (!Array.isArray(types)) {
            throw new TypeError('types must be an array');
        }
        else if (types.find(type => typeof type !== 'string')) {
            throw new TypeError('every type must be a string');
        }
        // Convert event types.
        const fbsEventTypes = [];
        for (const eventType of types) {
            try {
                fbsEventTypes.push(transportTraceEventTypeToFbs(eventType));
            }
            catch (error) {
                // Ignore invalid event types.
            }
        }
        /* Build Request. */
        const requestOffset = new FbsTransport.EnableTraceEventRequestT(fbsEventTypes).pack(this.channel.bufferBuilder);
        await this.channel.request(FbsRequest.Method.TRANSPORT_ENABLE_TRACE_EVENT, FbsRequest.Body.Transport_EnableTraceEventRequest, requestOffset, this.internal.transportId);
    }
    getNextSctpStreamId() {
        if (!this.#data.sctpParameters ||
            typeof this.#data.sctpParameters.MIS !== 'number') {
            throw new TypeError('missing sctpParameters.MIS');
        }
        const numStreams = this.#data.sctpParameters.MIS;
        if (!this.#sctpStreamIds) {
            this.#sctpStreamIds = Buffer.alloc(numStreams, 0);
        }
        let sctpStreamId;
        for (let idx = 0; idx < this.#sctpStreamIds.length; ++idx) {
            sctpStreamId =
                (this.#nextSctpStreamId + idx) % this.#sctpStreamIds.length;
            if (!this.#sctpStreamIds[sctpStreamId]) {
                this.#nextSctpStreamId = sctpStreamId + 1;
                return sctpStreamId;
            }
        }
        throw new Error('no sctpStreamId available');
    }
}
exports.Transport = Transport;
function transportTraceEventTypeToFbs(eventType) {
    switch (eventType) {
        case 'probation': {
            return FbsTransport.TraceEventType.PROBATION;
        }
        case 'bwe': {
            return FbsTransport.TraceEventType.BWE;
        }
        default: {
            throw new TypeError(`invalid TransportTraceEventType: ${eventType}`);
        }
    }
}
function transportTraceEventTypeFromFbs(eventType) {
    switch (eventType) {
        case FbsTransport.TraceEventType.PROBATION: {
            return 'probation';
        }
        case FbsTransport.TraceEventType.BWE: {
            return 'bwe';
        }
    }
}
function parseSctpState(fbsSctpState) {
    switch (fbsSctpState) {
        case sctp_state_1.SctpState.NEW: {
            return 'new';
        }
        case sctp_state_1.SctpState.CONNECTING: {
            return 'connecting';
        }
        case sctp_state_1.SctpState.CONNECTED: {
            return 'connected';
        }
        case sctp_state_1.SctpState.FAILED: {
            return 'failed';
        }
        case sctp_state_1.SctpState.CLOSED: {
            return 'closed';
        }
        default: {
            throw new TypeError(`invalid SctpState: ${fbsSctpState}`);
        }
    }
}
exports.parseSctpState = parseSctpState;
function parseProtocol(protocol) {
    switch (protocol) {
        case FbsTransport.Protocol.UDP: {
            return 'udp';
        }
        case FbsTransport.Protocol.TCP: {
            return 'tcp';
        }
    }
}
exports.parseProtocol = parseProtocol;
function serializeProtocol(protocol) {
    switch (protocol) {
        case 'udp': {
            return FbsTransport.Protocol.UDP;
        }
        case 'tcp': {
            return FbsTransport.Protocol.TCP;
        }
    }
}
exports.serializeProtocol = serializeProtocol;
function parseTuple(binary) {
    return {
        // @deprecated Use localAddress instead.
        localIp: binary.localAddress(),
        localAddress: binary.localAddress(),
        localPort: binary.localPort(),
        remoteIp: binary.remoteIp() ?? undefined,
        remotePort: binary.remotePort(),
        protocol: parseProtocol(binary.protocol()),
    };
}
exports.parseTuple = parseTuple;
function parseBaseTransportDump(binary) {
    // Retrieve producerIds.
    const producerIds = utils.parseVector(binary, 'producerIds');
    // Retrieve consumerIds.
    const consumerIds = utils.parseVector(binary, 'consumerIds');
    // Retrieve map SSRC consumerId.
    const mapSsrcConsumerId = utils.parseUint32StringVector(binary, 'mapSsrcConsumerId');
    // Retrieve map RTX SSRC consumerId.
    const mapRtxSsrcConsumerId = utils.parseUint32StringVector(binary, 'mapRtxSsrcConsumerId');
    // Retrieve dataProducerIds.
    const dataProducerIds = utils.parseVector(binary, 'dataProducerIds');
    // Retrieve dataConsumerIds.
    const dataConsumerIds = utils.parseVector(binary, 'dataConsumerIds');
    // Retrieve recvRtpHeaderExtesions.
    const recvRtpHeaderExtensions = parseRecvRtpHeaderExtensions(binary.recvRtpHeaderExtensions());
    // Retrieve RtpListener.
    const rtpListener = parseRtpListenerDump(binary.rtpListener());
    // Retrieve SctpParameters.
    const fbsSctpParameters = binary.sctpParameters();
    let sctpParameters;
    if (fbsSctpParameters) {
        sctpParameters = (0, SctpParameters_1.parseSctpParametersDump)(fbsSctpParameters);
    }
    // Retrieve sctpState.
    const sctpState = binary.sctpState() === null
        ? undefined
        : parseSctpState(binary.sctpState());
    // Retrive sctpListener.
    const sctpListener = binary.sctpListener()
        ? parseSctpListenerDump(binary.sctpListener())
        : undefined;
    // Retrieve traceEventTypes.
    const traceEventTypes = utils.parseVector(binary, 'traceEventTypes', transportTraceEventTypeFromFbs);
    return {
        id: binary.id(),
        direct: binary.direct(),
        producerIds: producerIds,
        consumerIds: consumerIds,
        mapSsrcConsumerId: mapSsrcConsumerId,
        mapRtxSsrcConsumerId: mapRtxSsrcConsumerId,
        dataProducerIds: dataProducerIds,
        dataConsumerIds: dataConsumerIds,
        recvRtpHeaderExtensions: recvRtpHeaderExtensions,
        rtpListener: rtpListener,
        maxMessageSize: binary.maxMessageSize(),
        sctpParameters: sctpParameters,
        sctpState: sctpState,
        sctpListener: sctpListener,
        traceEventTypes: traceEventTypes,
    };
}
exports.parseBaseTransportDump = parseBaseTransportDump;
function parseBaseTransportStats(binary) {
    const sctpState = binary.sctpState() === null
        ? undefined
        : parseSctpState(binary.sctpState());
    return {
        transportId: binary.transportId(),
        timestamp: Number(binary.timestamp()),
        sctpState,
        bytesReceived: Number(binary.bytesReceived()),
        recvBitrate: Number(binary.recvBitrate()),
        bytesSent: Number(binary.bytesSent()),
        sendBitrate: Number(binary.sendBitrate()),
        rtpBytesReceived: Number(binary.rtpBytesReceived()),
        rtpRecvBitrate: Number(binary.rtpRecvBitrate()),
        rtpBytesSent: Number(binary.rtpBytesSent()),
        rtpSendBitrate: Number(binary.rtpSendBitrate()),
        rtxBytesReceived: Number(binary.rtxBytesReceived()),
        rtxRecvBitrate: Number(binary.rtxRecvBitrate()),
        rtxBytesSent: Number(binary.rtxBytesSent()),
        rtxSendBitrate: Number(binary.rtxSendBitrate()),
        probationBytesSent: Number(binary.probationBytesSent()),
        probationSendBitrate: Number(binary.probationSendBitrate()),
        availableOutgoingBitrate: Number(binary.availableOutgoingBitrate()),
        availableIncomingBitrate: Number(binary.availableIncomingBitrate()),
        maxIncomingBitrate: binary.maxIncomingBitrate()
            ? Number(binary.maxIncomingBitrate())
            : undefined,
    };
}
exports.parseBaseTransportStats = parseBaseTransportStats;
function parseTransportTraceEventData(trace) {
    switch (trace.type()) {
        case FbsTransport.TraceEventType.BWE: {
            const info = new FbsTransport.BweTraceInfo();
            trace.info(info);
            return {
                type: 'bwe',
                timestamp: Number(trace.timestamp()),
                direction: trace.direction() === common_1.TraceDirection.DIRECTION_IN ? 'in' : 'out',
                info: parseBweTraceInfo(info),
            };
        }
        case FbsTransport.TraceEventType.PROBATION: {
            return {
                type: 'probation',
                timestamp: Number(trace.timestamp()),
                direction: trace.direction() === common_1.TraceDirection.DIRECTION_IN ? 'in' : 'out',
                info: {},
            };
        }
    }
}
exports.parseTransportTraceEventData = parseTransportTraceEventData;
function parseRecvRtpHeaderExtensions(binary) {
    return {
        mid: binary.mid() !== null ? binary.mid() : undefined,
        rid: binary.rid() !== null ? binary.rid() : undefined,
        rrid: binary.rrid() !== null ? binary.rrid() : undefined,
        absSendTime: binary.absSendTime() !== null ? binary.absSendTime() : undefined,
        transportWideCc01: binary.transportWideCc01() !== null
            ? binary.transportWideCc01()
            : undefined,
    };
}
function parseBweTraceInfo(binary) {
    return {
        desiredBitrate: binary.desiredBitrate(),
        effectiveDesiredBitrate: binary.effectiveDesiredBitrate(),
        minBitrate: binary.minBitrate(),
        maxBitrate: binary.maxBitrate(),
        startBitrate: binary.startBitrate(),
        maxPaddingBitrate: binary.maxPaddingBitrate(),
        availableBitrate: binary.availableBitrate(),
        bweType: binary.bweType() === FbsTransport.BweType.TRANSPORT_CC
            ? 'transport-cc'
            : 'remb',
    };
}
function createConsumeRequest({ builder, producer, consumerId, rtpParameters, paused, preferredLayers, ignoreDtx, pipe, }) {
    const rtpParametersOffset = (0, RtpParameters_1.serializeRtpParameters)(builder, rtpParameters);
    const consumerIdOffset = builder.createString(consumerId);
    const producerIdOffset = builder.createString(producer.id);
    let consumableRtpEncodingsOffset;
    let preferredLayersOffset;
    if (producer.consumableRtpParameters.encodings) {
        consumableRtpEncodingsOffset = (0, RtpParameters_1.serializeRtpEncodingParameters)(builder, producer.consumableRtpParameters.encodings);
    }
    if (preferredLayers) {
        FbsConsumer.ConsumerLayers.startConsumerLayers(builder);
        FbsConsumer.ConsumerLayers.addSpatialLayer(builder, preferredLayers.spatialLayer);
        if (preferredLayers.temporalLayer !== undefined) {
            FbsConsumer.ConsumerLayers.addTemporalLayer(builder, preferredLayers.temporalLayer);
        }
        preferredLayersOffset =
            FbsConsumer.ConsumerLayers.endConsumerLayers(builder);
    }
    const ConsumeRequest = FbsTransport.ConsumeRequest;
    // Create Consume Request.
    ConsumeRequest.startConsumeRequest(builder);
    ConsumeRequest.addConsumerId(builder, consumerIdOffset);
    ConsumeRequest.addProducerId(builder, producerIdOffset);
    ConsumeRequest.addKind(builder, producer.kind === 'audio' ? media_kind_1.MediaKind.AUDIO : media_kind_1.MediaKind.VIDEO);
    ConsumeRequest.addRtpParameters(builder, rtpParametersOffset);
    ConsumeRequest.addType(builder, pipe ? FbsRtpParameters.Type.PIPE : (0, Producer_1.producerTypeToFbs)(producer.type));
    if (consumableRtpEncodingsOffset) {
        ConsumeRequest.addConsumableRtpEncodings(builder, consumableRtpEncodingsOffset);
    }
    ConsumeRequest.addPaused(builder, paused);
    if (preferredLayersOffset) {
        ConsumeRequest.addPreferredLayers(builder, preferredLayersOffset);
    }
    ConsumeRequest.addIgnoreDtx(builder, Boolean(ignoreDtx));
    return ConsumeRequest.endConsumeRequest(builder);
}
function createProduceRequest({ builder, producerId, kind, rtpParameters, rtpMapping, keyFrameRequestDelay, paused, }) {
    const producerIdOffset = builder.createString(producerId);
    const rtpParametersOffset = (0, RtpParameters_1.serializeRtpParameters)(builder, rtpParameters);
    const rtpMappingOffset = ortc.serializeRtpMapping(builder, rtpMapping);
    FbsTransport.ProduceRequest.startProduceRequest(builder);
    FbsTransport.ProduceRequest.addProducerId(builder, producerIdOffset);
    FbsTransport.ProduceRequest.addKind(builder, kind === 'audio' ? media_kind_1.MediaKind.AUDIO : media_kind_1.MediaKind.VIDEO);
    FbsTransport.ProduceRequest.addRtpParameters(builder, rtpParametersOffset);
    FbsTransport.ProduceRequest.addRtpMapping(builder, rtpMappingOffset);
    FbsTransport.ProduceRequest.addKeyFrameRequestDelay(builder, keyFrameRequestDelay ?? 0);
    FbsTransport.ProduceRequest.addPaused(builder, paused);
    return FbsTransport.ProduceRequest.endProduceRequest(builder);
}
function createProduceDataRequest({ builder, dataProducerId, type, sctpStreamParameters, label, protocol, paused, }) {
    const dataProducerIdOffset = builder.createString(dataProducerId);
    const labelOffset = builder.createString(label);
    const protocolOffset = builder.createString(protocol);
    let sctpStreamParametersOffset = 0;
    if (sctpStreamParameters) {
        sctpStreamParametersOffset = (0, SctpParameters_1.serializeSctpStreamParameters)(builder, sctpStreamParameters);
    }
    FbsTransport.ProduceDataRequest.startProduceDataRequest(builder);
    FbsTransport.ProduceDataRequest.addDataProducerId(builder, dataProducerIdOffset);
    FbsTransport.ProduceDataRequest.addType(builder, (0, DataProducer_1.dataProducerTypeToFbs)(type));
    if (sctpStreamParametersOffset) {
        FbsTransport.ProduceDataRequest.addSctpStreamParameters(builder, sctpStreamParametersOffset);
    }
    FbsTransport.ProduceDataRequest.addLabel(builder, labelOffset);
    FbsTransport.ProduceDataRequest.addProtocol(builder, protocolOffset);
    FbsTransport.ProduceDataRequest.addPaused(builder, paused);
    return FbsTransport.ProduceDataRequest.endProduceDataRequest(builder);
}
function createConsumeDataRequest({ builder, dataConsumerId, dataProducerId, type, sctpStreamParameters, label, protocol, paused, subchannels = [], }) {
    const dataConsumerIdOffset = builder.createString(dataConsumerId);
    const dataProducerIdOffset = builder.createString(dataProducerId);
    const labelOffset = builder.createString(label);
    const protocolOffset = builder.createString(protocol);
    let sctpStreamParametersOffset = 0;
    if (sctpStreamParameters) {
        sctpStreamParametersOffset = (0, SctpParameters_1.serializeSctpStreamParameters)(builder, sctpStreamParameters);
    }
    const subchannelsOffset = FbsTransport.ConsumeDataRequest.createSubchannelsVector(builder, subchannels);
    FbsTransport.ConsumeDataRequest.startConsumeDataRequest(builder);
    FbsTransport.ConsumeDataRequest.addDataConsumerId(builder, dataConsumerIdOffset);
    FbsTransport.ConsumeDataRequest.addDataProducerId(builder, dataProducerIdOffset);
    FbsTransport.ConsumeDataRequest.addType(builder, (0, DataConsumer_1.dataConsumerTypeToFbs)(type));
    if (sctpStreamParametersOffset) {
        FbsTransport.ConsumeDataRequest.addSctpStreamParameters(builder, sctpStreamParametersOffset);
    }
    FbsTransport.ConsumeDataRequest.addLabel(builder, labelOffset);
    FbsTransport.ConsumeDataRequest.addProtocol(builder, protocolOffset);
    FbsTransport.ConsumeDataRequest.addPaused(builder, paused);
    FbsTransport.ConsumeDataRequest.addSubchannels(builder, subchannelsOffset);
    return FbsTransport.ConsumeDataRequest.endConsumeDataRequest(builder);
}
function parseRtpListenerDump(binary) {
    // Retrieve ssrcTable.
    const ssrcTable = utils.parseUint32StringVector(binary, 'ssrcTable');
    // Retrieve midTable.
    const midTable = utils.parseUint32StringVector(binary, 'midTable');
    // Retrieve ridTable.
    const ridTable = utils.parseUint32StringVector(binary, 'ridTable');
    return {
        ssrcTable,
        midTable,
        ridTable,
    };
}
function parseSctpListenerDump(binary) {
    // Retrieve streamIdTable.
    const streamIdTable = utils.parseUint32StringVector(binary, 'streamIdTable');
    return { streamIdTable };
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/WebRtcServer.js":
/*!*************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/WebRtcServer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebRtcServer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const request_1 = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsWorker = __webpack_require__(/*! ./fbs/worker */ "../../node_modules/mediasoup/node/lib/fbs/worker.js");
const FbsWebRtcServer = __webpack_require__(/*! ./fbs/web-rtc-server */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server.js");
const logger = new Logger_1.Logger('WebRtcServer');
class WebRtcServer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // Internal data.
    #internal;
    // Channel instance.
    #channel;
    // Closed flag.
    #closed = false;
    // Custom app data.
    #appData;
    // Transports map.
    #webRtcTransports = new Map();
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     */
    constructor({ internal, channel, appData, }) {
        super();
        logger.debug('constructor()');
        this.#internal = internal;
        this.#channel = channel;
        this.#appData = appData || {};
    }
    /**
     * WebRtcServer id.
     */
    get id() {
        return this.#internal.webRtcServerId;
    }
    /**
     * Whether the WebRtcServer is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * @private
     * Just for testing purposes.
     */
    get webRtcTransportsForTesting() {
        return this.#webRtcTransports;
    }
    /**
     * Close the WebRtcServer.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Build the request.
        const requestOffset = new FbsWorker.CloseWebRtcServerRequestT(this.#internal.webRtcServerId).pack(this.#channel.bufferBuilder);
        this.#channel
            .request(request_1.Method.WORKER_WEBRTCSERVER_CLOSE, request_1.Body.Worker_CloseWebRtcServerRequest, requestOffset)
            .catch(() => { });
        // Close every WebRtcTransport.
        for (const webRtcTransport of this.#webRtcTransports.values()) {
            webRtcTransport.listenServerClosed();
            // Emit observer event.
            this.#observer.safeEmit('webrtctransportunhandled', webRtcTransport);
        }
        this.#webRtcTransports.clear();
        this.emit('@close');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Worker was closed.
     *
     * @private
     */
    workerClosed() {
        if (this.#closed) {
            return;
        }
        logger.debug('workerClosed()');
        this.#closed = true;
        // NOTE: No need to close WebRtcTransports since they are closed by their
        // respective Router parents.
        this.#webRtcTransports.clear();
        this.safeEmit('workerclose');
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Dump WebRtcServer.
     */
    async dump() {
        logger.debug('dump()');
        const response = await this.#channel.request(request_1.Method.WEBRTCSERVER_DUMP, undefined, undefined, this.#internal.webRtcServerId);
        /* Decode Response. */
        const dump = new FbsWebRtcServer.DumpResponse();
        response.body(dump);
        return parseWebRtcServerDump(dump);
    }
    /**
     * @private
     */
    handleWebRtcTransport(webRtcTransport) {
        this.#webRtcTransports.set(webRtcTransport.id, webRtcTransport);
        // Emit observer event.
        this.#observer.safeEmit('webrtctransporthandled', webRtcTransport);
        webRtcTransport.on('@close', () => {
            this.#webRtcTransports.delete(webRtcTransport.id);
            // Emit observer event.
            this.#observer.safeEmit('webrtctransportunhandled', webRtcTransport);
        });
    }
}
exports.WebRtcServer = WebRtcServer;
function parseIpPort(binary) {
    return {
        ip: binary.ip(),
        port: binary.port(),
    };
}
function parseIceUserNameFragment(binary) {
    return {
        localIceUsernameFragment: binary.localIceUsernameFragment(),
        webRtcTransportId: binary.webRtcTransportId(),
    };
}
function parseTupleHash(binary) {
    return {
        tupleHash: Number(binary.tupleHash()),
        webRtcTransportId: binary.webRtcTransportId(),
    };
}
function parseWebRtcServerDump(data) {
    return {
        id: data.id(),
        udpSockets: utils.parseVector(data, 'udpSockets', parseIpPort),
        tcpServers: utils.parseVector(data, 'tcpServers', parseIpPort),
        webRtcTransportIds: utils.parseVector(data, 'webRtcTransportIds'),
        localIceUsernameFragments: utils.parseVector(data, 'localIceUsernameFragments', parseIceUserNameFragment),
        tupleHashes: utils.parseVector(data, 'tupleHashes', parseTupleHash),
    };
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/WebRtcTransport.js":
/*!****************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/WebRtcTransport.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseWebRtcTransportDumpResponse = exports.WebRtcTransport = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const Transport_1 = __webpack_require__(/*! ./Transport */ "../../node_modules/mediasoup/node/lib/Transport.js");
const utils_1 = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const FbsWebRtcTransport = __webpack_require__(/*! ./fbs/web-rtc-transport */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport.js");
const dtls_state_1 = __webpack_require__(/*! ./fbs/web-rtc-transport/dtls-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state.js");
const dtls_role_1 = __webpack_require__(/*! ./fbs/web-rtc-transport/dtls-role */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-role.js");
const fingerprint_algorithm_1 = __webpack_require__(/*! ./fbs/web-rtc-transport/fingerprint-algorithm */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint-algorithm.js");
const ice_state_1 = __webpack_require__(/*! ./fbs/web-rtc-transport/ice-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state.js");
const ice_role_1 = __webpack_require__(/*! ./fbs/web-rtc-transport/ice-role */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-role.js");
const ice_candidate_type_1 = __webpack_require__(/*! ./fbs/web-rtc-transport/ice-candidate-type */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-type.js");
const ice_candidate_tcp_type_1 = __webpack_require__(/*! ./fbs/web-rtc-transport/ice-candidate-tcp-type */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-tcp-type.js");
const logger = new Logger_1.Logger('WebRtcTransport');
class WebRtcTransport extends Transport_1.Transport {
    // WebRtcTransport data.
    #data;
    /**
     * @private
     */
    constructor(options) {
        super(options);
        logger.debug('constructor()');
        const { data } = options;
        this.#data = {
            iceRole: data.iceRole,
            iceParameters: data.iceParameters,
            iceCandidates: data.iceCandidates,
            iceState: data.iceState,
            iceSelectedTuple: data.iceSelectedTuple,
            dtlsParameters: data.dtlsParameters,
            dtlsState: data.dtlsState,
            dtlsRemoteCert: data.dtlsRemoteCert,
            sctpParameters: data.sctpParameters,
            sctpState: data.sctpState,
        };
        this.handleWorkerNotifications();
    }
    /**
     * ICE role.
     */
    get iceRole() {
        return this.#data.iceRole;
    }
    /**
     * ICE parameters.
     */
    get iceParameters() {
        return this.#data.iceParameters;
    }
    /**
     * ICE candidates.
     */
    get iceCandidates() {
        return this.#data.iceCandidates;
    }
    /**
     * ICE state.
     */
    get iceState() {
        return this.#data.iceState;
    }
    /**
     * ICE selected tuple.
     */
    get iceSelectedTuple() {
        return this.#data.iceSelectedTuple;
    }
    /**
     * DTLS parameters.
     */
    get dtlsParameters() {
        return this.#data.dtlsParameters;
    }
    /**
     * DTLS state.
     */
    get dtlsState() {
        return this.#data.dtlsState;
    }
    /**
     * Remote certificate in PEM format.
     */
    get dtlsRemoteCert() {
        return this.#data.dtlsRemoteCert;
    }
    /**
     * SCTP parameters.
     */
    get sctpParameters() {
        return this.#data.sctpParameters;
    }
    /**
     * SCTP state.
     */
    get sctpState() {
        return this.#data.sctpState;
    }
    /**
     * Close the WebRtcTransport.
     *
     * @override
     */
    close() {
        if (this.closed) {
            return;
        }
        this.#data.iceState = 'closed';
        this.#data.iceSelectedTuple = undefined;
        this.#data.dtlsState = 'closed';
        if (this.#data.sctpState) {
            this.#data.sctpState = 'closed';
        }
        super.close();
    }
    /**
     * Router was closed.
     *
     * @private
     * @override
     */
    routerClosed() {
        if (this.closed) {
            return;
        }
        this.#data.iceState = 'closed';
        this.#data.iceSelectedTuple = undefined;
        this.#data.dtlsState = 'closed';
        if (this.#data.sctpState) {
            this.#data.sctpState = 'closed';
        }
        super.routerClosed();
    }
    /**
     * Called when closing the associated listenServer (WebRtcServer).
     *
     * @private
     */
    listenServerClosed() {
        if (this.closed) {
            return;
        }
        this.#data.iceState = 'closed';
        this.#data.iceSelectedTuple = undefined;
        this.#data.dtlsState = 'closed';
        if (this.#data.sctpState) {
            this.#data.sctpState = 'closed';
        }
        super.listenServerClosed();
    }
    /**
     * Dump Transport.
     */
    async dump() {
        logger.debug('dump()');
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_DUMP, undefined, undefined, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsWebRtcTransport.DumpResponse();
        response.body(data);
        return parseWebRtcTransportDumpResponse(data);
    }
    /**
     * Get WebRtcTransport stats.
     *
     * @override
     */
    async getStats() {
        logger.debug('getStats()');
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_GET_STATS, undefined, undefined, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsWebRtcTransport.GetStatsResponse();
        response.body(data);
        return [parseGetStatsResponse(data)];
    }
    /**
     * Provide the WebRtcTransport remote parameters.
     *
     * @override
     */
    async connect({ dtlsParameters, }) {
        logger.debug('connect()');
        const requestOffset = createConnectRequest({
            builder: this.channel.bufferBuilder,
            dtlsParameters,
        });
        // Wait for response.
        const response = await this.channel.request(FbsRequest.Method.WEBRTCTRANSPORT_CONNECT, FbsRequest.Body.WebRtcTransport_ConnectRequest, requestOffset, this.internal.transportId);
        /* Decode Response. */
        const data = new FbsWebRtcTransport.ConnectResponse();
        response.body(data);
        // Update data.
        this.#data.dtlsParameters.role = dtlsRoleFromFbs(data.dtlsLocalRole());
    }
    /**
     * Restart ICE.
     */
    async restartIce() {
        logger.debug('restartIce()');
        const response = await this.channel.request(FbsRequest.Method.TRANSPORT_RESTART_ICE, undefined, undefined, this.internal.transportId);
        /* Decode Response. */
        const restartIceResponse = new FbsTransport.RestartIceResponse();
        response.body(restartIceResponse);
        const iceParameters = {
            usernameFragment: restartIceResponse.usernameFragment(),
            password: restartIceResponse.password(),
            iceLite: restartIceResponse.iceLite(),
        };
        this.#data.iceParameters = iceParameters;
        return iceParameters;
    }
    handleWorkerNotifications() {
        this.channel.on(this.internal.transportId, (event, data) => {
            switch (event) {
                case notification_1.Event.WEBRTCTRANSPORT_ICE_STATE_CHANGE: {
                    const notification = new FbsWebRtcTransport.IceStateChangeNotification();
                    data.body(notification);
                    const iceState = iceStateFromFbs(notification.iceState());
                    this.#data.iceState = iceState;
                    this.safeEmit('icestatechange', iceState);
                    // Emit observer event.
                    this.observer.safeEmit('icestatechange', iceState);
                    break;
                }
                case notification_1.Event.WEBRTCTRANSPORT_ICE_SELECTED_TUPLE_CHANGE: {
                    const notification = new FbsWebRtcTransport.IceSelectedTupleChangeNotification();
                    data.body(notification);
                    const iceSelectedTuple = (0, Transport_1.parseTuple)(notification.tuple());
                    this.#data.iceSelectedTuple = iceSelectedTuple;
                    this.safeEmit('iceselectedtuplechange', iceSelectedTuple);
                    // Emit observer event.
                    this.observer.safeEmit('iceselectedtuplechange', iceSelectedTuple);
                    break;
                }
                case notification_1.Event.WEBRTCTRANSPORT_DTLS_STATE_CHANGE: {
                    const notification = new FbsWebRtcTransport.DtlsStateChangeNotification();
                    data.body(notification);
                    const dtlsState = dtlsStateFromFbs(notification.dtlsState());
                    this.#data.dtlsState = dtlsState;
                    if (dtlsState === 'connected') {
                        this.#data.dtlsRemoteCert = notification.remoteCert();
                    }
                    this.safeEmit('dtlsstatechange', dtlsState);
                    // Emit observer event.
                    this.observer.safeEmit('dtlsstatechange', dtlsState);
                    break;
                }
                case notification_1.Event.TRANSPORT_SCTP_STATE_CHANGE: {
                    const notification = new FbsTransport.SctpStateChangeNotification();
                    data.body(notification);
                    const sctpState = (0, Transport_1.parseSctpState)(notification.sctpState());
                    this.#data.sctpState = sctpState;
                    this.safeEmit('sctpstatechange', sctpState);
                    // Emit observer event.
                    this.observer.safeEmit('sctpstatechange', sctpState);
                    break;
                }
                case notification_1.Event.TRANSPORT_TRACE: {
                    const notification = new FbsTransport.TraceNotification();
                    data.body(notification);
                    const trace = (0, Transport_1.parseTransportTraceEventData)(notification);
                    this.safeEmit('trace', trace);
                    // Emit observer event.
                    this.observer.safeEmit('trace', trace);
                    break;
                }
                default: {
                    logger.error('ignoring unknown event "%s"', event);
                }
            }
        });
    }
}
exports.WebRtcTransport = WebRtcTransport;
function iceStateFromFbs(fbsIceState) {
    switch (fbsIceState) {
        case ice_state_1.IceState.NEW: {
            return 'new';
        }
        case ice_state_1.IceState.CONNECTED: {
            return 'connected';
        }
        case ice_state_1.IceState.COMPLETED: {
            return 'completed';
        }
        case ice_state_1.IceState.DISCONNECTED: {
            return 'disconnected';
        }
    }
}
function iceRoleFromFbs(role) {
    switch (role) {
        case ice_role_1.IceRole.CONTROLLED: {
            return 'controlled';
        }
        case ice_role_1.IceRole.CONTROLLING: {
            return 'controlling';
        }
    }
}
function iceCandidateTypeFromFbs(type) {
    switch (type) {
        case ice_candidate_type_1.IceCandidateType.HOST: {
            return 'host';
        }
    }
}
function iceCandidateTcpTypeFromFbs(type) {
    switch (type) {
        case ice_candidate_tcp_type_1.IceCandidateTcpType.PASSIVE: {
            return 'passive';
        }
    }
}
function dtlsStateFromFbs(fbsDtlsState) {
    switch (fbsDtlsState) {
        case dtls_state_1.DtlsState.NEW: {
            return 'new';
        }
        case dtls_state_1.DtlsState.CONNECTING: {
            return 'connecting';
        }
        case dtls_state_1.DtlsState.CONNECTED: {
            return 'connected';
        }
        case dtls_state_1.DtlsState.FAILED: {
            return 'failed';
        }
        case dtls_state_1.DtlsState.CLOSED: {
            return 'closed';
        }
    }
}
function dtlsRoleFromFbs(role) {
    switch (role) {
        case dtls_role_1.DtlsRole.AUTO: {
            return 'auto';
        }
        case dtls_role_1.DtlsRole.CLIENT: {
            return 'client';
        }
        case dtls_role_1.DtlsRole.SERVER: {
            return 'server';
        }
    }
}
function fingerprintAlgorithmsFromFbs(algorithm) {
    switch (algorithm) {
        case fingerprint_algorithm_1.FingerprintAlgorithm.SHA1: {
            return 'sha-1';
        }
        case fingerprint_algorithm_1.FingerprintAlgorithm.SHA224: {
            return 'sha-224';
        }
        case fingerprint_algorithm_1.FingerprintAlgorithm.SHA256: {
            return 'sha-256';
        }
        case fingerprint_algorithm_1.FingerprintAlgorithm.SHA384: {
            return 'sha-384';
        }
        case fingerprint_algorithm_1.FingerprintAlgorithm.SHA512: {
            return 'sha-512';
        }
    }
}
function fingerprintAlgorithmToFbs(algorithm) {
    switch (algorithm) {
        case 'sha-1': {
            return fingerprint_algorithm_1.FingerprintAlgorithm.SHA1;
        }
        case 'sha-224': {
            return fingerprint_algorithm_1.FingerprintAlgorithm.SHA224;
        }
        case 'sha-256': {
            return fingerprint_algorithm_1.FingerprintAlgorithm.SHA256;
        }
        case 'sha-384': {
            return fingerprint_algorithm_1.FingerprintAlgorithm.SHA384;
        }
        case 'sha-512': {
            return fingerprint_algorithm_1.FingerprintAlgorithm.SHA512;
        }
        default: {
            throw new TypeError(`invalid FingerprintAlgorithm: ${algorithm}`);
        }
    }
}
function dtlsRoleToFbs(role) {
    switch (role) {
        case 'auto': {
            return dtls_role_1.DtlsRole.AUTO;
        }
        case 'client': {
            return dtls_role_1.DtlsRole.CLIENT;
        }
        case 'server': {
            return dtls_role_1.DtlsRole.SERVER;
        }
        default: {
            throw new TypeError(`invalid DtlsRole: ${role}`);
        }
    }
}
function parseWebRtcTransportDumpResponse(binary) {
    // Retrieve BaseTransportDump.
    const baseTransportDump = (0, Transport_1.parseBaseTransportDump)(binary.base());
    // Retrieve ICE candidates.
    const iceCandidates = (0, utils_1.parseVector)(binary, 'iceCandidates', parseIceCandidate);
    // Retrieve ICE parameters.
    const iceParameters = parseIceParameters(binary.iceParameters());
    // Retrieve DTLS parameters.
    const dtlsParameters = parseDtlsParameters(binary.dtlsParameters());
    return {
        ...baseTransportDump,
        sctpParameters: baseTransportDump.sctpParameters,
        sctpState: baseTransportDump.sctpState,
        iceRole: 'controlled',
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        iceState: iceStateFromFbs(binary.iceState()),
        dtlsParameters: dtlsParameters,
        dtlsState: dtlsStateFromFbs(binary.dtlsState()),
    };
}
exports.parseWebRtcTransportDumpResponse = parseWebRtcTransportDumpResponse;
function createConnectRequest({ builder, dtlsParameters, }) {
    // Serialize DtlsParameters. This can throw.
    const dtlsParametersOffset = serializeDtlsParameters(builder, dtlsParameters);
    // Create request.
    return FbsWebRtcTransport.ConnectRequest.createConnectRequest(builder, dtlsParametersOffset);
}
function parseGetStatsResponse(binary) {
    const base = (0, Transport_1.parseBaseTransportStats)(binary.base());
    return {
        ...base,
        type: 'webrtc-transport',
        iceRole: iceRoleFromFbs(binary.iceRole()),
        iceState: iceStateFromFbs(binary.iceState()),
        iceSelectedTuple: binary.iceSelectedTuple()
            ? (0, Transport_1.parseTuple)(binary.iceSelectedTuple())
            : undefined,
        dtlsState: dtlsStateFromFbs(binary.dtlsState()),
    };
}
function parseIceCandidate(binary) {
    return {
        foundation: binary.foundation(),
        priority: binary.priority(),
        ip: binary.address(),
        address: binary.address(),
        protocol: (0, Transport_1.parseProtocol)(binary.protocol()),
        port: binary.port(),
        type: iceCandidateTypeFromFbs(binary.type()),
        tcpType: binary.tcpType() === null
            ? undefined
            : iceCandidateTcpTypeFromFbs(binary.tcpType()),
    };
}
function parseIceParameters(binary) {
    return {
        usernameFragment: binary.usernameFragment(),
        password: binary.password(),
        iceLite: binary.iceLite(),
    };
}
function parseDtlsParameters(binary) {
    const fingerprints = [];
    for (let i = 0; i < binary.fingerprintsLength(); ++i) {
        const fbsFingerprint = binary.fingerprints(i);
        const fingerPrint = {
            algorithm: fingerprintAlgorithmsFromFbs(fbsFingerprint.algorithm()),
            value: fbsFingerprint.value(),
        };
        fingerprints.push(fingerPrint);
    }
    return {
        fingerprints: fingerprints,
        role: binary.role() === null ? undefined : dtlsRoleFromFbs(binary.role()),
    };
}
function serializeDtlsParameters(builder, dtlsParameters) {
    const fingerprints = [];
    for (const fingerprint of dtlsParameters.fingerprints) {
        const algorithm = fingerprintAlgorithmToFbs(fingerprint.algorithm);
        const valueOffset = builder.createString(fingerprint.value);
        const fingerprintOffset = FbsWebRtcTransport.Fingerprint.createFingerprint(builder, algorithm, valueOffset);
        fingerprints.push(fingerprintOffset);
    }
    const fingerprintsOffset = FbsWebRtcTransport.DtlsParameters.createFingerprintsVector(builder, fingerprints);
    const role = dtlsParameters.role !== undefined
        ? dtlsRoleToFbs(dtlsParameters.role)
        : FbsWebRtcTransport.DtlsRole.AUTO;
    return FbsWebRtcTransport.DtlsParameters.createDtlsParameters(builder, fingerprintsOffset, role);
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/Worker.js":
/*!*******************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/Worker.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseWorkerDumpResponse = exports.Worker = exports.workerBin = void 0;
const process = __webpack_require__(/*! node:process */ "node:process");
const path = __webpack_require__(/*! node:path */ "node:path");
const node_child_process_1 = __webpack_require__(/*! node:child_process */ "node:child_process");
const _1 = __webpack_require__(/*! ./ */ "../../node_modules/mediasoup/node/lib/index.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const ortc = __webpack_require__(/*! ./ortc */ "../../node_modules/mediasoup/node/lib/ortc.js");
const Channel_1 = __webpack_require__(/*! ./Channel */ "../../node_modules/mediasoup/node/lib/Channel.js");
const Router_1 = __webpack_require__(/*! ./Router */ "../../node_modules/mediasoup/node/lib/Router.js");
const WebRtcServer_1 = __webpack_require__(/*! ./WebRtcServer */ "../../node_modules/mediasoup/node/lib/WebRtcServer.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const notification_1 = __webpack_require__(/*! ./fbs/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification.js");
const FbsRequest = __webpack_require__(/*! ./fbs/request */ "../../node_modules/mediasoup/node/lib/fbs/request.js");
const FbsWorker = __webpack_require__(/*! ./fbs/worker */ "../../node_modules/mediasoup/node/lib/fbs/worker.js");
const FbsTransport = __webpack_require__(/*! ./fbs/transport */ "../../node_modules/mediasoup/node/lib/fbs/transport.js");
const protocol_1 = __webpack_require__(/*! ./fbs/transport/protocol */ "../../node_modules/mediasoup/node/lib/fbs/transport/protocol.js");
// If env MEDIASOUP_WORKER_BIN is given, use it as worker binary.
// Otherwise if env MEDIASOUP_BUILDTYPE is 'Debug' use the Debug binary.
// Otherwise use the Release binary.
exports.workerBin = process.env.MEDIASOUP_WORKER_BIN
    ? process.env.MEDIASOUP_WORKER_BIN
    : process.env.MEDIASOUP_BUILDTYPE === 'Debug'
        ? path.join(__dirname, '..', '..', 'worker', 'out', 'Debug', 'mediasoup-worker')
        : path.join(__dirname, '..', '..', 'worker', 'out', 'Release', 'mediasoup-worker');
const logger = new Logger_1.Logger('Worker');
const workerLogger = new Logger_1.Logger('Worker');
class Worker extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    // mediasoup-worker child process.
    #child;
    // Worker process PID.
    #pid;
    // Channel instance.
    #channel;
    // Closed flag.
    #closed = false;
    // Died dlag.
    #died = false;
    // Worker subprocess closed flag.
    #subprocessClosed = false;
    // Custom app data.
    #appData;
    // WebRtcServers set.
    #webRtcServers = new Set();
    // Routers set.
    #routers = new Set();
    // Observer instance.
    #observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    /**
     * @private
     */
    constructor({ logLevel, logTags, rtcMinPort, rtcMaxPort, dtlsCertificateFile, dtlsPrivateKeyFile, libwebrtcFieldTrials, appData, }) {
        super();
        logger.debug('constructor()');
        let spawnBin = exports.workerBin;
        let spawnArgs = [];
        if (process.env.MEDIASOUP_USE_VALGRIND === 'true') {
            spawnBin = process.env.MEDIASOUP_VALGRIND_BIN || 'valgrind';
            if (process.env.MEDIASOUP_VALGRIND_OPTIONS) {
                spawnArgs = spawnArgs.concat(process.env.MEDIASOUP_VALGRIND_OPTIONS.split(/\s+/));
            }
            spawnArgs.push(exports.workerBin);
        }
        if (typeof logLevel === 'string' && logLevel) {
            spawnArgs.push(`--logLevel=${logLevel}`);
        }
        for (const logTag of Array.isArray(logTags) ? logTags : []) {
            if (typeof logTag === 'string' && logTag) {
                spawnArgs.push(`--logTag=${logTag}`);
            }
        }
        if (typeof rtcMinPort === 'number' && !Number.isNaN(rtcMinPort)) {
            spawnArgs.push(`--rtcMinPort=${rtcMinPort}`);
        }
        if (typeof rtcMaxPort === 'number' && !Number.isNaN(rtcMaxPort)) {
            spawnArgs.push(`--rtcMaxPort=${rtcMaxPort}`);
        }
        if (typeof dtlsCertificateFile === 'string' && dtlsCertificateFile) {
            spawnArgs.push(`--dtlsCertificateFile=${dtlsCertificateFile}`);
        }
        if (typeof dtlsPrivateKeyFile === 'string' && dtlsPrivateKeyFile) {
            spawnArgs.push(`--dtlsPrivateKeyFile=${dtlsPrivateKeyFile}`);
        }
        if (typeof libwebrtcFieldTrials === 'string' && libwebrtcFieldTrials) {
            spawnArgs.push(`--libwebrtcFieldTrials=${libwebrtcFieldTrials}`);
        }
        logger.debug('spawning worker process: %s %s', spawnBin, spawnArgs.join(' '));
        this.#child = (0, node_child_process_1.spawn)(
        // command
        spawnBin, 
        // args
        spawnArgs, 
        // options
        {
            env: {
                MEDIASOUP_VERSION: _1.version,
                // Let the worker process inherit all environment variables, useful
                // if a custom and not in the path GCC is used so the user can set
                // LD_LIBRARY_PATH environment variable for runtime.
                ...process.env,
            },
            detached: false,
            // fd 0 (stdin)   : Just ignore it.
            // fd 1 (stdout)  : Pipe it for 3rd libraries that log their own stuff.
            // fd 2 (stderr)  : Same as stdout.
            // fd 3 (channel) : Producer Channel fd.
            // fd 4 (channel) : Consumer Channel fd.
            stdio: ['ignore', 'pipe', 'pipe', 'pipe', 'pipe'],
            windowsHide: true,
        });
        this.#pid = this.#child.pid;
        this.#channel = new Channel_1.Channel({
            producerSocket: this.#child.stdio[3],
            consumerSocket: this.#child.stdio[4],
            pid: this.#pid,
        });
        this.#appData = appData || {};
        let spawnDone = false;
        // Listen for 'running' notification.
        this.#channel.once(String(this.#pid), (event) => {
            if (!spawnDone && event === notification_1.Event.WORKER_RUNNING) {
                spawnDone = true;
                logger.debug('worker process running [pid:%s]', this.#pid);
                this.emit('@success');
            }
        });
        this.#child.on('exit', (code, signal) => {
            // If killed by ourselves, do nothing.
            if (this.#child.killed) {
                return;
            }
            if (!spawnDone) {
                spawnDone = true;
                if (code === 42) {
                    logger.error('worker process failed due to wrong settings [pid:%s]', this.#pid);
                    this.close();
                    this.emit('@failure', new TypeError('wrong settings'));
                }
                else {
                    logger.error('worker process failed unexpectedly [pid:%s, code:%s, signal:%s]', this.#pid, code, signal);
                    this.close();
                    this.emit('@failure', new Error(`[pid:${this.#pid}, code:${code}, signal:${signal}]`));
                }
            }
            else {
                logger.error('worker process died unexpectedly [pid:%s, code:%s, signal:%s]', this.#pid, code, signal);
                this.workerDied(new Error(`[pid:${this.#pid}, code:${code}, signal:${signal}]`));
            }
        });
        this.#child.on('error', error => {
            // If killed by ourselves, do nothing.
            if (this.#child.killed) {
                return;
            }
            if (!spawnDone) {
                spawnDone = true;
                logger.error('worker process failed [pid:%s]: %s', this.#pid, error.message);
                this.close();
                this.emit('@failure', error);
            }
            else {
                logger.error('worker process error [pid:%s]: %s', this.#pid, error.message);
                this.workerDied(error);
            }
        });
        this.#child.on('close', (code, signal) => {
            logger.debug('worker subprocess closed [pid:%s, code:%s, signal:%s]', this.#pid, code, signal);
            this.#subprocessClosed = true;
            this.safeEmit('subprocessclose');
        });
        // Be ready for 3rd party worker libraries logging to stdout.
        this.#child.stdout.on('data', buffer => {
            for (const line of buffer.toString('utf8').split('\n')) {
                if (line) {
                    workerLogger.debug(`(stdout) ${line}`);
                }
            }
        });
        // In case of a worker bug, mediasoup will log to stderr.
        this.#child.stderr.on('data', buffer => {
            for (const line of buffer.toString('utf8').split('\n')) {
                if (line) {
                    workerLogger.error(`(stderr) ${line}`);
                }
            }
        });
    }
    /**
     * Worker process identifier (PID).
     */
    get pid() {
        return this.#pid;
    }
    /**
     * Whether the Worker is closed.
     */
    get closed() {
        return this.#closed;
    }
    /**
     * Whether the Worker died.
     */
    get died() {
        return this.#died;
    }
    /**
     * Whether the Worker subprocess is closed.
     */
    get subprocessClosed() {
        return this.#subprocessClosed;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this.#appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this.#appData = appData;
    }
    /**
     * Observer.
     */
    get observer() {
        return this.#observer;
    }
    /**
     * @private
     * Just for testing purposes.
     */
    get webRtcServersForTesting() {
        return this.#webRtcServers;
    }
    /**
     * @private
     * Just for testing purposes.
     */
    get routersForTesting() {
        return this.#routers;
    }
    /**
     * Close the Worker.
     */
    close() {
        if (this.#closed) {
            return;
        }
        logger.debug('close()');
        this.#closed = true;
        // Kill the worker process.
        this.#child.kill('SIGTERM');
        // Close the Channel instance.
        this.#channel.close();
        // Close every Router.
        for (const router of this.#routers) {
            router.workerClosed();
        }
        this.#routers.clear();
        // Close every WebRtcServer.
        for (const webRtcServer of this.#webRtcServers) {
            webRtcServer.workerClosed();
        }
        this.#webRtcServers.clear();
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
    /**
     * Dump Worker.
     */
    async dump() {
        logger.debug('dump()');
        // Send the request and wait for the response.
        const response = await this.#channel.request(FbsRequest.Method.WORKER_DUMP);
        /* Decode Response. */
        const dump = new FbsWorker.DumpResponse();
        response.body(dump);
        return parseWorkerDumpResponse(dump);
    }
    /**
     * Get mediasoup-worker process resource usage.
     */
    async getResourceUsage() {
        logger.debug('getResourceUsage()');
        const response = await this.#channel.request(FbsRequest.Method.WORKER_GET_RESOURCE_USAGE);
        /* Decode Response. */
        const resourceUsage = new FbsWorker.ResourceUsageResponse();
        response.body(resourceUsage);
        const ru = resourceUsage.unpack();
        /* eslint-disable camelcase */
        return {
            ru_utime: Number(ru.ruUtime),
            ru_stime: Number(ru.ruStime),
            ru_maxrss: Number(ru.ruMaxrss),
            ru_ixrss: Number(ru.ruIxrss),
            ru_idrss: Number(ru.ruIdrss),
            ru_isrss: Number(ru.ruIsrss),
            ru_minflt: Number(ru.ruMinflt),
            ru_majflt: Number(ru.ruMajflt),
            ru_nswap: Number(ru.ruNswap),
            ru_inblock: Number(ru.ruInblock),
            ru_oublock: Number(ru.ruOublock),
            ru_msgsnd: Number(ru.ruMsgsnd),
            ru_msgrcv: Number(ru.ruMsgrcv),
            ru_nsignals: Number(ru.ruNsignals),
            ru_nvcsw: Number(ru.ruNvcsw),
            ru_nivcsw: Number(ru.ruNivcsw),
        };
        /* eslint-enable camelcase */
    }
    /**
     * Update settings.
     */
    async updateSettings({ logLevel, logTags, } = {}) {
        logger.debug('updateSettings()');
        // Build the request.
        const requestOffset = new FbsWorker.UpdateSettingsRequestT(logLevel, logTags).pack(this.#channel.bufferBuilder);
        await this.#channel.request(FbsRequest.Method.WORKER_UPDATE_SETTINGS, FbsRequest.Body.Worker_UpdateSettingsRequest, requestOffset);
    }
    /**
     * Create a WebRtcServer.
     */
    async createWebRtcServer({ listenInfos, appData, }) {
        logger.debug('createWebRtcServer()');
        if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Build the request.
        const fbsListenInfos = [];
        for (const listenInfo of listenInfos) {
            fbsListenInfos.push(new FbsTransport.ListenInfoT(listenInfo.protocol === 'udp'
                ? protocol_1.Protocol.UDP
                : protocol_1.Protocol.TCP, listenInfo.ip, listenInfo.announcedAddress ?? listenInfo.announcedIp, listenInfo.port, (0, Router_1.socketFlagsToFbs)(listenInfo.flags), listenInfo.sendBufferSize, listenInfo.recvBufferSize));
        }
        const webRtcServerId = utils.generateUUIDv4();
        const createWebRtcServerRequestOffset = new FbsWorker.CreateWebRtcServerRequestT(webRtcServerId, fbsListenInfos).pack(this.#channel.bufferBuilder);
        await this.#channel.request(FbsRequest.Method.WORKER_CREATE_WEBRTCSERVER, FbsRequest.Body.Worker_CreateWebRtcServerRequest, createWebRtcServerRequestOffset);
        const webRtcServer = new WebRtcServer_1.WebRtcServer({
            internal: { webRtcServerId },
            channel: this.#channel,
            appData,
        });
        this.#webRtcServers.add(webRtcServer);
        webRtcServer.on('@close', () => this.#webRtcServers.delete(webRtcServer));
        // Emit observer event.
        this.#observer.safeEmit('newwebrtcserver', webRtcServer);
        return webRtcServer;
    }
    /**
     * Create a Router.
     */
    async createRouter({ mediaCodecs, appData, } = {}) {
        logger.debug('createRouter()');
        if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Clone given media codecs to not modify input data.
        const clonedMediaCodecs = utils.clone(mediaCodecs);
        // This may throw.
        const rtpCapabilities = ortc.generateRouterRtpCapabilities(clonedMediaCodecs);
        const routerId = utils.generateUUIDv4();
        // Get flatbuffer builder.
        const createRouterRequestOffset = new FbsWorker.CreateRouterRequestT(routerId).pack(this.#channel.bufferBuilder);
        await this.#channel.request(FbsRequest.Method.WORKER_CREATE_ROUTER, FbsRequest.Body.Worker_CreateRouterRequest, createRouterRequestOffset);
        const data = { rtpCapabilities };
        const router = new Router_1.Router({
            internal: {
                routerId,
            },
            data,
            channel: this.#channel,
            appData,
        });
        this.#routers.add(router);
        router.on('@close', () => this.#routers.delete(router));
        // Emit observer event.
        this.#observer.safeEmit('newrouter', router);
        return router;
    }
    workerDied(error) {
        if (this.#closed) {
            return;
        }
        logger.debug(`died() [error:${error}]`);
        this.#closed = true;
        this.#died = true;
        // Close the Channel instance.
        this.#channel.close();
        // Close every Router.
        for (const router of this.#routers) {
            router.workerClosed();
        }
        this.#routers.clear();
        // Close every WebRtcServer.
        for (const webRtcServer of this.#webRtcServers) {
            webRtcServer.workerClosed();
        }
        this.#webRtcServers.clear();
        this.safeEmit('died', error);
        // Emit observer event.
        this.#observer.safeEmit('close');
    }
}
exports.Worker = Worker;
function parseWorkerDumpResponse(binary) {
    const dump = {
        pid: binary.pid(),
        webRtcServerIds: utils.parseVector(binary, 'webRtcServerIds'),
        routerIds: utils.parseVector(binary, 'routerIds'),
        channelMessageHandlers: {
            channelRequestHandlers: utils.parseVector(binary.channelMessageHandlers(), 'channelRequestHandlers'),
            channelNotificationHandlers: utils.parseVector(binary.channelMessageHandlers(), 'channelNotificationHandlers'),
        },
    };
    if (binary.liburing()) {
        dump.liburing = {
            sqeProcessCount: Number(binary.liburing().sqeProcessCount()),
            sqeMissCount: Number(binary.liburing().sqeMissCount()),
            userDataMissCount: Number(binary.liburing().userDataMissCount()),
        };
    }
    return dump;
}
exports.parseWorkerDumpResponse = parseWorkerDumpResponse;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/errors.js":
/*!*******************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */
class UnsupportedError extends Error {
    constructor(message) {
        super(message);
        this.name = 'UnsupportedError';
        if (Error.hasOwnProperty('captureStackTrace')) {
            // Just in V8.
            Error.captureStackTrace(this, UnsupportedError);
        }
        else {
            this.stack = new Error(message).stack;
        }
    }
}
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */
class InvalidStateError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InvalidStateError';
        if (Error.hasOwnProperty('captureStackTrace')) {
            // Just in V8.
            Error.captureStackTrace(this, InvalidStateError);
        }
        else {
            this.stack = new Error(message).stack;
        }
    }
}
exports.InvalidStateError = InvalidStateError;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DominantSpeakerNotificationT = exports.DominantSpeakerNotification = exports.ActiveSpeakerObserverOptionsT = exports.ActiveSpeakerObserverOptions = void 0;
var active_speaker_observer_options_1 = __webpack_require__(/*! ./active-speaker-observer/active-speaker-observer-options */ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer/active-speaker-observer-options.js");
Object.defineProperty(exports, "ActiveSpeakerObserverOptions", ({ enumerable: true, get: function () { return active_speaker_observer_options_1.ActiveSpeakerObserverOptions; } }));
Object.defineProperty(exports, "ActiveSpeakerObserverOptionsT", ({ enumerable: true, get: function () { return active_speaker_observer_options_1.ActiveSpeakerObserverOptionsT; } }));
var dominant_speaker_notification_1 = __webpack_require__(/*! ./active-speaker-observer/dominant-speaker-notification */ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer/dominant-speaker-notification.js");
Object.defineProperty(exports, "DominantSpeakerNotification", ({ enumerable: true, get: function () { return dominant_speaker_notification_1.DominantSpeakerNotification; } }));
Object.defineProperty(exports, "DominantSpeakerNotificationT", ({ enumerable: true, get: function () { return dominant_speaker_notification_1.DominantSpeakerNotificationT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer/active-speaker-observer-options.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer/active-speaker-observer-options.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveSpeakerObserverOptionsT = exports.ActiveSpeakerObserverOptions = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class ActiveSpeakerObserverOptions {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsActiveSpeakerObserverOptions(bb, obj) {
        return (obj || new ActiveSpeakerObserverOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsActiveSpeakerObserverOptions(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ActiveSpeakerObserverOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    interval() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    static startActiveSpeakerObserverOptions(builder) {
        builder.startObject(1);
    }
    static addInterval(builder, interval) {
        builder.addFieldInt16(0, interval, 0);
    }
    static endActiveSpeakerObserverOptions(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createActiveSpeakerObserverOptions(builder, interval) {
        ActiveSpeakerObserverOptions.startActiveSpeakerObserverOptions(builder);
        ActiveSpeakerObserverOptions.addInterval(builder, interval);
        return ActiveSpeakerObserverOptions.endActiveSpeakerObserverOptions(builder);
    }
    unpack() {
        return new ActiveSpeakerObserverOptionsT(this.interval());
    }
    unpackTo(_o) {
        _o.interval = this.interval();
    }
}
exports.ActiveSpeakerObserverOptions = ActiveSpeakerObserverOptions;
class ActiveSpeakerObserverOptionsT {
    interval;
    constructor(interval = 0) {
        this.interval = interval;
    }
    pack(builder) {
        return ActiveSpeakerObserverOptions.createActiveSpeakerObserverOptions(builder, this.interval);
    }
}
exports.ActiveSpeakerObserverOptionsT = ActiveSpeakerObserverOptionsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer/dominant-speaker-notification.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer/dominant-speaker-notification.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DominantSpeakerNotificationT = exports.DominantSpeakerNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class DominantSpeakerNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDominantSpeakerNotification(bb, obj) {
        return (obj || new DominantSpeakerNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDominantSpeakerNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DominantSpeakerNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    producerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startDominantSpeakerNotification(builder) {
        builder.startObject(1);
    }
    static addProducerId(builder, producerIdOffset) {
        builder.addFieldOffset(0, producerIdOffset, 0);
    }
    static endDominantSpeakerNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // producer_id
        return offset;
    }
    static createDominantSpeakerNotification(builder, producerIdOffset) {
        DominantSpeakerNotification.startDominantSpeakerNotification(builder);
        DominantSpeakerNotification.addProducerId(builder, producerIdOffset);
        return DominantSpeakerNotification.endDominantSpeakerNotification(builder);
    }
    unpack() {
        return new DominantSpeakerNotificationT(this.producerId());
    }
    unpackTo(_o) {
        _o.producerId = this.producerId();
    }
}
exports.DominantSpeakerNotification = DominantSpeakerNotification;
class DominantSpeakerNotificationT {
    producerId;
    constructor(producerId = null) {
        this.producerId = producerId;
    }
    pack(builder) {
        const producerId = (this.producerId !== null ? builder.createString(this.producerId) : 0);
        return DominantSpeakerNotification.createDominantSpeakerNotification(builder, producerId);
    }
}
exports.DominantSpeakerNotificationT = DominantSpeakerNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/audio-level-observer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VolumesNotificationT = exports.VolumesNotification = exports.VolumeT = exports.Volume = exports.AudioLevelObserverOptionsT = exports.AudioLevelObserverOptions = void 0;
var audio_level_observer_options_1 = __webpack_require__(/*! ./audio-level-observer/audio-level-observer-options */ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/audio-level-observer-options.js");
Object.defineProperty(exports, "AudioLevelObserverOptions", ({ enumerable: true, get: function () { return audio_level_observer_options_1.AudioLevelObserverOptions; } }));
Object.defineProperty(exports, "AudioLevelObserverOptionsT", ({ enumerable: true, get: function () { return audio_level_observer_options_1.AudioLevelObserverOptionsT; } }));
var volume_1 = __webpack_require__(/*! ./audio-level-observer/volume */ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/volume.js");
Object.defineProperty(exports, "Volume", ({ enumerable: true, get: function () { return volume_1.Volume; } }));
Object.defineProperty(exports, "VolumeT", ({ enumerable: true, get: function () { return volume_1.VolumeT; } }));
var volumes_notification_1 = __webpack_require__(/*! ./audio-level-observer/volumes-notification */ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/volumes-notification.js");
Object.defineProperty(exports, "VolumesNotification", ({ enumerable: true, get: function () { return volumes_notification_1.VolumesNotification; } }));
Object.defineProperty(exports, "VolumesNotificationT", ({ enumerable: true, get: function () { return volumes_notification_1.VolumesNotificationT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/audio-level-observer-options.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/audio-level-observer-options.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioLevelObserverOptionsT = exports.AudioLevelObserverOptions = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class AudioLevelObserverOptions {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsAudioLevelObserverOptions(bb, obj) {
        return (obj || new AudioLevelObserverOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsAudioLevelObserverOptions(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new AudioLevelObserverOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    maxEntries() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    threshold() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
    }
    interval() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    static startAudioLevelObserverOptions(builder) {
        builder.startObject(3);
    }
    static addMaxEntries(builder, maxEntries) {
        builder.addFieldInt16(0, maxEntries, 0);
    }
    static addThreshold(builder, threshold) {
        builder.addFieldInt8(1, threshold, 0);
    }
    static addInterval(builder, interval) {
        builder.addFieldInt16(2, interval, 0);
    }
    static endAudioLevelObserverOptions(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createAudioLevelObserverOptions(builder, maxEntries, threshold, interval) {
        AudioLevelObserverOptions.startAudioLevelObserverOptions(builder);
        AudioLevelObserverOptions.addMaxEntries(builder, maxEntries);
        AudioLevelObserverOptions.addThreshold(builder, threshold);
        AudioLevelObserverOptions.addInterval(builder, interval);
        return AudioLevelObserverOptions.endAudioLevelObserverOptions(builder);
    }
    unpack() {
        return new AudioLevelObserverOptionsT(this.maxEntries(), this.threshold(), this.interval());
    }
    unpackTo(_o) {
        _o.maxEntries = this.maxEntries();
        _o.threshold = this.threshold();
        _o.interval = this.interval();
    }
}
exports.AudioLevelObserverOptions = AudioLevelObserverOptions;
class AudioLevelObserverOptionsT {
    maxEntries;
    threshold;
    interval;
    constructor(maxEntries = 0, threshold = 0, interval = 0) {
        this.maxEntries = maxEntries;
        this.threshold = threshold;
        this.interval = interval;
    }
    pack(builder) {
        return AudioLevelObserverOptions.createAudioLevelObserverOptions(builder, this.maxEntries, this.threshold, this.interval);
    }
}
exports.AudioLevelObserverOptionsT = AudioLevelObserverOptionsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/volume.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/volume.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VolumeT = exports.Volume = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Volume {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsVolume(bb, obj) {
        return (obj || new Volume()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsVolume(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Volume()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    producerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    volume() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : 0;
    }
    static startVolume(builder) {
        builder.startObject(2);
    }
    static addProducerId(builder, producerIdOffset) {
        builder.addFieldOffset(0, producerIdOffset, 0);
    }
    static addVolume(builder, volume) {
        builder.addFieldInt8(1, volume, 0);
    }
    static endVolume(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // producer_id
        return offset;
    }
    static createVolume(builder, producerIdOffset, volume) {
        Volume.startVolume(builder);
        Volume.addProducerId(builder, producerIdOffset);
        Volume.addVolume(builder, volume);
        return Volume.endVolume(builder);
    }
    unpack() {
        return new VolumeT(this.producerId(), this.volume());
    }
    unpackTo(_o) {
        _o.producerId = this.producerId();
        _o.volume = this.volume();
    }
}
exports.Volume = Volume;
class VolumeT {
    producerId;
    volume;
    constructor(producerId = null, volume = 0) {
        this.producerId = producerId;
        this.volume = volume;
    }
    pack(builder) {
        const producerId = (this.producerId !== null ? builder.createString(this.producerId) : 0);
        return Volume.createVolume(builder, producerId, this.volume);
    }
}
exports.VolumeT = VolumeT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/volumes-notification.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/volumes-notification.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VolumesNotificationT = exports.VolumesNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const volume_1 = __webpack_require__(/*! ../../fbs/audio-level-observer/volume */ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/volume.js");
class VolumesNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsVolumesNotification(bb, obj) {
        return (obj || new VolumesNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsVolumesNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new VolumesNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    volumes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new volume_1.Volume()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    volumesLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startVolumesNotification(builder) {
        builder.startObject(1);
    }
    static addVolumes(builder, volumesOffset) {
        builder.addFieldOffset(0, volumesOffset, 0);
    }
    static createVolumesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startVolumesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endVolumesNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // volumes
        return offset;
    }
    static createVolumesNotification(builder, volumesOffset) {
        VolumesNotification.startVolumesNotification(builder);
        VolumesNotification.addVolumes(builder, volumesOffset);
        return VolumesNotification.endVolumesNotification(builder);
    }
    unpack() {
        return new VolumesNotificationT(this.bb.createObjList(this.volumes.bind(this), this.volumesLength()));
    }
    unpackTo(_o) {
        _o.volumes = this.bb.createObjList(this.volumes.bind(this), this.volumesLength());
    }
}
exports.VolumesNotification = VolumesNotification;
class VolumesNotificationT {
    volumes;
    constructor(volumes = []) {
        this.volumes = volumes;
    }
    pack(builder) {
        const volumes = VolumesNotification.createVolumesVector(builder, builder.createObjectOffsetList(this.volumes));
        return VolumesNotification.createVolumesNotification(builder, volumes);
    }
}
exports.VolumesNotificationT = VolumesNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/common.js":
/*!***********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/common.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uint32StringT = exports.Uint32String = exports.Uint16StringT = exports.Uint16String = exports.TraceDirection = exports.StringUint8T = exports.StringUint8 = exports.StringStringArrayT = exports.StringStringArray = exports.StringStringT = exports.StringString = void 0;
var string_string_1 = __webpack_require__(/*! ./common/string-string */ "../../node_modules/mediasoup/node/lib/fbs/common/string-string.js");
Object.defineProperty(exports, "StringString", ({ enumerable: true, get: function () { return string_string_1.StringString; } }));
Object.defineProperty(exports, "StringStringT", ({ enumerable: true, get: function () { return string_string_1.StringStringT; } }));
var string_string_array_1 = __webpack_require__(/*! ./common/string-string-array */ "../../node_modules/mediasoup/node/lib/fbs/common/string-string-array.js");
Object.defineProperty(exports, "StringStringArray", ({ enumerable: true, get: function () { return string_string_array_1.StringStringArray; } }));
Object.defineProperty(exports, "StringStringArrayT", ({ enumerable: true, get: function () { return string_string_array_1.StringStringArrayT; } }));
var string_uint8_1 = __webpack_require__(/*! ./common/string-uint8 */ "../../node_modules/mediasoup/node/lib/fbs/common/string-uint8.js");
Object.defineProperty(exports, "StringUint8", ({ enumerable: true, get: function () { return string_uint8_1.StringUint8; } }));
Object.defineProperty(exports, "StringUint8T", ({ enumerable: true, get: function () { return string_uint8_1.StringUint8T; } }));
var trace_direction_1 = __webpack_require__(/*! ./common/trace-direction */ "../../node_modules/mediasoup/node/lib/fbs/common/trace-direction.js");
Object.defineProperty(exports, "TraceDirection", ({ enumerable: true, get: function () { return trace_direction_1.TraceDirection; } }));
var uint16_string_1 = __webpack_require__(/*! ./common/uint16-string */ "../../node_modules/mediasoup/node/lib/fbs/common/uint16-string.js");
Object.defineProperty(exports, "Uint16String", ({ enumerable: true, get: function () { return uint16_string_1.Uint16String; } }));
Object.defineProperty(exports, "Uint16StringT", ({ enumerable: true, get: function () { return uint16_string_1.Uint16StringT; } }));
var uint32_string_1 = __webpack_require__(/*! ./common/uint32-string */ "../../node_modules/mediasoup/node/lib/fbs/common/uint32-string.js");
Object.defineProperty(exports, "Uint32String", ({ enumerable: true, get: function () { return uint32_string_1.Uint32String; } }));
Object.defineProperty(exports, "Uint32StringT", ({ enumerable: true, get: function () { return uint32_string_1.Uint32StringT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/common/string-string-array.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/common/string-string-array.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringStringArrayT = exports.StringStringArray = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class StringStringArray {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStringStringArray(bb, obj) {
        return (obj || new StringStringArray()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStringStringArray(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new StringStringArray()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    values(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    valuesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startStringStringArray(builder) {
        builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
        builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValues(builder, valuesOffset) {
        builder.addFieldOffset(1, valuesOffset, 0);
    }
    static createValuesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startValuesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endStringStringArray(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // key
        builder.requiredField(offset, 6); // values
        return offset;
    }
    static createStringStringArray(builder, keyOffset, valuesOffset) {
        StringStringArray.startStringStringArray(builder);
        StringStringArray.addKey(builder, keyOffset);
        StringStringArray.addValues(builder, valuesOffset);
        return StringStringArray.endStringStringArray(builder);
    }
    unpack() {
        return new StringStringArrayT(this.key(), this.bb.createScalarList(this.values.bind(this), this.valuesLength()));
    }
    unpackTo(_o) {
        _o.key = this.key();
        _o.values = this.bb.createScalarList(this.values.bind(this), this.valuesLength());
    }
}
exports.StringStringArray = StringStringArray;
class StringStringArrayT {
    key;
    values;
    constructor(key = null, values = []) {
        this.key = key;
        this.values = values;
    }
    pack(builder) {
        const key = (this.key !== null ? builder.createString(this.key) : 0);
        const values = StringStringArray.createValuesVector(builder, builder.createObjectOffsetList(this.values));
        return StringStringArray.createStringStringArray(builder, key, values);
    }
}
exports.StringStringArrayT = StringStringArrayT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/common/string-string.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/common/string-string.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringStringT = exports.StringString = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class StringString {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStringString(bb, obj) {
        return (obj || new StringString()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStringString(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new StringString()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startStringString(builder) {
        builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
        builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
    }
    static endStringString(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // key
        builder.requiredField(offset, 6); // value
        return offset;
    }
    static createStringString(builder, keyOffset, valueOffset) {
        StringString.startStringString(builder);
        StringString.addKey(builder, keyOffset);
        StringString.addValue(builder, valueOffset);
        return StringString.endStringString(builder);
    }
    unpack() {
        return new StringStringT(this.key(), this.value());
    }
    unpackTo(_o) {
        _o.key = this.key();
        _o.value = this.value();
    }
}
exports.StringString = StringString;
class StringStringT {
    key;
    value;
    constructor(key = null, value = null) {
        this.key = key;
        this.value = value;
    }
    pack(builder) {
        const key = (this.key !== null ? builder.createString(this.key) : 0);
        const value = (this.value !== null ? builder.createString(this.value) : 0);
        return StringString.createStringString(builder, key, value);
    }
}
exports.StringStringT = StringStringT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/common/string-uint8.js":
/*!************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/common/string-uint8.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringUint8T = exports.StringUint8 = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class StringUint8 {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStringUint8(bb, obj) {
        return (obj || new StringUint8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStringUint8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new StringUint8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startStringUint8(builder) {
        builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
        builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, value) {
        builder.addFieldInt8(1, value, 0);
    }
    static endStringUint8(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // key
        return offset;
    }
    static createStringUint8(builder, keyOffset, value) {
        StringUint8.startStringUint8(builder);
        StringUint8.addKey(builder, keyOffset);
        StringUint8.addValue(builder, value);
        return StringUint8.endStringUint8(builder);
    }
    unpack() {
        return new StringUint8T(this.key(), this.value());
    }
    unpackTo(_o) {
        _o.key = this.key();
        _o.value = this.value();
    }
}
exports.StringUint8 = StringUint8;
class StringUint8T {
    key;
    value;
    constructor(key = null, value = 0) {
        this.key = key;
        this.value = value;
    }
    pack(builder) {
        const key = (this.key !== null ? builder.createString(this.key) : 0);
        return StringUint8.createStringUint8(builder, key, this.value);
    }
}
exports.StringUint8T = StringUint8T;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/common/trace-direction.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/common/trace-direction.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceDirection = void 0;
var TraceDirection;
(function (TraceDirection) {
    TraceDirection[TraceDirection["DIRECTION_IN"] = 0] = "DIRECTION_IN";
    TraceDirection[TraceDirection["DIRECTION_OUT"] = 1] = "DIRECTION_OUT";
})(TraceDirection || (exports.TraceDirection = TraceDirection = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/common/uint16-string.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/common/uint16-string.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uint16StringT = exports.Uint16String = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Uint16String {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUint16String(bb, obj) {
        return (obj || new Uint16String()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUint16String(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Uint16String()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startUint16String(builder) {
        builder.startObject(2);
    }
    static addKey(builder, key) {
        builder.addFieldInt16(0, key, 0);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
    }
    static endUint16String(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // value
        return offset;
    }
    static createUint16String(builder, key, valueOffset) {
        Uint16String.startUint16String(builder);
        Uint16String.addKey(builder, key);
        Uint16String.addValue(builder, valueOffset);
        return Uint16String.endUint16String(builder);
    }
    unpack() {
        return new Uint16StringT(this.key(), this.value());
    }
    unpackTo(_o) {
        _o.key = this.key();
        _o.value = this.value();
    }
}
exports.Uint16String = Uint16String;
class Uint16StringT {
    key;
    value;
    constructor(key = 0, value = null) {
        this.key = key;
        this.value = value;
    }
    pack(builder) {
        const value = (this.value !== null ? builder.createString(this.value) : 0);
        return Uint16String.createUint16String(builder, this.key, value);
    }
}
exports.Uint16StringT = Uint16StringT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/common/uint32-string.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/common/uint32-string.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uint32StringT = exports.Uint32String = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Uint32String {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUint32String(bb, obj) {
        return (obj || new Uint32String()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUint32String(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Uint32String()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startUint32String(builder) {
        builder.startObject(2);
    }
    static addKey(builder, key) {
        builder.addFieldInt32(0, key, 0);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
    }
    static endUint32String(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // value
        return offset;
    }
    static createUint32String(builder, key, valueOffset) {
        Uint32String.startUint32String(builder);
        Uint32String.addKey(builder, key);
        Uint32String.addValue(builder, valueOffset);
        return Uint32String.endUint32String(builder);
    }
    unpack() {
        return new Uint32StringT(this.key(), this.value());
    }
    unpackTo(_o) {
        _o.key = this.key();
        _o.value = this.value();
    }
}
exports.Uint32String = Uint32String;
class Uint32StringT {
    key;
    value;
    constructor(key = 0, value = null) {
        this.key = key;
        this.value = value;
    }
    pack(builder) {
        const value = (this.value !== null ? builder.createString(this.value) : 0);
        return Uint32String.createUint32String(builder, this.key, value);
    }
}
exports.Uint32StringT = Uint32StringT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer.js":
/*!*************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceNotificationT = exports.TraceNotification = exports.TraceInfo = exports.TraceEventType = exports.SetPriorityResponseT = exports.SetPriorityResponse = exports.SetPriorityRequestT = exports.SetPriorityRequest = exports.SetPreferredLayersResponseT = exports.SetPreferredLayersResponse = exports.SetPreferredLayersRequestT = exports.SetPreferredLayersRequest = exports.ScoreNotificationT = exports.ScoreNotification = exports.RtpTraceInfoT = exports.RtpTraceInfo = exports.RtpNotificationT = exports.RtpNotification = exports.PliTraceInfoT = exports.PliTraceInfo = exports.LayersChangeNotificationT = exports.LayersChangeNotification = exports.KeyFrameTraceInfoT = exports.KeyFrameTraceInfo = exports.GetStatsResponseT = exports.GetStatsResponse = exports.FirTraceInfoT = exports.FirTraceInfo = exports.EnableTraceEventRequestT = exports.EnableTraceEventRequest = exports.DumpResponseT = exports.DumpResponse = exports.ConsumerScoreT = exports.ConsumerScore = exports.ConsumerLayersT = exports.ConsumerLayers = exports.ConsumerDumpT = exports.ConsumerDump = exports.BaseConsumerDumpT = exports.BaseConsumerDump = void 0;
var base_consumer_dump_1 = __webpack_require__(/*! ./consumer/base-consumer-dump */ "../../node_modules/mediasoup/node/lib/fbs/consumer/base-consumer-dump.js");
Object.defineProperty(exports, "BaseConsumerDump", ({ enumerable: true, get: function () { return base_consumer_dump_1.BaseConsumerDump; } }));
Object.defineProperty(exports, "BaseConsumerDumpT", ({ enumerable: true, get: function () { return base_consumer_dump_1.BaseConsumerDumpT; } }));
var consumer_dump_1 = __webpack_require__(/*! ./consumer/consumer-dump */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-dump.js");
Object.defineProperty(exports, "ConsumerDump", ({ enumerable: true, get: function () { return consumer_dump_1.ConsumerDump; } }));
Object.defineProperty(exports, "ConsumerDumpT", ({ enumerable: true, get: function () { return consumer_dump_1.ConsumerDumpT; } }));
var consumer_layers_1 = __webpack_require__(/*! ./consumer/consumer-layers */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-layers.js");
Object.defineProperty(exports, "ConsumerLayers", ({ enumerable: true, get: function () { return consumer_layers_1.ConsumerLayers; } }));
Object.defineProperty(exports, "ConsumerLayersT", ({ enumerable: true, get: function () { return consumer_layers_1.ConsumerLayersT; } }));
var consumer_score_1 = __webpack_require__(/*! ./consumer/consumer-score */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-score.js");
Object.defineProperty(exports, "ConsumerScore", ({ enumerable: true, get: function () { return consumer_score_1.ConsumerScore; } }));
Object.defineProperty(exports, "ConsumerScoreT", ({ enumerable: true, get: function () { return consumer_score_1.ConsumerScoreT; } }));
var dump_response_1 = __webpack_require__(/*! ./consumer/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/consumer/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var enable_trace_event_request_1 = __webpack_require__(/*! ./consumer/enable-trace-event-request */ "../../node_modules/mediasoup/node/lib/fbs/consumer/enable-trace-event-request.js");
Object.defineProperty(exports, "EnableTraceEventRequest", ({ enumerable: true, get: function () { return enable_trace_event_request_1.EnableTraceEventRequest; } }));
Object.defineProperty(exports, "EnableTraceEventRequestT", ({ enumerable: true, get: function () { return enable_trace_event_request_1.EnableTraceEventRequestT; } }));
var fir_trace_info_1 = __webpack_require__(/*! ./consumer/fir-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/fir-trace-info.js");
Object.defineProperty(exports, "FirTraceInfo", ({ enumerable: true, get: function () { return fir_trace_info_1.FirTraceInfo; } }));
Object.defineProperty(exports, "FirTraceInfoT", ({ enumerable: true, get: function () { return fir_trace_info_1.FirTraceInfoT; } }));
var get_stats_response_1 = __webpack_require__(/*! ./consumer/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/consumer/get-stats-response.js");
Object.defineProperty(exports, "GetStatsResponse", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponse; } }));
Object.defineProperty(exports, "GetStatsResponseT", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponseT; } }));
var key_frame_trace_info_1 = __webpack_require__(/*! ./consumer/key-frame-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/key-frame-trace-info.js");
Object.defineProperty(exports, "KeyFrameTraceInfo", ({ enumerable: true, get: function () { return key_frame_trace_info_1.KeyFrameTraceInfo; } }));
Object.defineProperty(exports, "KeyFrameTraceInfoT", ({ enumerable: true, get: function () { return key_frame_trace_info_1.KeyFrameTraceInfoT; } }));
var layers_change_notification_1 = __webpack_require__(/*! ./consumer/layers-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/consumer/layers-change-notification.js");
Object.defineProperty(exports, "LayersChangeNotification", ({ enumerable: true, get: function () { return layers_change_notification_1.LayersChangeNotification; } }));
Object.defineProperty(exports, "LayersChangeNotificationT", ({ enumerable: true, get: function () { return layers_change_notification_1.LayersChangeNotificationT; } }));
var pli_trace_info_1 = __webpack_require__(/*! ./consumer/pli-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/pli-trace-info.js");
Object.defineProperty(exports, "PliTraceInfo", ({ enumerable: true, get: function () { return pli_trace_info_1.PliTraceInfo; } }));
Object.defineProperty(exports, "PliTraceInfoT", ({ enumerable: true, get: function () { return pli_trace_info_1.PliTraceInfoT; } }));
var rtp_notification_1 = __webpack_require__(/*! ./consumer/rtp-notification */ "../../node_modules/mediasoup/node/lib/fbs/consumer/rtp-notification.js");
Object.defineProperty(exports, "RtpNotification", ({ enumerable: true, get: function () { return rtp_notification_1.RtpNotification; } }));
Object.defineProperty(exports, "RtpNotificationT", ({ enumerable: true, get: function () { return rtp_notification_1.RtpNotificationT; } }));
var rtp_trace_info_1 = __webpack_require__(/*! ./consumer/rtp-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/rtp-trace-info.js");
Object.defineProperty(exports, "RtpTraceInfo", ({ enumerable: true, get: function () { return rtp_trace_info_1.RtpTraceInfo; } }));
Object.defineProperty(exports, "RtpTraceInfoT", ({ enumerable: true, get: function () { return rtp_trace_info_1.RtpTraceInfoT; } }));
var score_notification_1 = __webpack_require__(/*! ./consumer/score-notification */ "../../node_modules/mediasoup/node/lib/fbs/consumer/score-notification.js");
Object.defineProperty(exports, "ScoreNotification", ({ enumerable: true, get: function () { return score_notification_1.ScoreNotification; } }));
Object.defineProperty(exports, "ScoreNotificationT", ({ enumerable: true, get: function () { return score_notification_1.ScoreNotificationT; } }));
var set_preferred_layers_request_1 = __webpack_require__(/*! ./consumer/set-preferred-layers-request */ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-preferred-layers-request.js");
Object.defineProperty(exports, "SetPreferredLayersRequest", ({ enumerable: true, get: function () { return set_preferred_layers_request_1.SetPreferredLayersRequest; } }));
Object.defineProperty(exports, "SetPreferredLayersRequestT", ({ enumerable: true, get: function () { return set_preferred_layers_request_1.SetPreferredLayersRequestT; } }));
var set_preferred_layers_response_1 = __webpack_require__(/*! ./consumer/set-preferred-layers-response */ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-preferred-layers-response.js");
Object.defineProperty(exports, "SetPreferredLayersResponse", ({ enumerable: true, get: function () { return set_preferred_layers_response_1.SetPreferredLayersResponse; } }));
Object.defineProperty(exports, "SetPreferredLayersResponseT", ({ enumerable: true, get: function () { return set_preferred_layers_response_1.SetPreferredLayersResponseT; } }));
var set_priority_request_1 = __webpack_require__(/*! ./consumer/set-priority-request */ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-priority-request.js");
Object.defineProperty(exports, "SetPriorityRequest", ({ enumerable: true, get: function () { return set_priority_request_1.SetPriorityRequest; } }));
Object.defineProperty(exports, "SetPriorityRequestT", ({ enumerable: true, get: function () { return set_priority_request_1.SetPriorityRequestT; } }));
var set_priority_response_1 = __webpack_require__(/*! ./consumer/set-priority-response */ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-priority-response.js");
Object.defineProperty(exports, "SetPriorityResponse", ({ enumerable: true, get: function () { return set_priority_response_1.SetPriorityResponse; } }));
Object.defineProperty(exports, "SetPriorityResponseT", ({ enumerable: true, get: function () { return set_priority_response_1.SetPriorityResponseT; } }));
var trace_event_type_1 = __webpack_require__(/*! ./consumer/trace-event-type */ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-event-type.js");
Object.defineProperty(exports, "TraceEventType", ({ enumerable: true, get: function () { return trace_event_type_1.TraceEventType; } }));
var trace_info_1 = __webpack_require__(/*! ./consumer/trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-info.js");
Object.defineProperty(exports, "TraceInfo", ({ enumerable: true, get: function () { return trace_info_1.TraceInfo; } }));
var trace_notification_1 = __webpack_require__(/*! ./consumer/trace-notification */ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-notification.js");
Object.defineProperty(exports, "TraceNotification", ({ enumerable: true, get: function () { return trace_notification_1.TraceNotification; } }));
Object.defineProperty(exports, "TraceNotificationT", ({ enumerable: true, get: function () { return trace_notification_1.TraceNotificationT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/base-consumer-dump.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/base-consumer-dump.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseConsumerDumpT = exports.BaseConsumerDump = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const media_kind_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/media-kind */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js");
const rtp_encoding_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-encoding-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-encoding-parameters.js");
const rtp_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-parameters.js");
const type_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/type */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/type.js");
class BaseConsumerDump {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBaseConsumerDump(bb, obj) {
        return (obj || new BaseConsumerDump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBaseConsumerDump(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BaseConsumerDump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_1.Type.SIMPLE;
    }
    producerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    kind() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : media_kind_1.MediaKind.AUDIO;
    }
    rtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new rtp_parameters_1.RtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    consumableRtpEncodings(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new rtp_encoding_parameters_1.RtpEncodingParameters()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    consumableRtpEncodingsLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    supportedCodecPayloadTypes(index) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    supportedCodecPayloadTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    supportedCodecPayloadTypesArray() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    traceEventTypes(index) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    traceEventTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    traceEventTypesArray() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    producerPaused() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    priority() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startBaseConsumerDump(builder) {
        builder.startObject(11);
    }
    static addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    }
    static addType(builder, type) {
        builder.addFieldInt8(1, type, type_1.Type.SIMPLE);
    }
    static addProducerId(builder, producerIdOffset) {
        builder.addFieldOffset(2, producerIdOffset, 0);
    }
    static addKind(builder, kind) {
        builder.addFieldInt8(3, kind, media_kind_1.MediaKind.AUDIO);
    }
    static addRtpParameters(builder, rtpParametersOffset) {
        builder.addFieldOffset(4, rtpParametersOffset, 0);
    }
    static addConsumableRtpEncodings(builder, consumableRtpEncodingsOffset) {
        builder.addFieldOffset(5, consumableRtpEncodingsOffset, 0);
    }
    static createConsumableRtpEncodingsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startConsumableRtpEncodingsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addSupportedCodecPayloadTypes(builder, supportedCodecPayloadTypesOffset) {
        builder.addFieldOffset(6, supportedCodecPayloadTypesOffset, 0);
    }
    static createSupportedCodecPayloadTypesVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startSupportedCodecPayloadTypesVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addTraceEventTypes(builder, traceEventTypesOffset) {
        builder.addFieldOffset(7, traceEventTypesOffset, 0);
    }
    static createTraceEventTypesVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startTraceEventTypesVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(8, +paused, +false);
    }
    static addProducerPaused(builder, producerPaused) {
        builder.addFieldInt8(9, +producerPaused, +false);
    }
    static addPriority(builder, priority) {
        builder.addFieldInt8(10, priority, 0);
    }
    static endBaseConsumerDump(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // id
        builder.requiredField(offset, 8); // producer_id
        builder.requiredField(offset, 12); // rtp_parameters
        builder.requiredField(offset, 14); // consumable_rtp_encodings
        builder.requiredField(offset, 16); // supported_codec_payload_types
        builder.requiredField(offset, 18); // trace_event_types
        return offset;
    }
    unpack() {
        return new BaseConsumerDumpT(this.id(), this.type(), this.producerId(), this.kind(), (this.rtpParameters() !== null ? this.rtpParameters().unpack() : null), this.bb.createObjList(this.consumableRtpEncodings.bind(this), this.consumableRtpEncodingsLength()), this.bb.createScalarList(this.supportedCodecPayloadTypes.bind(this), this.supportedCodecPayloadTypesLength()), this.bb.createScalarList(this.traceEventTypes.bind(this), this.traceEventTypesLength()), this.paused(), this.producerPaused(), this.priority());
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.type = this.type();
        _o.producerId = this.producerId();
        _o.kind = this.kind();
        _o.rtpParameters = (this.rtpParameters() !== null ? this.rtpParameters().unpack() : null);
        _o.consumableRtpEncodings = this.bb.createObjList(this.consumableRtpEncodings.bind(this), this.consumableRtpEncodingsLength());
        _o.supportedCodecPayloadTypes = this.bb.createScalarList(this.supportedCodecPayloadTypes.bind(this), this.supportedCodecPayloadTypesLength());
        _o.traceEventTypes = this.bb.createScalarList(this.traceEventTypes.bind(this), this.traceEventTypesLength());
        _o.paused = this.paused();
        _o.producerPaused = this.producerPaused();
        _o.priority = this.priority();
    }
}
exports.BaseConsumerDump = BaseConsumerDump;
class BaseConsumerDumpT {
    id;
    type;
    producerId;
    kind;
    rtpParameters;
    consumableRtpEncodings;
    supportedCodecPayloadTypes;
    traceEventTypes;
    paused;
    producerPaused;
    priority;
    constructor(id = null, type = type_1.Type.SIMPLE, producerId = null, kind = media_kind_1.MediaKind.AUDIO, rtpParameters = null, consumableRtpEncodings = [], supportedCodecPayloadTypes = [], traceEventTypes = [], paused = false, producerPaused = false, priority = 0) {
        this.id = id;
        this.type = type;
        this.producerId = producerId;
        this.kind = kind;
        this.rtpParameters = rtpParameters;
        this.consumableRtpEncodings = consumableRtpEncodings;
        this.supportedCodecPayloadTypes = supportedCodecPayloadTypes;
        this.traceEventTypes = traceEventTypes;
        this.paused = paused;
        this.producerPaused = producerPaused;
        this.priority = priority;
    }
    pack(builder) {
        const id = (this.id !== null ? builder.createString(this.id) : 0);
        const producerId = (this.producerId !== null ? builder.createString(this.producerId) : 0);
        const rtpParameters = (this.rtpParameters !== null ? this.rtpParameters.pack(builder) : 0);
        const consumableRtpEncodings = BaseConsumerDump.createConsumableRtpEncodingsVector(builder, builder.createObjectOffsetList(this.consumableRtpEncodings));
        const supportedCodecPayloadTypes = BaseConsumerDump.createSupportedCodecPayloadTypesVector(builder, this.supportedCodecPayloadTypes);
        const traceEventTypes = BaseConsumerDump.createTraceEventTypesVector(builder, this.traceEventTypes);
        BaseConsumerDump.startBaseConsumerDump(builder);
        BaseConsumerDump.addId(builder, id);
        BaseConsumerDump.addType(builder, this.type);
        BaseConsumerDump.addProducerId(builder, producerId);
        BaseConsumerDump.addKind(builder, this.kind);
        BaseConsumerDump.addRtpParameters(builder, rtpParameters);
        BaseConsumerDump.addConsumableRtpEncodings(builder, consumableRtpEncodings);
        BaseConsumerDump.addSupportedCodecPayloadTypes(builder, supportedCodecPayloadTypes);
        BaseConsumerDump.addTraceEventTypes(builder, traceEventTypes);
        BaseConsumerDump.addPaused(builder, this.paused);
        BaseConsumerDump.addProducerPaused(builder, this.producerPaused);
        BaseConsumerDump.addPriority(builder, this.priority);
        return BaseConsumerDump.endBaseConsumerDump(builder);
    }
}
exports.BaseConsumerDumpT = BaseConsumerDumpT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-dump.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-dump.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsumerDumpT = exports.ConsumerDump = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const base_consumer_dump_1 = __webpack_require__(/*! ../../fbs/consumer/base-consumer-dump */ "../../node_modules/mediasoup/node/lib/fbs/consumer/base-consumer-dump.js");
const dump_1 = __webpack_require__(/*! ../../fbs/rtp-stream/dump */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/dump.js");
class ConsumerDump {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConsumerDump(bb, obj) {
        return (obj || new ConsumerDump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConsumerDump(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConsumerDump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new base_consumer_dump_1.BaseConsumerDump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtpStreams(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    rtpStreamsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    preferredSpatialLayer() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : null;
    }
    targetSpatialLayer() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : null;
    }
    currentSpatialLayer() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : null;
    }
    preferredTemporalLayer() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : null;
    }
    targetTemporalLayer() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : null;
    }
    currentTemporalLayer() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : null;
    }
    static startConsumerDump(builder) {
        builder.startObject(8);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addRtpStreams(builder, rtpStreamsOffset) {
        builder.addFieldOffset(1, rtpStreamsOffset, 0);
    }
    static createRtpStreamsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRtpStreamsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addPreferredSpatialLayer(builder, preferredSpatialLayer) {
        builder.addFieldInt16(2, preferredSpatialLayer, 0);
    }
    static addTargetSpatialLayer(builder, targetSpatialLayer) {
        builder.addFieldInt16(3, targetSpatialLayer, 0);
    }
    static addCurrentSpatialLayer(builder, currentSpatialLayer) {
        builder.addFieldInt16(4, currentSpatialLayer, 0);
    }
    static addPreferredTemporalLayer(builder, preferredTemporalLayer) {
        builder.addFieldInt16(5, preferredTemporalLayer, 0);
    }
    static addTargetTemporalLayer(builder, targetTemporalLayer) {
        builder.addFieldInt16(6, targetTemporalLayer, 0);
    }
    static addCurrentTemporalLayer(builder, currentTemporalLayer) {
        builder.addFieldInt16(7, currentTemporalLayer, 0);
    }
    static endConsumerDump(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 6); // rtp_streams
        return offset;
    }
    static createConsumerDump(builder, baseOffset, rtpStreamsOffset, preferredSpatialLayer, targetSpatialLayer, currentSpatialLayer, preferredTemporalLayer, targetTemporalLayer, currentTemporalLayer) {
        ConsumerDump.startConsumerDump(builder);
        ConsumerDump.addBase(builder, baseOffset);
        ConsumerDump.addRtpStreams(builder, rtpStreamsOffset);
        if (preferredSpatialLayer !== null)
            ConsumerDump.addPreferredSpatialLayer(builder, preferredSpatialLayer);
        if (targetSpatialLayer !== null)
            ConsumerDump.addTargetSpatialLayer(builder, targetSpatialLayer);
        if (currentSpatialLayer !== null)
            ConsumerDump.addCurrentSpatialLayer(builder, currentSpatialLayer);
        if (preferredTemporalLayer !== null)
            ConsumerDump.addPreferredTemporalLayer(builder, preferredTemporalLayer);
        if (targetTemporalLayer !== null)
            ConsumerDump.addTargetTemporalLayer(builder, targetTemporalLayer);
        if (currentTemporalLayer !== null)
            ConsumerDump.addCurrentTemporalLayer(builder, currentTemporalLayer);
        return ConsumerDump.endConsumerDump(builder);
    }
    unpack() {
        return new ConsumerDumpT((this.base() !== null ? this.base().unpack() : null), this.bb.createObjList(this.rtpStreams.bind(this), this.rtpStreamsLength()), this.preferredSpatialLayer(), this.targetSpatialLayer(), this.currentSpatialLayer(), this.preferredTemporalLayer(), this.targetTemporalLayer(), this.currentTemporalLayer());
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.rtpStreams = this.bb.createObjList(this.rtpStreams.bind(this), this.rtpStreamsLength());
        _o.preferredSpatialLayer = this.preferredSpatialLayer();
        _o.targetSpatialLayer = this.targetSpatialLayer();
        _o.currentSpatialLayer = this.currentSpatialLayer();
        _o.preferredTemporalLayer = this.preferredTemporalLayer();
        _o.targetTemporalLayer = this.targetTemporalLayer();
        _o.currentTemporalLayer = this.currentTemporalLayer();
    }
}
exports.ConsumerDump = ConsumerDump;
class ConsumerDumpT {
    base;
    rtpStreams;
    preferredSpatialLayer;
    targetSpatialLayer;
    currentSpatialLayer;
    preferredTemporalLayer;
    targetTemporalLayer;
    currentTemporalLayer;
    constructor(base = null, rtpStreams = [], preferredSpatialLayer = null, targetSpatialLayer = null, currentSpatialLayer = null, preferredTemporalLayer = null, targetTemporalLayer = null, currentTemporalLayer = null) {
        this.base = base;
        this.rtpStreams = rtpStreams;
        this.preferredSpatialLayer = preferredSpatialLayer;
        this.targetSpatialLayer = targetSpatialLayer;
        this.currentSpatialLayer = currentSpatialLayer;
        this.preferredTemporalLayer = preferredTemporalLayer;
        this.targetTemporalLayer = targetTemporalLayer;
        this.currentTemporalLayer = currentTemporalLayer;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const rtpStreams = ConsumerDump.createRtpStreamsVector(builder, builder.createObjectOffsetList(this.rtpStreams));
        return ConsumerDump.createConsumerDump(builder, base, rtpStreams, this.preferredSpatialLayer, this.targetSpatialLayer, this.currentSpatialLayer, this.preferredTemporalLayer, this.targetTemporalLayer, this.currentTemporalLayer);
    }
}
exports.ConsumerDumpT = ConsumerDumpT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-layers.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-layers.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsumerLayersT = exports.ConsumerLayers = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class ConsumerLayers {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConsumerLayers(bb, obj) {
        return (obj || new ConsumerLayers()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConsumerLayers(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConsumerLayers()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    spatialLayer() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    temporalLayer() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    static startConsumerLayers(builder) {
        builder.startObject(2);
    }
    static addSpatialLayer(builder, spatialLayer) {
        builder.addFieldInt8(0, spatialLayer, 0);
    }
    static addTemporalLayer(builder, temporalLayer) {
        builder.addFieldInt8(1, temporalLayer, 0);
    }
    static endConsumerLayers(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createConsumerLayers(builder, spatialLayer, temporalLayer) {
        ConsumerLayers.startConsumerLayers(builder);
        ConsumerLayers.addSpatialLayer(builder, spatialLayer);
        if (temporalLayer !== null)
            ConsumerLayers.addTemporalLayer(builder, temporalLayer);
        return ConsumerLayers.endConsumerLayers(builder);
    }
    unpack() {
        return new ConsumerLayersT(this.spatialLayer(), this.temporalLayer());
    }
    unpackTo(_o) {
        _o.spatialLayer = this.spatialLayer();
        _o.temporalLayer = this.temporalLayer();
    }
}
exports.ConsumerLayers = ConsumerLayers;
class ConsumerLayersT {
    spatialLayer;
    temporalLayer;
    constructor(spatialLayer = 0, temporalLayer = null) {
        this.spatialLayer = spatialLayer;
        this.temporalLayer = temporalLayer;
    }
    pack(builder) {
        return ConsumerLayers.createConsumerLayers(builder, this.spatialLayer, this.temporalLayer);
    }
}
exports.ConsumerLayersT = ConsumerLayersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-score.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-score.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsumerScoreT = exports.ConsumerScore = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class ConsumerScore {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConsumerScore(bb, obj) {
        return (obj || new ConsumerScore()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConsumerScore(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConsumerScore()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    score() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    producerScore() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    producerScores(index) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    producerScoresLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    producerScoresArray() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startConsumerScore(builder) {
        builder.startObject(3);
    }
    static addScore(builder, score) {
        builder.addFieldInt8(0, score, 0);
    }
    static addProducerScore(builder, producerScore) {
        builder.addFieldInt8(1, producerScore, 0);
    }
    static addProducerScores(builder, producerScoresOffset) {
        builder.addFieldOffset(2, producerScoresOffset, 0);
    }
    static createProducerScoresVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startProducerScoresVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endConsumerScore(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 8); // producer_scores
        return offset;
    }
    static createConsumerScore(builder, score, producerScore, producerScoresOffset) {
        ConsumerScore.startConsumerScore(builder);
        ConsumerScore.addScore(builder, score);
        ConsumerScore.addProducerScore(builder, producerScore);
        ConsumerScore.addProducerScores(builder, producerScoresOffset);
        return ConsumerScore.endConsumerScore(builder);
    }
    unpack() {
        return new ConsumerScoreT(this.score(), this.producerScore(), this.bb.createScalarList(this.producerScores.bind(this), this.producerScoresLength()));
    }
    unpackTo(_o) {
        _o.score = this.score();
        _o.producerScore = this.producerScore();
        _o.producerScores = this.bb.createScalarList(this.producerScores.bind(this), this.producerScoresLength());
    }
}
exports.ConsumerScore = ConsumerScore;
class ConsumerScoreT {
    score;
    producerScore;
    producerScores;
    constructor(score = 0, producerScore = 0, producerScores = []) {
        this.score = score;
        this.producerScore = producerScore;
        this.producerScores = producerScores;
    }
    pack(builder) {
        const producerScores = ConsumerScore.createProducerScoresVector(builder, this.producerScores);
        return ConsumerScore.createConsumerScore(builder, this.score, this.producerScore, producerScores);
    }
}
exports.ConsumerScoreT = ConsumerScoreT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/dump-response.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/dump-response.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const consumer_dump_1 = __webpack_require__(/*! ../../fbs/consumer/consumer-dump */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-dump.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new consumer_dump_1.ConsumerDump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startDumpResponse(builder) {
        builder.startObject(1);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(0, dataOffset, 0);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data
        return offset;
    }
    static createDumpResponse(builder, dataOffset) {
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addData(builder, dataOffset);
        return DumpResponse.endDumpResponse(builder);
    }
    unpack() {
        return new DumpResponseT((this.data() !== null ? this.data().unpack() : null));
    }
    unpackTo(_o) {
        _o.data = (this.data() !== null ? this.data().unpack() : null);
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    data;
    constructor(data = null) {
        this.data = data;
    }
    pack(builder) {
        const data = (this.data !== null ? this.data.pack(builder) : 0);
        return DumpResponse.createDumpResponse(builder, data);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/enable-trace-event-request.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/enable-trace-event-request.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnableTraceEventRequestT = exports.EnableTraceEventRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class EnableTraceEventRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEnableTraceEventRequest(bb, obj) {
        return (obj || new EnableTraceEventRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEnableTraceEventRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EnableTraceEventRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    events(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    eventsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    eventsArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startEnableTraceEventRequest(builder) {
        builder.startObject(1);
    }
    static addEvents(builder, eventsOffset) {
        builder.addFieldOffset(0, eventsOffset, 0);
    }
    static createEventsVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startEventsVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endEnableTraceEventRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // events
        return offset;
    }
    static createEnableTraceEventRequest(builder, eventsOffset) {
        EnableTraceEventRequest.startEnableTraceEventRequest(builder);
        EnableTraceEventRequest.addEvents(builder, eventsOffset);
        return EnableTraceEventRequest.endEnableTraceEventRequest(builder);
    }
    unpack() {
        return new EnableTraceEventRequestT(this.bb.createScalarList(this.events.bind(this), this.eventsLength()));
    }
    unpackTo(_o) {
        _o.events = this.bb.createScalarList(this.events.bind(this), this.eventsLength());
    }
}
exports.EnableTraceEventRequest = EnableTraceEventRequest;
class EnableTraceEventRequestT {
    events;
    constructor(events = []) {
        this.events = events;
    }
    pack(builder) {
        const events = EnableTraceEventRequest.createEventsVector(builder, this.events);
        return EnableTraceEventRequest.createEnableTraceEventRequest(builder, events);
    }
}
exports.EnableTraceEventRequestT = EnableTraceEventRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/fir-trace-info.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/fir-trace-info.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FirTraceInfoT = exports.FirTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class FirTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFirTraceInfo(bb, obj) {
        return (obj || new FirTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFirTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FirTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startFirTraceInfo(builder) {
        builder.startObject(1);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(0, ssrc, 0);
    }
    static endFirTraceInfo(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFirTraceInfo(builder, ssrc) {
        FirTraceInfo.startFirTraceInfo(builder);
        FirTraceInfo.addSsrc(builder, ssrc);
        return FirTraceInfo.endFirTraceInfo(builder);
    }
    unpack() {
        return new FirTraceInfoT(this.ssrc());
    }
    unpackTo(_o) {
        _o.ssrc = this.ssrc();
    }
}
exports.FirTraceInfo = FirTraceInfo;
class FirTraceInfoT {
    ssrc;
    constructor(ssrc = 0) {
        this.ssrc = ssrc;
    }
    pack(builder) {
        return FirTraceInfo.createFirTraceInfo(builder, this.ssrc);
    }
}
exports.FirTraceInfoT = FirTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/get-stats-response.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/get-stats-response.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStatsResponseT = exports.GetStatsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const stats_1 = __webpack_require__(/*! ../../fbs/rtp-stream/stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats.js");
class GetStatsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetStatsResponse(bb, obj) {
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetStatsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    stats(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new stats_1.Stats()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    statsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startGetStatsResponse(builder) {
        builder.startObject(1);
    }
    static addStats(builder, statsOffset) {
        builder.addFieldOffset(0, statsOffset, 0);
    }
    static createStatsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startStatsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endGetStatsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // stats
        return offset;
    }
    static createGetStatsResponse(builder, statsOffset) {
        GetStatsResponse.startGetStatsResponse(builder);
        GetStatsResponse.addStats(builder, statsOffset);
        return GetStatsResponse.endGetStatsResponse(builder);
    }
    unpack() {
        return new GetStatsResponseT(this.bb.createObjList(this.stats.bind(this), this.statsLength()));
    }
    unpackTo(_o) {
        _o.stats = this.bb.createObjList(this.stats.bind(this), this.statsLength());
    }
}
exports.GetStatsResponse = GetStatsResponse;
class GetStatsResponseT {
    stats;
    constructor(stats = []) {
        this.stats = stats;
    }
    pack(builder) {
        const stats = GetStatsResponse.createStatsVector(builder, builder.createObjectOffsetList(this.stats));
        return GetStatsResponse.createGetStatsResponse(builder, stats);
    }
}
exports.GetStatsResponseT = GetStatsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/key-frame-trace-info.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/key-frame-trace-info.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyFrameTraceInfoT = exports.KeyFrameTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dump_1 = __webpack_require__(/*! ../../fbs/rtp-packet/dump */ "../../node_modules/mediasoup/node/lib/fbs/rtp-packet/dump.js");
class KeyFrameTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsKeyFrameTraceInfo(bb, obj) {
        return (obj || new KeyFrameTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyFrameTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new KeyFrameTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    rtpPacket(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isRtx() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startKeyFrameTraceInfo(builder) {
        builder.startObject(2);
    }
    static addRtpPacket(builder, rtpPacketOffset) {
        builder.addFieldOffset(0, rtpPacketOffset, 0);
    }
    static addIsRtx(builder, isRtx) {
        builder.addFieldInt8(1, +isRtx, +false);
    }
    static endKeyFrameTraceInfo(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // rtp_packet
        return offset;
    }
    static createKeyFrameTraceInfo(builder, rtpPacketOffset, isRtx) {
        KeyFrameTraceInfo.startKeyFrameTraceInfo(builder);
        KeyFrameTraceInfo.addRtpPacket(builder, rtpPacketOffset);
        KeyFrameTraceInfo.addIsRtx(builder, isRtx);
        return KeyFrameTraceInfo.endKeyFrameTraceInfo(builder);
    }
    unpack() {
        return new KeyFrameTraceInfoT((this.rtpPacket() !== null ? this.rtpPacket().unpack() : null), this.isRtx());
    }
    unpackTo(_o) {
        _o.rtpPacket = (this.rtpPacket() !== null ? this.rtpPacket().unpack() : null);
        _o.isRtx = this.isRtx();
    }
}
exports.KeyFrameTraceInfo = KeyFrameTraceInfo;
class KeyFrameTraceInfoT {
    rtpPacket;
    isRtx;
    constructor(rtpPacket = null, isRtx = false) {
        this.rtpPacket = rtpPacket;
        this.isRtx = isRtx;
    }
    pack(builder) {
        const rtpPacket = (this.rtpPacket !== null ? this.rtpPacket.pack(builder) : 0);
        return KeyFrameTraceInfo.createKeyFrameTraceInfo(builder, rtpPacket, this.isRtx);
    }
}
exports.KeyFrameTraceInfoT = KeyFrameTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/layers-change-notification.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/layers-change-notification.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayersChangeNotificationT = exports.LayersChangeNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const consumer_layers_1 = __webpack_require__(/*! ../../fbs/consumer/consumer-layers */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-layers.js");
class LayersChangeNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLayersChangeNotification(bb, obj) {
        return (obj || new LayersChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLayersChangeNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LayersChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    layers(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new consumer_layers_1.ConsumerLayers()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startLayersChangeNotification(builder) {
        builder.startObject(1);
    }
    static addLayers(builder, layersOffset) {
        builder.addFieldOffset(0, layersOffset, 0);
    }
    static endLayersChangeNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLayersChangeNotification(builder, layersOffset) {
        LayersChangeNotification.startLayersChangeNotification(builder);
        LayersChangeNotification.addLayers(builder, layersOffset);
        return LayersChangeNotification.endLayersChangeNotification(builder);
    }
    unpack() {
        return new LayersChangeNotificationT((this.layers() !== null ? this.layers().unpack() : null));
    }
    unpackTo(_o) {
        _o.layers = (this.layers() !== null ? this.layers().unpack() : null);
    }
}
exports.LayersChangeNotification = LayersChangeNotification;
class LayersChangeNotificationT {
    layers;
    constructor(layers = null) {
        this.layers = layers;
    }
    pack(builder) {
        const layers = (this.layers !== null ? this.layers.pack(builder) : 0);
        return LayersChangeNotification.createLayersChangeNotification(builder, layers);
    }
}
exports.LayersChangeNotificationT = LayersChangeNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/pli-trace-info.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/pli-trace-info.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PliTraceInfoT = exports.PliTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class PliTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPliTraceInfo(bb, obj) {
        return (obj || new PliTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPliTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new PliTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startPliTraceInfo(builder) {
        builder.startObject(1);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(0, ssrc, 0);
    }
    static endPliTraceInfo(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createPliTraceInfo(builder, ssrc) {
        PliTraceInfo.startPliTraceInfo(builder);
        PliTraceInfo.addSsrc(builder, ssrc);
        return PliTraceInfo.endPliTraceInfo(builder);
    }
    unpack() {
        return new PliTraceInfoT(this.ssrc());
    }
    unpackTo(_o) {
        _o.ssrc = this.ssrc();
    }
}
exports.PliTraceInfo = PliTraceInfo;
class PliTraceInfoT {
    ssrc;
    constructor(ssrc = 0) {
        this.ssrc = ssrc;
    }
    pack(builder) {
        return PliTraceInfo.createPliTraceInfo(builder, this.ssrc);
    }
}
exports.PliTraceInfoT = PliTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/rtp-notification.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/rtp-notification.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpNotificationT = exports.RtpNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RtpNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpNotification(bb, obj) {
        return (obj || new RtpNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    data(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startRtpNotification(builder) {
        builder.startObject(1);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(0, dataOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endRtpNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data
        return offset;
    }
    static createRtpNotification(builder, dataOffset) {
        RtpNotification.startRtpNotification(builder);
        RtpNotification.addData(builder, dataOffset);
        return RtpNotification.endRtpNotification(builder);
    }
    unpack() {
        return new RtpNotificationT(this.bb.createScalarList(this.data.bind(this), this.dataLength()));
    }
    unpackTo(_o) {
        _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());
    }
}
exports.RtpNotification = RtpNotification;
class RtpNotificationT {
    data;
    constructor(data = []) {
        this.data = data;
    }
    pack(builder) {
        const data = RtpNotification.createDataVector(builder, this.data);
        return RtpNotification.createRtpNotification(builder, data);
    }
}
exports.RtpNotificationT = RtpNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/rtp-trace-info.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/rtp-trace-info.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpTraceInfoT = exports.RtpTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dump_1 = __webpack_require__(/*! ../../fbs/rtp-packet/dump */ "../../node_modules/mediasoup/node/lib/fbs/rtp-packet/dump.js");
class RtpTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpTraceInfo(bb, obj) {
        return (obj || new RtpTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    rtpPacket(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isRtx() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startRtpTraceInfo(builder) {
        builder.startObject(2);
    }
    static addRtpPacket(builder, rtpPacketOffset) {
        builder.addFieldOffset(0, rtpPacketOffset, 0);
    }
    static addIsRtx(builder, isRtx) {
        builder.addFieldInt8(1, +isRtx, +false);
    }
    static endRtpTraceInfo(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // rtp_packet
        return offset;
    }
    static createRtpTraceInfo(builder, rtpPacketOffset, isRtx) {
        RtpTraceInfo.startRtpTraceInfo(builder);
        RtpTraceInfo.addRtpPacket(builder, rtpPacketOffset);
        RtpTraceInfo.addIsRtx(builder, isRtx);
        return RtpTraceInfo.endRtpTraceInfo(builder);
    }
    unpack() {
        return new RtpTraceInfoT((this.rtpPacket() !== null ? this.rtpPacket().unpack() : null), this.isRtx());
    }
    unpackTo(_o) {
        _o.rtpPacket = (this.rtpPacket() !== null ? this.rtpPacket().unpack() : null);
        _o.isRtx = this.isRtx();
    }
}
exports.RtpTraceInfo = RtpTraceInfo;
class RtpTraceInfoT {
    rtpPacket;
    isRtx;
    constructor(rtpPacket = null, isRtx = false) {
        this.rtpPacket = rtpPacket;
        this.isRtx = isRtx;
    }
    pack(builder) {
        const rtpPacket = (this.rtpPacket !== null ? this.rtpPacket.pack(builder) : 0);
        return RtpTraceInfo.createRtpTraceInfo(builder, rtpPacket, this.isRtx);
    }
}
exports.RtpTraceInfoT = RtpTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/score-notification.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/score-notification.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScoreNotificationT = exports.ScoreNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const consumer_score_1 = __webpack_require__(/*! ../../fbs/consumer/consumer-score */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-score.js");
class ScoreNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsScoreNotification(bb, obj) {
        return (obj || new ScoreNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsScoreNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ScoreNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    score(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new consumer_score_1.ConsumerScore()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startScoreNotification(builder) {
        builder.startObject(1);
    }
    static addScore(builder, scoreOffset) {
        builder.addFieldOffset(0, scoreOffset, 0);
    }
    static endScoreNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // score
        return offset;
    }
    static createScoreNotification(builder, scoreOffset) {
        ScoreNotification.startScoreNotification(builder);
        ScoreNotification.addScore(builder, scoreOffset);
        return ScoreNotification.endScoreNotification(builder);
    }
    unpack() {
        return new ScoreNotificationT((this.score() !== null ? this.score().unpack() : null));
    }
    unpackTo(_o) {
        _o.score = (this.score() !== null ? this.score().unpack() : null);
    }
}
exports.ScoreNotification = ScoreNotification;
class ScoreNotificationT {
    score;
    constructor(score = null) {
        this.score = score;
    }
    pack(builder) {
        const score = (this.score !== null ? this.score.pack(builder) : 0);
        return ScoreNotification.createScoreNotification(builder, score);
    }
}
exports.ScoreNotificationT = ScoreNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-preferred-layers-request.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/set-preferred-layers-request.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetPreferredLayersRequestT = exports.SetPreferredLayersRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const consumer_layers_1 = __webpack_require__(/*! ../../fbs/consumer/consumer-layers */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-layers.js");
class SetPreferredLayersRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetPreferredLayersRequest(bb, obj) {
        return (obj || new SetPreferredLayersRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetPreferredLayersRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetPreferredLayersRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    preferredLayers(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new consumer_layers_1.ConsumerLayers()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startSetPreferredLayersRequest(builder) {
        builder.startObject(1);
    }
    static addPreferredLayers(builder, preferredLayersOffset) {
        builder.addFieldOffset(0, preferredLayersOffset, 0);
    }
    static endSetPreferredLayersRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // preferred_layers
        return offset;
    }
    static createSetPreferredLayersRequest(builder, preferredLayersOffset) {
        SetPreferredLayersRequest.startSetPreferredLayersRequest(builder);
        SetPreferredLayersRequest.addPreferredLayers(builder, preferredLayersOffset);
        return SetPreferredLayersRequest.endSetPreferredLayersRequest(builder);
    }
    unpack() {
        return new SetPreferredLayersRequestT((this.preferredLayers() !== null ? this.preferredLayers().unpack() : null));
    }
    unpackTo(_o) {
        _o.preferredLayers = (this.preferredLayers() !== null ? this.preferredLayers().unpack() : null);
    }
}
exports.SetPreferredLayersRequest = SetPreferredLayersRequest;
class SetPreferredLayersRequestT {
    preferredLayers;
    constructor(preferredLayers = null) {
        this.preferredLayers = preferredLayers;
    }
    pack(builder) {
        const preferredLayers = (this.preferredLayers !== null ? this.preferredLayers.pack(builder) : 0);
        return SetPreferredLayersRequest.createSetPreferredLayersRequest(builder, preferredLayers);
    }
}
exports.SetPreferredLayersRequestT = SetPreferredLayersRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-preferred-layers-response.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/set-preferred-layers-response.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetPreferredLayersResponseT = exports.SetPreferredLayersResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const consumer_layers_1 = __webpack_require__(/*! ../../fbs/consumer/consumer-layers */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-layers.js");
class SetPreferredLayersResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetPreferredLayersResponse(bb, obj) {
        return (obj || new SetPreferredLayersResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetPreferredLayersResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetPreferredLayersResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    preferredLayers(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new consumer_layers_1.ConsumerLayers()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startSetPreferredLayersResponse(builder) {
        builder.startObject(1);
    }
    static addPreferredLayers(builder, preferredLayersOffset) {
        builder.addFieldOffset(0, preferredLayersOffset, 0);
    }
    static endSetPreferredLayersResponse(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSetPreferredLayersResponse(builder, preferredLayersOffset) {
        SetPreferredLayersResponse.startSetPreferredLayersResponse(builder);
        SetPreferredLayersResponse.addPreferredLayers(builder, preferredLayersOffset);
        return SetPreferredLayersResponse.endSetPreferredLayersResponse(builder);
    }
    unpack() {
        return new SetPreferredLayersResponseT((this.preferredLayers() !== null ? this.preferredLayers().unpack() : null));
    }
    unpackTo(_o) {
        _o.preferredLayers = (this.preferredLayers() !== null ? this.preferredLayers().unpack() : null);
    }
}
exports.SetPreferredLayersResponse = SetPreferredLayersResponse;
class SetPreferredLayersResponseT {
    preferredLayers;
    constructor(preferredLayers = null) {
        this.preferredLayers = preferredLayers;
    }
    pack(builder) {
        const preferredLayers = (this.preferredLayers !== null ? this.preferredLayers.pack(builder) : 0);
        return SetPreferredLayersResponse.createSetPreferredLayersResponse(builder, preferredLayers);
    }
}
exports.SetPreferredLayersResponseT = SetPreferredLayersResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-priority-request.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/set-priority-request.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetPriorityRequestT = exports.SetPriorityRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SetPriorityRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetPriorityRequest(bb, obj) {
        return (obj || new SetPriorityRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetPriorityRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetPriorityRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    priority() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startSetPriorityRequest(builder) {
        builder.startObject(1);
    }
    static addPriority(builder, priority) {
        builder.addFieldInt8(0, priority, 0);
    }
    static endSetPriorityRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSetPriorityRequest(builder, priority) {
        SetPriorityRequest.startSetPriorityRequest(builder);
        SetPriorityRequest.addPriority(builder, priority);
        return SetPriorityRequest.endSetPriorityRequest(builder);
    }
    unpack() {
        return new SetPriorityRequestT(this.priority());
    }
    unpackTo(_o) {
        _o.priority = this.priority();
    }
}
exports.SetPriorityRequest = SetPriorityRequest;
class SetPriorityRequestT {
    priority;
    constructor(priority = 0) {
        this.priority = priority;
    }
    pack(builder) {
        return SetPriorityRequest.createSetPriorityRequest(builder, this.priority);
    }
}
exports.SetPriorityRequestT = SetPriorityRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-priority-response.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/set-priority-response.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetPriorityResponseT = exports.SetPriorityResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SetPriorityResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetPriorityResponse(bb, obj) {
        return (obj || new SetPriorityResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetPriorityResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetPriorityResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    priority() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startSetPriorityResponse(builder) {
        builder.startObject(1);
    }
    static addPriority(builder, priority) {
        builder.addFieldInt8(0, priority, 0);
    }
    static endSetPriorityResponse(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSetPriorityResponse(builder, priority) {
        SetPriorityResponse.startSetPriorityResponse(builder);
        SetPriorityResponse.addPriority(builder, priority);
        return SetPriorityResponse.endSetPriorityResponse(builder);
    }
    unpack() {
        return new SetPriorityResponseT(this.priority());
    }
    unpackTo(_o) {
        _o.priority = this.priority();
    }
}
exports.SetPriorityResponse = SetPriorityResponse;
class SetPriorityResponseT {
    priority;
    constructor(priority = 0) {
        this.priority = priority;
    }
    pack(builder) {
        return SetPriorityResponse.createSetPriorityResponse(builder, this.priority);
    }
}
exports.SetPriorityResponseT = SetPriorityResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-event-type.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/trace-event-type.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceEventType = void 0;
var TraceEventType;
(function (TraceEventType) {
    TraceEventType[TraceEventType["KEYFRAME"] = 0] = "KEYFRAME";
    TraceEventType[TraceEventType["FIR"] = 1] = "FIR";
    TraceEventType[TraceEventType["NACK"] = 2] = "NACK";
    TraceEventType[TraceEventType["PLI"] = 3] = "PLI";
    TraceEventType[TraceEventType["RTP"] = 4] = "RTP";
})(TraceEventType || (exports.TraceEventType = TraceEventType = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-info.js":
/*!************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/trace-info.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToTraceInfo = exports.unionToTraceInfo = exports.TraceInfo = void 0;
const fir_trace_info_1 = __webpack_require__(/*! ../../fbs/consumer/fir-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/fir-trace-info.js");
const key_frame_trace_info_1 = __webpack_require__(/*! ../../fbs/consumer/key-frame-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/key-frame-trace-info.js");
const pli_trace_info_1 = __webpack_require__(/*! ../../fbs/consumer/pli-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/pli-trace-info.js");
const rtp_trace_info_1 = __webpack_require__(/*! ../../fbs/consumer/rtp-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/rtp-trace-info.js");
var TraceInfo;
(function (TraceInfo) {
    TraceInfo[TraceInfo["NONE"] = 0] = "NONE";
    TraceInfo[TraceInfo["KeyFrameTraceInfo"] = 1] = "KeyFrameTraceInfo";
    TraceInfo[TraceInfo["FirTraceInfo"] = 2] = "FirTraceInfo";
    TraceInfo[TraceInfo["PliTraceInfo"] = 3] = "PliTraceInfo";
    TraceInfo[TraceInfo["RtpTraceInfo"] = 4] = "RtpTraceInfo";
})(TraceInfo || (exports.TraceInfo = TraceInfo = {}));
function unionToTraceInfo(type, accessor) {
    switch (TraceInfo[type]) {
        case 'NONE': return null;
        case 'KeyFrameTraceInfo': return accessor(new key_frame_trace_info_1.KeyFrameTraceInfo());
        case 'FirTraceInfo': return accessor(new fir_trace_info_1.FirTraceInfo());
        case 'PliTraceInfo': return accessor(new pli_trace_info_1.PliTraceInfo());
        case 'RtpTraceInfo': return accessor(new rtp_trace_info_1.RtpTraceInfo());
        default: return null;
    }
}
exports.unionToTraceInfo = unionToTraceInfo;
function unionListToTraceInfo(type, accessor, index) {
    switch (TraceInfo[type]) {
        case 'NONE': return null;
        case 'KeyFrameTraceInfo': return accessor(index, new key_frame_trace_info_1.KeyFrameTraceInfo());
        case 'FirTraceInfo': return accessor(index, new fir_trace_info_1.FirTraceInfo());
        case 'PliTraceInfo': return accessor(index, new pli_trace_info_1.PliTraceInfo());
        case 'RtpTraceInfo': return accessor(index, new rtp_trace_info_1.RtpTraceInfo());
        default: return null;
    }
}
exports.unionListToTraceInfo = unionListToTraceInfo;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-notification.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/consumer/trace-notification.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceNotificationT = exports.TraceNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const trace_direction_1 = __webpack_require__(/*! ../../fbs/common/trace-direction */ "../../node_modules/mediasoup/node/lib/fbs/common/trace-direction.js");
const trace_event_type_1 = __webpack_require__(/*! ../../fbs/consumer/trace-event-type */ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-event-type.js");
const trace_info_1 = __webpack_require__(/*! ../../fbs/consumer/trace-info */ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-info.js");
class TraceNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTraceNotification(bb, obj) {
        return (obj || new TraceNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTraceNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TraceNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_event_type_1.TraceEventType.KEYFRAME;
    }
    timestamp() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    direction() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_direction_1.TraceDirection.DIRECTION_IN;
    }
    infoType() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_info_1.TraceInfo.NONE;
    }
    info(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startTraceNotification(builder) {
        builder.startObject(5);
    }
    static addType(builder, type) {
        builder.addFieldInt8(0, type, trace_event_type_1.TraceEventType.KEYFRAME);
    }
    static addTimestamp(builder, timestamp) {
        builder.addFieldInt64(1, timestamp, BigInt('0'));
    }
    static addDirection(builder, direction) {
        builder.addFieldInt8(2, direction, trace_direction_1.TraceDirection.DIRECTION_IN);
    }
    static addInfoType(builder, infoType) {
        builder.addFieldInt8(3, infoType, trace_info_1.TraceInfo.NONE);
    }
    static addInfo(builder, infoOffset) {
        builder.addFieldOffset(4, infoOffset, 0);
    }
    static endTraceNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTraceNotification(builder, type, timestamp, direction, infoType, infoOffset) {
        TraceNotification.startTraceNotification(builder);
        TraceNotification.addType(builder, type);
        TraceNotification.addTimestamp(builder, timestamp);
        TraceNotification.addDirection(builder, direction);
        TraceNotification.addInfoType(builder, infoType);
        TraceNotification.addInfo(builder, infoOffset);
        return TraceNotification.endTraceNotification(builder);
    }
    unpack() {
        return new TraceNotificationT(this.type(), this.timestamp(), this.direction(), this.infoType(), (() => {
            const temp = (0, trace_info_1.unionToTraceInfo)(this.infoType(), this.info.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.type = this.type();
        _o.timestamp = this.timestamp();
        _o.direction = this.direction();
        _o.infoType = this.infoType();
        _o.info = (() => {
            const temp = (0, trace_info_1.unionToTraceInfo)(this.infoType(), this.info.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
exports.TraceNotification = TraceNotification;
class TraceNotificationT {
    type;
    timestamp;
    direction;
    infoType;
    info;
    constructor(type = trace_event_type_1.TraceEventType.KEYFRAME, timestamp = BigInt('0'), direction = trace_direction_1.TraceDirection.DIRECTION_IN, infoType = trace_info_1.TraceInfo.NONE, info = null) {
        this.type = type;
        this.timestamp = timestamp;
        this.direction = direction;
        this.infoType = infoType;
        this.info = info;
    }
    pack(builder) {
        const info = builder.createObjectOffset(this.info);
        return TraceNotification.createTraceNotification(builder, this.type, this.timestamp, this.direction, this.infoType, info);
    }
}
exports.TraceNotificationT = TraceNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetSubchannelsResponseT = exports.SetSubchannelsResponse = exports.SetSubchannelsRequestT = exports.SetSubchannelsRequest = exports.SetBufferedAmountLowThresholdRequestT = exports.SetBufferedAmountLowThresholdRequest = exports.SendRequestT = exports.SendRequest = exports.RemoveSubchannelResponseT = exports.RemoveSubchannelResponse = exports.RemoveSubchannelRequestT = exports.RemoveSubchannelRequest = exports.MessageNotificationT = exports.MessageNotification = exports.GetStatsResponseT = exports.GetStatsResponse = exports.GetBufferedAmountResponseT = exports.GetBufferedAmountResponse = exports.DumpResponseT = exports.DumpResponse = exports.BufferedAmountLowNotificationT = exports.BufferedAmountLowNotification = exports.AddSubchannelResponseT = exports.AddSubchannelResponse = exports.AddSubchannelRequestT = exports.AddSubchannelRequest = void 0;
var add_subchannel_request_1 = __webpack_require__(/*! ./data-consumer/add-subchannel-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/add-subchannel-request.js");
Object.defineProperty(exports, "AddSubchannelRequest", ({ enumerable: true, get: function () { return add_subchannel_request_1.AddSubchannelRequest; } }));
Object.defineProperty(exports, "AddSubchannelRequestT", ({ enumerable: true, get: function () { return add_subchannel_request_1.AddSubchannelRequestT; } }));
var add_subchannel_response_1 = __webpack_require__(/*! ./data-consumer/add-subchannel-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/add-subchannel-response.js");
Object.defineProperty(exports, "AddSubchannelResponse", ({ enumerable: true, get: function () { return add_subchannel_response_1.AddSubchannelResponse; } }));
Object.defineProperty(exports, "AddSubchannelResponseT", ({ enumerable: true, get: function () { return add_subchannel_response_1.AddSubchannelResponseT; } }));
var buffered_amount_low_notification_1 = __webpack_require__(/*! ./data-consumer/buffered-amount-low-notification */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/buffered-amount-low-notification.js");
Object.defineProperty(exports, "BufferedAmountLowNotification", ({ enumerable: true, get: function () { return buffered_amount_low_notification_1.BufferedAmountLowNotification; } }));
Object.defineProperty(exports, "BufferedAmountLowNotificationT", ({ enumerable: true, get: function () { return buffered_amount_low_notification_1.BufferedAmountLowNotificationT; } }));
var dump_response_1 = __webpack_require__(/*! ./data-consumer/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var get_buffered_amount_response_1 = __webpack_require__(/*! ./data-consumer/get-buffered-amount-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/get-buffered-amount-response.js");
Object.defineProperty(exports, "GetBufferedAmountResponse", ({ enumerable: true, get: function () { return get_buffered_amount_response_1.GetBufferedAmountResponse; } }));
Object.defineProperty(exports, "GetBufferedAmountResponseT", ({ enumerable: true, get: function () { return get_buffered_amount_response_1.GetBufferedAmountResponseT; } }));
var get_stats_response_1 = __webpack_require__(/*! ./data-consumer/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/get-stats-response.js");
Object.defineProperty(exports, "GetStatsResponse", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponse; } }));
Object.defineProperty(exports, "GetStatsResponseT", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponseT; } }));
var message_notification_1 = __webpack_require__(/*! ./data-consumer/message-notification */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/message-notification.js");
Object.defineProperty(exports, "MessageNotification", ({ enumerable: true, get: function () { return message_notification_1.MessageNotification; } }));
Object.defineProperty(exports, "MessageNotificationT", ({ enumerable: true, get: function () { return message_notification_1.MessageNotificationT; } }));
var remove_subchannel_request_1 = __webpack_require__(/*! ./data-consumer/remove-subchannel-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/remove-subchannel-request.js");
Object.defineProperty(exports, "RemoveSubchannelRequest", ({ enumerable: true, get: function () { return remove_subchannel_request_1.RemoveSubchannelRequest; } }));
Object.defineProperty(exports, "RemoveSubchannelRequestT", ({ enumerable: true, get: function () { return remove_subchannel_request_1.RemoveSubchannelRequestT; } }));
var remove_subchannel_response_1 = __webpack_require__(/*! ./data-consumer/remove-subchannel-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/remove-subchannel-response.js");
Object.defineProperty(exports, "RemoveSubchannelResponse", ({ enumerable: true, get: function () { return remove_subchannel_response_1.RemoveSubchannelResponse; } }));
Object.defineProperty(exports, "RemoveSubchannelResponseT", ({ enumerable: true, get: function () { return remove_subchannel_response_1.RemoveSubchannelResponseT; } }));
var send_request_1 = __webpack_require__(/*! ./data-consumer/send-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/send-request.js");
Object.defineProperty(exports, "SendRequest", ({ enumerable: true, get: function () { return send_request_1.SendRequest; } }));
Object.defineProperty(exports, "SendRequestT", ({ enumerable: true, get: function () { return send_request_1.SendRequestT; } }));
var set_buffered_amount_low_threshold_request_1 = __webpack_require__(/*! ./data-consumer/set-buffered-amount-low-threshold-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-buffered-amount-low-threshold-request.js");
Object.defineProperty(exports, "SetBufferedAmountLowThresholdRequest", ({ enumerable: true, get: function () { return set_buffered_amount_low_threshold_request_1.SetBufferedAmountLowThresholdRequest; } }));
Object.defineProperty(exports, "SetBufferedAmountLowThresholdRequestT", ({ enumerable: true, get: function () { return set_buffered_amount_low_threshold_request_1.SetBufferedAmountLowThresholdRequestT; } }));
var set_subchannels_request_1 = __webpack_require__(/*! ./data-consumer/set-subchannels-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-subchannels-request.js");
Object.defineProperty(exports, "SetSubchannelsRequest", ({ enumerable: true, get: function () { return set_subchannels_request_1.SetSubchannelsRequest; } }));
Object.defineProperty(exports, "SetSubchannelsRequestT", ({ enumerable: true, get: function () { return set_subchannels_request_1.SetSubchannelsRequestT; } }));
var set_subchannels_response_1 = __webpack_require__(/*! ./data-consumer/set-subchannels-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-subchannels-response.js");
Object.defineProperty(exports, "SetSubchannelsResponse", ({ enumerable: true, get: function () { return set_subchannels_response_1.SetSubchannelsResponse; } }));
Object.defineProperty(exports, "SetSubchannelsResponseT", ({ enumerable: true, get: function () { return set_subchannels_response_1.SetSubchannelsResponseT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/add-subchannel-request.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/add-subchannel-request.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddSubchannelRequestT = exports.AddSubchannelRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class AddSubchannelRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsAddSubchannelRequest(bb, obj) {
        return (obj || new AddSubchannelRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsAddSubchannelRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new AddSubchannelRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    subchannel() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    static startAddSubchannelRequest(builder) {
        builder.startObject(1);
    }
    static addSubchannel(builder, subchannel) {
        builder.addFieldInt16(0, subchannel, 0);
    }
    static endAddSubchannelRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createAddSubchannelRequest(builder, subchannel) {
        AddSubchannelRequest.startAddSubchannelRequest(builder);
        AddSubchannelRequest.addSubchannel(builder, subchannel);
        return AddSubchannelRequest.endAddSubchannelRequest(builder);
    }
    unpack() {
        return new AddSubchannelRequestT(this.subchannel());
    }
    unpackTo(_o) {
        _o.subchannel = this.subchannel();
    }
}
exports.AddSubchannelRequest = AddSubchannelRequest;
class AddSubchannelRequestT {
    subchannel;
    constructor(subchannel = 0) {
        this.subchannel = subchannel;
    }
    pack(builder) {
        return AddSubchannelRequest.createAddSubchannelRequest(builder, this.subchannel);
    }
}
exports.AddSubchannelRequestT = AddSubchannelRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/add-subchannel-response.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/add-subchannel-response.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddSubchannelResponseT = exports.AddSubchannelResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class AddSubchannelResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsAddSubchannelResponse(bb, obj) {
        return (obj || new AddSubchannelResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsAddSubchannelResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new AddSubchannelResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    subchannels(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
    }
    subchannelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    subchannelsArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startAddSubchannelResponse(builder) {
        builder.startObject(1);
    }
    static addSubchannels(builder, subchannelsOffset) {
        builder.addFieldOffset(0, subchannelsOffset, 0);
    }
    static createSubchannelsVector(builder, data) {
        builder.startVector(2, data.length, 2);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt16(data[i]);
        }
        return builder.endVector();
    }
    static startSubchannelsVector(builder, numElems) {
        builder.startVector(2, numElems, 2);
    }
    static endAddSubchannelResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // subchannels
        return offset;
    }
    static createAddSubchannelResponse(builder, subchannelsOffset) {
        AddSubchannelResponse.startAddSubchannelResponse(builder);
        AddSubchannelResponse.addSubchannels(builder, subchannelsOffset);
        return AddSubchannelResponse.endAddSubchannelResponse(builder);
    }
    unpack() {
        return new AddSubchannelResponseT(this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength()));
    }
    unpackTo(_o) {
        _o.subchannels = this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength());
    }
}
exports.AddSubchannelResponse = AddSubchannelResponse;
class AddSubchannelResponseT {
    subchannels;
    constructor(subchannels = []) {
        this.subchannels = subchannels;
    }
    pack(builder) {
        const subchannels = AddSubchannelResponse.createSubchannelsVector(builder, this.subchannels);
        return AddSubchannelResponse.createAddSubchannelResponse(builder, subchannels);
    }
}
exports.AddSubchannelResponseT = AddSubchannelResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/buffered-amount-low-notification.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/buffered-amount-low-notification.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferedAmountLowNotificationT = exports.BufferedAmountLowNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class BufferedAmountLowNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBufferedAmountLowNotification(bb, obj) {
        return (obj || new BufferedAmountLowNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBufferedAmountLowNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BufferedAmountLowNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bufferedAmount() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startBufferedAmountLowNotification(builder) {
        builder.startObject(1);
    }
    static addBufferedAmount(builder, bufferedAmount) {
        builder.addFieldInt32(0, bufferedAmount, 0);
    }
    static endBufferedAmountLowNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBufferedAmountLowNotification(builder, bufferedAmount) {
        BufferedAmountLowNotification.startBufferedAmountLowNotification(builder);
        BufferedAmountLowNotification.addBufferedAmount(builder, bufferedAmount);
        return BufferedAmountLowNotification.endBufferedAmountLowNotification(builder);
    }
    unpack() {
        return new BufferedAmountLowNotificationT(this.bufferedAmount());
    }
    unpackTo(_o) {
        _o.bufferedAmount = this.bufferedAmount();
    }
}
exports.BufferedAmountLowNotification = BufferedAmountLowNotification;
class BufferedAmountLowNotificationT {
    bufferedAmount;
    constructor(bufferedAmount = 0) {
        this.bufferedAmount = bufferedAmount;
    }
    pack(builder) {
        return BufferedAmountLowNotification.createBufferedAmountLowNotification(builder, this.bufferedAmount);
    }
}
exports.BufferedAmountLowNotificationT = BufferedAmountLowNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/dump-response.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/dump-response.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const type_1 = __webpack_require__(/*! ../../fbs/data-producer/type */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/type.js");
const sctp_stream_parameters_1 = __webpack_require__(/*! ../../fbs/sctp-parameters/sctp-stream-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-stream-parameters.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    dataProducerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_1.Type.SCTP;
    }
    sctpStreamParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new sctp_stream_parameters_1.SctpStreamParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    label(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    protocol(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    bufferedAmountLowThreshold() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dataProducerPaused() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    subchannels(index) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
    }
    subchannelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    subchannelsArray() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startDumpResponse(builder) {
        builder.startObject(10);
    }
    static addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    }
    static addDataProducerId(builder, dataProducerIdOffset) {
        builder.addFieldOffset(1, dataProducerIdOffset, 0);
    }
    static addType(builder, type) {
        builder.addFieldInt8(2, type, type_1.Type.SCTP);
    }
    static addSctpStreamParameters(builder, sctpStreamParametersOffset) {
        builder.addFieldOffset(3, sctpStreamParametersOffset, 0);
    }
    static addLabel(builder, labelOffset) {
        builder.addFieldOffset(4, labelOffset, 0);
    }
    static addProtocol(builder, protocolOffset) {
        builder.addFieldOffset(5, protocolOffset, 0);
    }
    static addBufferedAmountLowThreshold(builder, bufferedAmountLowThreshold) {
        builder.addFieldInt32(6, bufferedAmountLowThreshold, 0);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(7, +paused, +false);
    }
    static addDataProducerPaused(builder, dataProducerPaused) {
        builder.addFieldInt8(8, +dataProducerPaused, +false);
    }
    static addSubchannels(builder, subchannelsOffset) {
        builder.addFieldOffset(9, subchannelsOffset, 0);
    }
    static createSubchannelsVector(builder, data) {
        builder.startVector(2, data.length, 2);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt16(data[i]);
        }
        return builder.endVector();
    }
    static startSubchannelsVector(builder, numElems) {
        builder.startVector(2, numElems, 2);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // id
        builder.requiredField(offset, 6); // data_producer_id
        builder.requiredField(offset, 12); // label
        builder.requiredField(offset, 14); // protocol
        builder.requiredField(offset, 22); // subchannels
        return offset;
    }
    unpack() {
        return new DumpResponseT(this.id(), this.dataProducerId(), this.type(), (this.sctpStreamParameters() !== null ? this.sctpStreamParameters().unpack() : null), this.label(), this.protocol(), this.bufferedAmountLowThreshold(), this.paused(), this.dataProducerPaused(), this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength()));
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.dataProducerId = this.dataProducerId();
        _o.type = this.type();
        _o.sctpStreamParameters = (this.sctpStreamParameters() !== null ? this.sctpStreamParameters().unpack() : null);
        _o.label = this.label();
        _o.protocol = this.protocol();
        _o.bufferedAmountLowThreshold = this.bufferedAmountLowThreshold();
        _o.paused = this.paused();
        _o.dataProducerPaused = this.dataProducerPaused();
        _o.subchannels = this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength());
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    id;
    dataProducerId;
    type;
    sctpStreamParameters;
    label;
    protocol;
    bufferedAmountLowThreshold;
    paused;
    dataProducerPaused;
    subchannels;
    constructor(id = null, dataProducerId = null, type = type_1.Type.SCTP, sctpStreamParameters = null, label = null, protocol = null, bufferedAmountLowThreshold = 0, paused = false, dataProducerPaused = false, subchannels = []) {
        this.id = id;
        this.dataProducerId = dataProducerId;
        this.type = type;
        this.sctpStreamParameters = sctpStreamParameters;
        this.label = label;
        this.protocol = protocol;
        this.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
        this.paused = paused;
        this.dataProducerPaused = dataProducerPaused;
        this.subchannels = subchannels;
    }
    pack(builder) {
        const id = (this.id !== null ? builder.createString(this.id) : 0);
        const dataProducerId = (this.dataProducerId !== null ? builder.createString(this.dataProducerId) : 0);
        const sctpStreamParameters = (this.sctpStreamParameters !== null ? this.sctpStreamParameters.pack(builder) : 0);
        const label = (this.label !== null ? builder.createString(this.label) : 0);
        const protocol = (this.protocol !== null ? builder.createString(this.protocol) : 0);
        const subchannels = DumpResponse.createSubchannelsVector(builder, this.subchannels);
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addId(builder, id);
        DumpResponse.addDataProducerId(builder, dataProducerId);
        DumpResponse.addType(builder, this.type);
        DumpResponse.addSctpStreamParameters(builder, sctpStreamParameters);
        DumpResponse.addLabel(builder, label);
        DumpResponse.addProtocol(builder, protocol);
        DumpResponse.addBufferedAmountLowThreshold(builder, this.bufferedAmountLowThreshold);
        DumpResponse.addPaused(builder, this.paused);
        DumpResponse.addDataProducerPaused(builder, this.dataProducerPaused);
        DumpResponse.addSubchannels(builder, subchannels);
        return DumpResponse.endDumpResponse(builder);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/get-buffered-amount-response.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/get-buffered-amount-response.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBufferedAmountResponseT = exports.GetBufferedAmountResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class GetBufferedAmountResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetBufferedAmountResponse(bb, obj) {
        return (obj || new GetBufferedAmountResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetBufferedAmountResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetBufferedAmountResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bufferedAmount() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startGetBufferedAmountResponse(builder) {
        builder.startObject(1);
    }
    static addBufferedAmount(builder, bufferedAmount) {
        builder.addFieldInt32(0, bufferedAmount, 0);
    }
    static endGetBufferedAmountResponse(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createGetBufferedAmountResponse(builder, bufferedAmount) {
        GetBufferedAmountResponse.startGetBufferedAmountResponse(builder);
        GetBufferedAmountResponse.addBufferedAmount(builder, bufferedAmount);
        return GetBufferedAmountResponse.endGetBufferedAmountResponse(builder);
    }
    unpack() {
        return new GetBufferedAmountResponseT(this.bufferedAmount());
    }
    unpackTo(_o) {
        _o.bufferedAmount = this.bufferedAmount();
    }
}
exports.GetBufferedAmountResponse = GetBufferedAmountResponse;
class GetBufferedAmountResponseT {
    bufferedAmount;
    constructor(bufferedAmount = 0) {
        this.bufferedAmount = bufferedAmount;
    }
    pack(builder) {
        return GetBufferedAmountResponse.createGetBufferedAmountResponse(builder, this.bufferedAmount);
    }
}
exports.GetBufferedAmountResponseT = GetBufferedAmountResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/get-stats-response.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/get-stats-response.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStatsResponseT = exports.GetStatsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class GetStatsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetStatsResponse(bb, obj) {
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetStatsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    timestamp() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    label(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    protocol(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    messagesSent() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    bytesSent() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    bufferedAmount() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startGetStatsResponse(builder) {
        builder.startObject(6);
    }
    static addTimestamp(builder, timestamp) {
        builder.addFieldInt64(0, timestamp, BigInt('0'));
    }
    static addLabel(builder, labelOffset) {
        builder.addFieldOffset(1, labelOffset, 0);
    }
    static addProtocol(builder, protocolOffset) {
        builder.addFieldOffset(2, protocolOffset, 0);
    }
    static addMessagesSent(builder, messagesSent) {
        builder.addFieldInt64(3, messagesSent, BigInt('0'));
    }
    static addBytesSent(builder, bytesSent) {
        builder.addFieldInt64(4, bytesSent, BigInt('0'));
    }
    static addBufferedAmount(builder, bufferedAmount) {
        builder.addFieldInt32(5, bufferedAmount, 0);
    }
    static endGetStatsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // label
        builder.requiredField(offset, 8); // protocol
        return offset;
    }
    static createGetStatsResponse(builder, timestamp, labelOffset, protocolOffset, messagesSent, bytesSent, bufferedAmount) {
        GetStatsResponse.startGetStatsResponse(builder);
        GetStatsResponse.addTimestamp(builder, timestamp);
        GetStatsResponse.addLabel(builder, labelOffset);
        GetStatsResponse.addProtocol(builder, protocolOffset);
        GetStatsResponse.addMessagesSent(builder, messagesSent);
        GetStatsResponse.addBytesSent(builder, bytesSent);
        GetStatsResponse.addBufferedAmount(builder, bufferedAmount);
        return GetStatsResponse.endGetStatsResponse(builder);
    }
    unpack() {
        return new GetStatsResponseT(this.timestamp(), this.label(), this.protocol(), this.messagesSent(), this.bytesSent(), this.bufferedAmount());
    }
    unpackTo(_o) {
        _o.timestamp = this.timestamp();
        _o.label = this.label();
        _o.protocol = this.protocol();
        _o.messagesSent = this.messagesSent();
        _o.bytesSent = this.bytesSent();
        _o.bufferedAmount = this.bufferedAmount();
    }
}
exports.GetStatsResponse = GetStatsResponse;
class GetStatsResponseT {
    timestamp;
    label;
    protocol;
    messagesSent;
    bytesSent;
    bufferedAmount;
    constructor(timestamp = BigInt('0'), label = null, protocol = null, messagesSent = BigInt('0'), bytesSent = BigInt('0'), bufferedAmount = 0) {
        this.timestamp = timestamp;
        this.label = label;
        this.protocol = protocol;
        this.messagesSent = messagesSent;
        this.bytesSent = bytesSent;
        this.bufferedAmount = bufferedAmount;
    }
    pack(builder) {
        const label = (this.label !== null ? builder.createString(this.label) : 0);
        const protocol = (this.protocol !== null ? builder.createString(this.protocol) : 0);
        return GetStatsResponse.createGetStatsResponse(builder, this.timestamp, label, protocol, this.messagesSent, this.bytesSent, this.bufferedAmount);
    }
}
exports.GetStatsResponseT = GetStatsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/message-notification.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/message-notification.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageNotificationT = exports.MessageNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class MessageNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMessageNotification(bb, obj) {
        return (obj || new MessageNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessageNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new MessageNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ppid() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    data(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startMessageNotification(builder) {
        builder.startObject(2);
    }
    static addPpid(builder, ppid) {
        builder.addFieldInt32(0, ppid, 0);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endMessageNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // data
        return offset;
    }
    static createMessageNotification(builder, ppid, dataOffset) {
        MessageNotification.startMessageNotification(builder);
        MessageNotification.addPpid(builder, ppid);
        MessageNotification.addData(builder, dataOffset);
        return MessageNotification.endMessageNotification(builder);
    }
    unpack() {
        return new MessageNotificationT(this.ppid(), this.bb.createScalarList(this.data.bind(this), this.dataLength()));
    }
    unpackTo(_o) {
        _o.ppid = this.ppid();
        _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());
    }
}
exports.MessageNotification = MessageNotification;
class MessageNotificationT {
    ppid;
    data;
    constructor(ppid = 0, data = []) {
        this.ppid = ppid;
        this.data = data;
    }
    pack(builder) {
        const data = MessageNotification.createDataVector(builder, this.data);
        return MessageNotification.createMessageNotification(builder, this.ppid, data);
    }
}
exports.MessageNotificationT = MessageNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/remove-subchannel-request.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/remove-subchannel-request.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveSubchannelRequestT = exports.RemoveSubchannelRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RemoveSubchannelRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRemoveSubchannelRequest(bb, obj) {
        return (obj || new RemoveSubchannelRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRemoveSubchannelRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RemoveSubchannelRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    subchannel() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    static startRemoveSubchannelRequest(builder) {
        builder.startObject(1);
    }
    static addSubchannel(builder, subchannel) {
        builder.addFieldInt16(0, subchannel, 0);
    }
    static endRemoveSubchannelRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRemoveSubchannelRequest(builder, subchannel) {
        RemoveSubchannelRequest.startRemoveSubchannelRequest(builder);
        RemoveSubchannelRequest.addSubchannel(builder, subchannel);
        return RemoveSubchannelRequest.endRemoveSubchannelRequest(builder);
    }
    unpack() {
        return new RemoveSubchannelRequestT(this.subchannel());
    }
    unpackTo(_o) {
        _o.subchannel = this.subchannel();
    }
}
exports.RemoveSubchannelRequest = RemoveSubchannelRequest;
class RemoveSubchannelRequestT {
    subchannel;
    constructor(subchannel = 0) {
        this.subchannel = subchannel;
    }
    pack(builder) {
        return RemoveSubchannelRequest.createRemoveSubchannelRequest(builder, this.subchannel);
    }
}
exports.RemoveSubchannelRequestT = RemoveSubchannelRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/remove-subchannel-response.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/remove-subchannel-response.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveSubchannelResponseT = exports.RemoveSubchannelResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RemoveSubchannelResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRemoveSubchannelResponse(bb, obj) {
        return (obj || new RemoveSubchannelResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRemoveSubchannelResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RemoveSubchannelResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    subchannels(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
    }
    subchannelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    subchannelsArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startRemoveSubchannelResponse(builder) {
        builder.startObject(1);
    }
    static addSubchannels(builder, subchannelsOffset) {
        builder.addFieldOffset(0, subchannelsOffset, 0);
    }
    static createSubchannelsVector(builder, data) {
        builder.startVector(2, data.length, 2);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt16(data[i]);
        }
        return builder.endVector();
    }
    static startSubchannelsVector(builder, numElems) {
        builder.startVector(2, numElems, 2);
    }
    static endRemoveSubchannelResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // subchannels
        return offset;
    }
    static createRemoveSubchannelResponse(builder, subchannelsOffset) {
        RemoveSubchannelResponse.startRemoveSubchannelResponse(builder);
        RemoveSubchannelResponse.addSubchannels(builder, subchannelsOffset);
        return RemoveSubchannelResponse.endRemoveSubchannelResponse(builder);
    }
    unpack() {
        return new RemoveSubchannelResponseT(this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength()));
    }
    unpackTo(_o) {
        _o.subchannels = this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength());
    }
}
exports.RemoveSubchannelResponse = RemoveSubchannelResponse;
class RemoveSubchannelResponseT {
    subchannels;
    constructor(subchannels = []) {
        this.subchannels = subchannels;
    }
    pack(builder) {
        const subchannels = RemoveSubchannelResponse.createSubchannelsVector(builder, this.subchannels);
        return RemoveSubchannelResponse.createRemoveSubchannelResponse(builder, subchannels);
    }
}
exports.RemoveSubchannelResponseT = RemoveSubchannelResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/send-request.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/send-request.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendRequestT = exports.SendRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SendRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSendRequest(bb, obj) {
        return (obj || new SendRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSendRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SendRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ppid() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    data(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSendRequest(builder) {
        builder.startObject(2);
    }
    static addPpid(builder, ppid) {
        builder.addFieldInt32(0, ppid, 0);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endSendRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // data
        return offset;
    }
    static createSendRequest(builder, ppid, dataOffset) {
        SendRequest.startSendRequest(builder);
        SendRequest.addPpid(builder, ppid);
        SendRequest.addData(builder, dataOffset);
        return SendRequest.endSendRequest(builder);
    }
    unpack() {
        return new SendRequestT(this.ppid(), this.bb.createScalarList(this.data.bind(this), this.dataLength()));
    }
    unpackTo(_o) {
        _o.ppid = this.ppid();
        _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());
    }
}
exports.SendRequest = SendRequest;
class SendRequestT {
    ppid;
    data;
    constructor(ppid = 0, data = []) {
        this.ppid = ppid;
        this.data = data;
    }
    pack(builder) {
        const data = SendRequest.createDataVector(builder, this.data);
        return SendRequest.createSendRequest(builder, this.ppid, data);
    }
}
exports.SendRequestT = SendRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-buffered-amount-low-threshold-request.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-buffered-amount-low-threshold-request.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetBufferedAmountLowThresholdRequestT = exports.SetBufferedAmountLowThresholdRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SetBufferedAmountLowThresholdRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetBufferedAmountLowThresholdRequest(bb, obj) {
        return (obj || new SetBufferedAmountLowThresholdRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetBufferedAmountLowThresholdRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetBufferedAmountLowThresholdRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    threshold() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startSetBufferedAmountLowThresholdRequest(builder) {
        builder.startObject(1);
    }
    static addThreshold(builder, threshold) {
        builder.addFieldInt32(0, threshold, 0);
    }
    static endSetBufferedAmountLowThresholdRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSetBufferedAmountLowThresholdRequest(builder, threshold) {
        SetBufferedAmountLowThresholdRequest.startSetBufferedAmountLowThresholdRequest(builder);
        SetBufferedAmountLowThresholdRequest.addThreshold(builder, threshold);
        return SetBufferedAmountLowThresholdRequest.endSetBufferedAmountLowThresholdRequest(builder);
    }
    unpack() {
        return new SetBufferedAmountLowThresholdRequestT(this.threshold());
    }
    unpackTo(_o) {
        _o.threshold = this.threshold();
    }
}
exports.SetBufferedAmountLowThresholdRequest = SetBufferedAmountLowThresholdRequest;
class SetBufferedAmountLowThresholdRequestT {
    threshold;
    constructor(threshold = 0) {
        this.threshold = threshold;
    }
    pack(builder) {
        return SetBufferedAmountLowThresholdRequest.createSetBufferedAmountLowThresholdRequest(builder, this.threshold);
    }
}
exports.SetBufferedAmountLowThresholdRequestT = SetBufferedAmountLowThresholdRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-subchannels-request.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-subchannels-request.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetSubchannelsRequestT = exports.SetSubchannelsRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SetSubchannelsRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetSubchannelsRequest(bb, obj) {
        return (obj || new SetSubchannelsRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetSubchannelsRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetSubchannelsRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    subchannels(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
    }
    subchannelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    subchannelsArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSetSubchannelsRequest(builder) {
        builder.startObject(1);
    }
    static addSubchannels(builder, subchannelsOffset) {
        builder.addFieldOffset(0, subchannelsOffset, 0);
    }
    static createSubchannelsVector(builder, data) {
        builder.startVector(2, data.length, 2);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt16(data[i]);
        }
        return builder.endVector();
    }
    static startSubchannelsVector(builder, numElems) {
        builder.startVector(2, numElems, 2);
    }
    static endSetSubchannelsRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // subchannels
        return offset;
    }
    static createSetSubchannelsRequest(builder, subchannelsOffset) {
        SetSubchannelsRequest.startSetSubchannelsRequest(builder);
        SetSubchannelsRequest.addSubchannels(builder, subchannelsOffset);
        return SetSubchannelsRequest.endSetSubchannelsRequest(builder);
    }
    unpack() {
        return new SetSubchannelsRequestT(this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength()));
    }
    unpackTo(_o) {
        _o.subchannels = this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength());
    }
}
exports.SetSubchannelsRequest = SetSubchannelsRequest;
class SetSubchannelsRequestT {
    subchannels;
    constructor(subchannels = []) {
        this.subchannels = subchannels;
    }
    pack(builder) {
        const subchannels = SetSubchannelsRequest.createSubchannelsVector(builder, this.subchannels);
        return SetSubchannelsRequest.createSetSubchannelsRequest(builder, subchannels);
    }
}
exports.SetSubchannelsRequestT = SetSubchannelsRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-subchannels-response.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-subchannels-response.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetSubchannelsResponseT = exports.SetSubchannelsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SetSubchannelsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetSubchannelsResponse(bb, obj) {
        return (obj || new SetSubchannelsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetSubchannelsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetSubchannelsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    subchannels(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
    }
    subchannelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    subchannelsArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSetSubchannelsResponse(builder) {
        builder.startObject(1);
    }
    static addSubchannels(builder, subchannelsOffset) {
        builder.addFieldOffset(0, subchannelsOffset, 0);
    }
    static createSubchannelsVector(builder, data) {
        builder.startVector(2, data.length, 2);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt16(data[i]);
        }
        return builder.endVector();
    }
    static startSubchannelsVector(builder, numElems) {
        builder.startVector(2, numElems, 2);
    }
    static endSetSubchannelsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // subchannels
        return offset;
    }
    static createSetSubchannelsResponse(builder, subchannelsOffset) {
        SetSubchannelsResponse.startSetSubchannelsResponse(builder);
        SetSubchannelsResponse.addSubchannels(builder, subchannelsOffset);
        return SetSubchannelsResponse.endSetSubchannelsResponse(builder);
    }
    unpack() {
        return new SetSubchannelsResponseT(this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength()));
    }
    unpackTo(_o) {
        _o.subchannels = this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength());
    }
}
exports.SetSubchannelsResponse = SetSubchannelsResponse;
class SetSubchannelsResponseT {
    subchannels;
    constructor(subchannels = []) {
        this.subchannels = subchannels;
    }
    pack(builder) {
        const subchannels = SetSubchannelsResponse.createSubchannelsVector(builder, this.subchannels);
        return SetSubchannelsResponse.createSetSubchannelsResponse(builder, subchannels);
    }
}
exports.SetSubchannelsResponseT = SetSubchannelsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-producer.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-producer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Type = exports.SendNotificationT = exports.SendNotification = exports.GetStatsResponseT = exports.GetStatsResponse = exports.DumpResponseT = exports.DumpResponse = void 0;
var dump_response_1 = __webpack_require__(/*! ./data-producer/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var get_stats_response_1 = __webpack_require__(/*! ./data-producer/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/get-stats-response.js");
Object.defineProperty(exports, "GetStatsResponse", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponse; } }));
Object.defineProperty(exports, "GetStatsResponseT", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponseT; } }));
var send_notification_1 = __webpack_require__(/*! ./data-producer/send-notification */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/send-notification.js");
Object.defineProperty(exports, "SendNotification", ({ enumerable: true, get: function () { return send_notification_1.SendNotification; } }));
Object.defineProperty(exports, "SendNotificationT", ({ enumerable: true, get: function () { return send_notification_1.SendNotificationT; } }));
var type_1 = __webpack_require__(/*! ./data-producer/type */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/type.js");
Object.defineProperty(exports, "Type", ({ enumerable: true, get: function () { return type_1.Type; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-producer/dump-response.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-producer/dump-response.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const type_1 = __webpack_require__(/*! ../../fbs/data-producer/type */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/type.js");
const sctp_stream_parameters_1 = __webpack_require__(/*! ../../fbs/sctp-parameters/sctp-stream-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-stream-parameters.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_1.Type.SCTP;
    }
    sctpStreamParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new sctp_stream_parameters_1.SctpStreamParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    label(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    protocol(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDumpResponse(builder) {
        builder.startObject(6);
    }
    static addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    }
    static addType(builder, type) {
        builder.addFieldInt8(1, type, type_1.Type.SCTP);
    }
    static addSctpStreamParameters(builder, sctpStreamParametersOffset) {
        builder.addFieldOffset(2, sctpStreamParametersOffset, 0);
    }
    static addLabel(builder, labelOffset) {
        builder.addFieldOffset(3, labelOffset, 0);
    }
    static addProtocol(builder, protocolOffset) {
        builder.addFieldOffset(4, protocolOffset, 0);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(5, +paused, +false);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // id
        builder.requiredField(offset, 10); // label
        builder.requiredField(offset, 12); // protocol
        return offset;
    }
    unpack() {
        return new DumpResponseT(this.id(), this.type(), (this.sctpStreamParameters() !== null ? this.sctpStreamParameters().unpack() : null), this.label(), this.protocol(), this.paused());
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.type = this.type();
        _o.sctpStreamParameters = (this.sctpStreamParameters() !== null ? this.sctpStreamParameters().unpack() : null);
        _o.label = this.label();
        _o.protocol = this.protocol();
        _o.paused = this.paused();
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    id;
    type;
    sctpStreamParameters;
    label;
    protocol;
    paused;
    constructor(id = null, type = type_1.Type.SCTP, sctpStreamParameters = null, label = null, protocol = null, paused = false) {
        this.id = id;
        this.type = type;
        this.sctpStreamParameters = sctpStreamParameters;
        this.label = label;
        this.protocol = protocol;
        this.paused = paused;
    }
    pack(builder) {
        const id = (this.id !== null ? builder.createString(this.id) : 0);
        const sctpStreamParameters = (this.sctpStreamParameters !== null ? this.sctpStreamParameters.pack(builder) : 0);
        const label = (this.label !== null ? builder.createString(this.label) : 0);
        const protocol = (this.protocol !== null ? builder.createString(this.protocol) : 0);
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addId(builder, id);
        DumpResponse.addType(builder, this.type);
        DumpResponse.addSctpStreamParameters(builder, sctpStreamParameters);
        DumpResponse.addLabel(builder, label);
        DumpResponse.addProtocol(builder, protocol);
        DumpResponse.addPaused(builder, this.paused);
        return DumpResponse.endDumpResponse(builder);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-producer/get-stats-response.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-producer/get-stats-response.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStatsResponseT = exports.GetStatsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class GetStatsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetStatsResponse(bb, obj) {
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetStatsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    timestamp() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    label(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    protocol(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    messagesReceived() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    bytesReceived() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    bufferedAmount() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startGetStatsResponse(builder) {
        builder.startObject(6);
    }
    static addTimestamp(builder, timestamp) {
        builder.addFieldInt64(0, timestamp, BigInt('0'));
    }
    static addLabel(builder, labelOffset) {
        builder.addFieldOffset(1, labelOffset, 0);
    }
    static addProtocol(builder, protocolOffset) {
        builder.addFieldOffset(2, protocolOffset, 0);
    }
    static addMessagesReceived(builder, messagesReceived) {
        builder.addFieldInt64(3, messagesReceived, BigInt('0'));
    }
    static addBytesReceived(builder, bytesReceived) {
        builder.addFieldInt64(4, bytesReceived, BigInt('0'));
    }
    static addBufferedAmount(builder, bufferedAmount) {
        builder.addFieldInt32(5, bufferedAmount, 0);
    }
    static endGetStatsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // label
        builder.requiredField(offset, 8); // protocol
        return offset;
    }
    static createGetStatsResponse(builder, timestamp, labelOffset, protocolOffset, messagesReceived, bytesReceived, bufferedAmount) {
        GetStatsResponse.startGetStatsResponse(builder);
        GetStatsResponse.addTimestamp(builder, timestamp);
        GetStatsResponse.addLabel(builder, labelOffset);
        GetStatsResponse.addProtocol(builder, protocolOffset);
        GetStatsResponse.addMessagesReceived(builder, messagesReceived);
        GetStatsResponse.addBytesReceived(builder, bytesReceived);
        GetStatsResponse.addBufferedAmount(builder, bufferedAmount);
        return GetStatsResponse.endGetStatsResponse(builder);
    }
    unpack() {
        return new GetStatsResponseT(this.timestamp(), this.label(), this.protocol(), this.messagesReceived(), this.bytesReceived(), this.bufferedAmount());
    }
    unpackTo(_o) {
        _o.timestamp = this.timestamp();
        _o.label = this.label();
        _o.protocol = this.protocol();
        _o.messagesReceived = this.messagesReceived();
        _o.bytesReceived = this.bytesReceived();
        _o.bufferedAmount = this.bufferedAmount();
    }
}
exports.GetStatsResponse = GetStatsResponse;
class GetStatsResponseT {
    timestamp;
    label;
    protocol;
    messagesReceived;
    bytesReceived;
    bufferedAmount;
    constructor(timestamp = BigInt('0'), label = null, protocol = null, messagesReceived = BigInt('0'), bytesReceived = BigInt('0'), bufferedAmount = 0) {
        this.timestamp = timestamp;
        this.label = label;
        this.protocol = protocol;
        this.messagesReceived = messagesReceived;
        this.bytesReceived = bytesReceived;
        this.bufferedAmount = bufferedAmount;
    }
    pack(builder) {
        const label = (this.label !== null ? builder.createString(this.label) : 0);
        const protocol = (this.protocol !== null ? builder.createString(this.protocol) : 0);
        return GetStatsResponse.createGetStatsResponse(builder, this.timestamp, label, protocol, this.messagesReceived, this.bytesReceived, this.bufferedAmount);
    }
}
exports.GetStatsResponseT = GetStatsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-producer/send-notification.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-producer/send-notification.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendNotificationT = exports.SendNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SendNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSendNotification(bb, obj) {
        return (obj || new SendNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSendNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SendNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ppid() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    data(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    subchannels(index) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
    }
    subchannelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    subchannelsArray() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    requiredSubchannel() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : null;
    }
    static startSendNotification(builder) {
        builder.startObject(4);
    }
    static addPpid(builder, ppid) {
        builder.addFieldInt32(0, ppid, 0);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addSubchannels(builder, subchannelsOffset) {
        builder.addFieldOffset(2, subchannelsOffset, 0);
    }
    static createSubchannelsVector(builder, data) {
        builder.startVector(2, data.length, 2);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt16(data[i]);
        }
        return builder.endVector();
    }
    static startSubchannelsVector(builder, numElems) {
        builder.startVector(2, numElems, 2);
    }
    static addRequiredSubchannel(builder, requiredSubchannel) {
        builder.addFieldInt16(3, requiredSubchannel, 0);
    }
    static endSendNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // data
        return offset;
    }
    static createSendNotification(builder, ppid, dataOffset, subchannelsOffset, requiredSubchannel) {
        SendNotification.startSendNotification(builder);
        SendNotification.addPpid(builder, ppid);
        SendNotification.addData(builder, dataOffset);
        SendNotification.addSubchannels(builder, subchannelsOffset);
        if (requiredSubchannel !== null)
            SendNotification.addRequiredSubchannel(builder, requiredSubchannel);
        return SendNotification.endSendNotification(builder);
    }
    unpack() {
        return new SendNotificationT(this.ppid(), this.bb.createScalarList(this.data.bind(this), this.dataLength()), this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength()), this.requiredSubchannel());
    }
    unpackTo(_o) {
        _o.ppid = this.ppid();
        _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());
        _o.subchannels = this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength());
        _o.requiredSubchannel = this.requiredSubchannel();
    }
}
exports.SendNotification = SendNotification;
class SendNotificationT {
    ppid;
    data;
    subchannels;
    requiredSubchannel;
    constructor(ppid = 0, data = [], subchannels = [], requiredSubchannel = null) {
        this.ppid = ppid;
        this.data = data;
        this.subchannels = subchannels;
        this.requiredSubchannel = requiredSubchannel;
    }
    pack(builder) {
        const data = SendNotification.createDataVector(builder, this.data);
        const subchannels = SendNotification.createSubchannelsVector(builder, this.subchannels);
        return SendNotification.createSendNotification(builder, this.ppid, data, subchannels, this.requiredSubchannel);
    }
}
exports.SendNotificationT = SendNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/data-producer/type.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/data-producer/type.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Type = void 0;
var Type;
(function (Type) {
    Type[Type["SCTP"] = 0] = "SCTP";
    Type[Type["DIRECT"] = 1] = "DIRECT";
})(Type || (exports.Type = Type = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/direct-transport.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/direct-transport.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtcpNotificationT = exports.RtcpNotification = exports.GetStatsResponseT = exports.GetStatsResponse = exports.DumpResponseT = exports.DumpResponse = exports.DirectTransportOptionsT = exports.DirectTransportOptions = void 0;
var direct_transport_options_1 = __webpack_require__(/*! ./direct-transport/direct-transport-options */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/direct-transport-options.js");
Object.defineProperty(exports, "DirectTransportOptions", ({ enumerable: true, get: function () { return direct_transport_options_1.DirectTransportOptions; } }));
Object.defineProperty(exports, "DirectTransportOptionsT", ({ enumerable: true, get: function () { return direct_transport_options_1.DirectTransportOptionsT; } }));
var dump_response_1 = __webpack_require__(/*! ./direct-transport/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var get_stats_response_1 = __webpack_require__(/*! ./direct-transport/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/get-stats-response.js");
Object.defineProperty(exports, "GetStatsResponse", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponse; } }));
Object.defineProperty(exports, "GetStatsResponseT", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponseT; } }));
var rtcp_notification_1 = __webpack_require__(/*! ./direct-transport/rtcp-notification */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/rtcp-notification.js");
Object.defineProperty(exports, "RtcpNotification", ({ enumerable: true, get: function () { return rtcp_notification_1.RtcpNotification; } }));
Object.defineProperty(exports, "RtcpNotificationT", ({ enumerable: true, get: function () { return rtcp_notification_1.RtcpNotificationT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/direct-transport-options.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/direct-transport/direct-transport-options.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirectTransportOptionsT = exports.DirectTransportOptions = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const options_1 = __webpack_require__(/*! ../../fbs/transport/options */ "../../node_modules/mediasoup/node/lib/fbs/transport/options.js");
class DirectTransportOptions {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDirectTransportOptions(bb, obj) {
        return (obj || new DirectTransportOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDirectTransportOptions(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DirectTransportOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new options_1.Options()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startDirectTransportOptions(builder) {
        builder.startObject(1);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static endDirectTransportOptions(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        return offset;
    }
    static createDirectTransportOptions(builder, baseOffset) {
        DirectTransportOptions.startDirectTransportOptions(builder);
        DirectTransportOptions.addBase(builder, baseOffset);
        return DirectTransportOptions.endDirectTransportOptions(builder);
    }
    unpack() {
        return new DirectTransportOptionsT((this.base() !== null ? this.base().unpack() : null));
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
    }
}
exports.DirectTransportOptions = DirectTransportOptions;
class DirectTransportOptionsT {
    base;
    constructor(base = null) {
        this.base = base;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        return DirectTransportOptions.createDirectTransportOptions(builder, base);
    }
}
exports.DirectTransportOptionsT = DirectTransportOptionsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/dump-response.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/direct-transport/dump-response.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dump_1 = __webpack_require__(/*! ../../fbs/transport/dump */ "../../node_modules/mediasoup/node/lib/fbs/transport/dump.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startDumpResponse(builder) {
        builder.startObject(1);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        return offset;
    }
    static createDumpResponse(builder, baseOffset) {
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addBase(builder, baseOffset);
        return DumpResponse.endDumpResponse(builder);
    }
    unpack() {
        return new DumpResponseT((this.base() !== null ? this.base().unpack() : null));
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    base;
    constructor(base = null) {
        this.base = base;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        return DumpResponse.createDumpResponse(builder, base);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/get-stats-response.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/direct-transport/get-stats-response.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStatsResponseT = exports.GetStatsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const stats_1 = __webpack_require__(/*! ../../fbs/transport/stats */ "../../node_modules/mediasoup/node/lib/fbs/transport/stats.js");
class GetStatsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetStatsResponse(bb, obj) {
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetStatsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new stats_1.Stats()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startGetStatsResponse(builder) {
        builder.startObject(1);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static endGetStatsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        return offset;
    }
    static createGetStatsResponse(builder, baseOffset) {
        GetStatsResponse.startGetStatsResponse(builder);
        GetStatsResponse.addBase(builder, baseOffset);
        return GetStatsResponse.endGetStatsResponse(builder);
    }
    unpack() {
        return new GetStatsResponseT((this.base() !== null ? this.base().unpack() : null));
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
    }
}
exports.GetStatsResponse = GetStatsResponse;
class GetStatsResponseT {
    base;
    constructor(base = null) {
        this.base = base;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        return GetStatsResponse.createGetStatsResponse(builder, base);
    }
}
exports.GetStatsResponseT = GetStatsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/rtcp-notification.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/direct-transport/rtcp-notification.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtcpNotificationT = exports.RtcpNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RtcpNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtcpNotification(bb, obj) {
        return (obj || new RtcpNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtcpNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtcpNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    data(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startRtcpNotification(builder) {
        builder.startObject(1);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(0, dataOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endRtcpNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data
        return offset;
    }
    static createRtcpNotification(builder, dataOffset) {
        RtcpNotification.startRtcpNotification(builder);
        RtcpNotification.addData(builder, dataOffset);
        return RtcpNotification.endRtcpNotification(builder);
    }
    unpack() {
        return new RtcpNotificationT(this.bb.createScalarList(this.data.bind(this), this.dataLength()));
    }
    unpackTo(_o) {
        _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());
    }
}
exports.RtcpNotification = RtcpNotification;
class RtcpNotificationT {
    data;
    constructor(data = []) {
        this.data = data;
    }
    pack(builder) {
        const data = RtcpNotification.createDataVector(builder, this.data);
        return RtcpNotification.createRtcpNotification(builder, data);
    }
}
exports.RtcpNotificationT = RtcpNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/lib-uring/dump.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/lib-uring/dump.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpT = exports.Dump = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Dump {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDump(bb, obj) {
        return (obj || new Dump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDump(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Dump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    sqeProcessCount() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    sqeMissCount() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    userDataMissCount() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    static startDump(builder) {
        builder.startObject(3);
    }
    static addSqeProcessCount(builder, sqeProcessCount) {
        builder.addFieldInt64(0, sqeProcessCount, BigInt('0'));
    }
    static addSqeMissCount(builder, sqeMissCount) {
        builder.addFieldInt64(1, sqeMissCount, BigInt('0'));
    }
    static addUserDataMissCount(builder, userDataMissCount) {
        builder.addFieldInt64(2, userDataMissCount, BigInt('0'));
    }
    static endDump(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDump(builder, sqeProcessCount, sqeMissCount, userDataMissCount) {
        Dump.startDump(builder);
        Dump.addSqeProcessCount(builder, sqeProcessCount);
        Dump.addSqeMissCount(builder, sqeMissCount);
        Dump.addUserDataMissCount(builder, userDataMissCount);
        return Dump.endDump(builder);
    }
    unpack() {
        return new DumpT(this.sqeProcessCount(), this.sqeMissCount(), this.userDataMissCount());
    }
    unpackTo(_o) {
        _o.sqeProcessCount = this.sqeProcessCount();
        _o.sqeMissCount = this.sqeMissCount();
        _o.userDataMissCount = this.userDataMissCount();
    }
}
exports.Dump = Dump;
class DumpT {
    sqeProcessCount;
    sqeMissCount;
    userDataMissCount;
    constructor(sqeProcessCount = BigInt('0'), sqeMissCount = BigInt('0'), userDataMissCount = BigInt('0')) {
        this.sqeProcessCount = sqeProcessCount;
        this.sqeMissCount = sqeMissCount;
        this.userDataMissCount = userDataMissCount;
    }
    pack(builder) {
        return Dump.createDump(builder, this.sqeProcessCount, this.sqeMissCount, this.userDataMissCount);
    }
}
exports.DumpT = DumpT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/log.js":
/*!********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/log.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogT = exports.Log = void 0;
var log_1 = __webpack_require__(/*! ./log/log */ "../../node_modules/mediasoup/node/lib/fbs/log/log.js");
Object.defineProperty(exports, "Log", ({ enumerable: true, get: function () { return log_1.Log; } }));
Object.defineProperty(exports, "LogT", ({ enumerable: true, get: function () { return log_1.LogT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/log/log.js":
/*!************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/log/log.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogT = exports.Log = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Log {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLog(bb, obj) {
        return (obj || new Log()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLog(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Log()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    data(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startLog(builder) {
        builder.startObject(1);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(0, dataOffset, 0);
    }
    static endLog(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data
        return offset;
    }
    static createLog(builder, dataOffset) {
        Log.startLog(builder);
        Log.addData(builder, dataOffset);
        return Log.endLog(builder);
    }
    unpack() {
        return new LogT(this.data());
    }
    unpackTo(_o) {
        _o.data = this.data();
    }
}
exports.Log = Log;
class LogT {
    data;
    constructor(data = null) {
        this.data = data;
    }
    pack(builder) {
        const data = (this.data !== null ? builder.createString(this.data) : 0);
        return Log.createLog(builder, data);
    }
}
exports.LogT = LogT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/message.js":
/*!************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/message.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageT = exports.Message = exports.Body = void 0;
var body_1 = __webpack_require__(/*! ./message/body */ "../../node_modules/mediasoup/node/lib/fbs/message/body.js");
Object.defineProperty(exports, "Body", ({ enumerable: true, get: function () { return body_1.Body; } }));
var message_1 = __webpack_require__(/*! ./message/message */ "../../node_modules/mediasoup/node/lib/fbs/message/message.js");
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return message_1.Message; } }));
Object.defineProperty(exports, "MessageT", ({ enumerable: true, get: function () { return message_1.MessageT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/message/body.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/message/body.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToBody = exports.unionToBody = exports.Body = void 0;
const log_1 = __webpack_require__(/*! ../../fbs/log/log */ "../../node_modules/mediasoup/node/lib/fbs/log/log.js");
const notification_1 = __webpack_require__(/*! ../../fbs/notification/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification/notification.js");
const request_1 = __webpack_require__(/*! ../../fbs/request/request */ "../../node_modules/mediasoup/node/lib/fbs/request/request.js");
const response_1 = __webpack_require__(/*! ../../fbs/response/response */ "../../node_modules/mediasoup/node/lib/fbs/response/response.js");
var Body;
(function (Body) {
    Body[Body["NONE"] = 0] = "NONE";
    Body[Body["Request"] = 1] = "Request";
    Body[Body["Response"] = 2] = "Response";
    Body[Body["Notification"] = 3] = "Notification";
    Body[Body["Log"] = 4] = "Log";
})(Body || (exports.Body = Body = {}));
function unionToBody(type, accessor) {
    switch (Body[type]) {
        case 'NONE': return null;
        case 'Request': return accessor(new request_1.Request());
        case 'Response': return accessor(new response_1.Response());
        case 'Notification': return accessor(new notification_1.Notification());
        case 'Log': return accessor(new log_1.Log());
        default: return null;
    }
}
exports.unionToBody = unionToBody;
function unionListToBody(type, accessor, index) {
    switch (Body[type]) {
        case 'NONE': return null;
        case 'Request': return accessor(index, new request_1.Request());
        case 'Response': return accessor(index, new response_1.Response());
        case 'Notification': return accessor(index, new notification_1.Notification());
        case 'Log': return accessor(index, new log_1.Log());
        default: return null;
    }
}
exports.unionListToBody = unionListToBody;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/message/message.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/message/message.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageT = exports.Message = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const body_1 = __webpack_require__(/*! ../../fbs/message/body */ "../../node_modules/mediasoup/node/lib/fbs/message/body.js");
class Message {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMessage(bb, obj) {
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dataType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : body_1.Body.NONE;
    }
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startMessage(builder) {
        builder.startObject(2);
    }
    static addDataType(builder, dataType) {
        builder.addFieldInt8(0, dataType, body_1.Body.NONE);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static endMessage(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // data
        return offset;
    }
    static finishMessageBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createMessage(builder, dataType, dataOffset) {
        Message.startMessage(builder);
        Message.addDataType(builder, dataType);
        Message.addData(builder, dataOffset);
        return Message.endMessage(builder);
    }
    unpack() {
        return new MessageT(this.dataType(), (() => {
            const temp = (0, body_1.unionToBody)(this.dataType(), this.data.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.dataType = this.dataType();
        _o.data = (() => {
            const temp = (0, body_1.unionToBody)(this.dataType(), this.data.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
exports.Message = Message;
class MessageT {
    dataType;
    data;
    constructor(dataType = body_1.Body.NONE, data = null) {
        this.dataType = dataType;
        this.data = data;
    }
    pack(builder) {
        const data = builder.createObjectOffset(this.data);
        return Message.createMessage(builder, this.dataType, data);
    }
}
exports.MessageT = MessageT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/notification.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/notification.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationT = exports.Notification = exports.Event = exports.Body = void 0;
var body_1 = __webpack_require__(/*! ./notification/body */ "../../node_modules/mediasoup/node/lib/fbs/notification/body.js");
Object.defineProperty(exports, "Body", ({ enumerable: true, get: function () { return body_1.Body; } }));
var event_1 = __webpack_require__(/*! ./notification/event */ "../../node_modules/mediasoup/node/lib/fbs/notification/event.js");
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return event_1.Event; } }));
var notification_1 = __webpack_require__(/*! ./notification/notification */ "../../node_modules/mediasoup/node/lib/fbs/notification/notification.js");
Object.defineProperty(exports, "Notification", ({ enumerable: true, get: function () { return notification_1.Notification; } }));
Object.defineProperty(exports, "NotificationT", ({ enumerable: true, get: function () { return notification_1.NotificationT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/notification/body.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/notification/body.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToBody = exports.unionToBody = exports.Body = void 0;
const dominant_speaker_notification_1 = __webpack_require__(/*! ../../fbs/active-speaker-observer/dominant-speaker-notification */ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer/dominant-speaker-notification.js");
const volumes_notification_1 = __webpack_require__(/*! ../../fbs/audio-level-observer/volumes-notification */ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/volumes-notification.js");
const layers_change_notification_1 = __webpack_require__(/*! ../../fbs/consumer/layers-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/consumer/layers-change-notification.js");
const rtp_notification_1 = __webpack_require__(/*! ../../fbs/consumer/rtp-notification */ "../../node_modules/mediasoup/node/lib/fbs/consumer/rtp-notification.js");
const score_notification_1 = __webpack_require__(/*! ../../fbs/consumer/score-notification */ "../../node_modules/mediasoup/node/lib/fbs/consumer/score-notification.js");
const trace_notification_1 = __webpack_require__(/*! ../../fbs/consumer/trace-notification */ "../../node_modules/mediasoup/node/lib/fbs/consumer/trace-notification.js");
const buffered_amount_low_notification_1 = __webpack_require__(/*! ../../fbs/data-consumer/buffered-amount-low-notification */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/buffered-amount-low-notification.js");
const message_notification_1 = __webpack_require__(/*! ../../fbs/data-consumer/message-notification */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/message-notification.js");
const send_notification_1 = __webpack_require__(/*! ../../fbs/data-producer/send-notification */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/send-notification.js");
const rtcp_notification_1 = __webpack_require__(/*! ../../fbs/direct-transport/rtcp-notification */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/rtcp-notification.js");
const rtcp_tuple_notification_1 = __webpack_require__(/*! ../../fbs/plain-transport/rtcp-tuple-notification */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/rtcp-tuple-notification.js");
const tuple_notification_1 = __webpack_require__(/*! ../../fbs/plain-transport/tuple-notification */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/tuple-notification.js");
const score_notification_2 = __webpack_require__(/*! ../../fbs/producer/score-notification */ "../../node_modules/mediasoup/node/lib/fbs/producer/score-notification.js");
const send_notification_2 = __webpack_require__(/*! ../../fbs/producer/send-notification */ "../../node_modules/mediasoup/node/lib/fbs/producer/send-notification.js");
const trace_notification_2 = __webpack_require__(/*! ../../fbs/producer/trace-notification */ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-notification.js");
const video_orientation_change_notification_1 = __webpack_require__(/*! ../../fbs/producer/video-orientation-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/producer/video-orientation-change-notification.js");
const sctp_state_change_notification_1 = __webpack_require__(/*! ../../fbs/transport/sctp-state-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/transport/sctp-state-change-notification.js");
const send_rtcp_notification_1 = __webpack_require__(/*! ../../fbs/transport/send-rtcp-notification */ "../../node_modules/mediasoup/node/lib/fbs/transport/send-rtcp-notification.js");
const trace_notification_3 = __webpack_require__(/*! ../../fbs/transport/trace-notification */ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-notification.js");
const dtls_state_change_notification_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dtls-state-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state-change-notification.js");
const ice_selected_tuple_change_notification_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-selected-tuple-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-selected-tuple-change-notification.js");
const ice_state_change_notification_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-state-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state-change-notification.js");
var Body;
(function (Body) {
    Body[Body["NONE"] = 0] = "NONE";
    Body[Body["Transport_SendRtcpNotification"] = 1] = "Transport_SendRtcpNotification";
    Body[Body["Transport_SctpStateChangeNotification"] = 2] = "Transport_SctpStateChangeNotification";
    Body[Body["Producer_SendNotification"] = 3] = "Producer_SendNotification";
    Body[Body["DataProducer_SendNotification"] = 4] = "DataProducer_SendNotification";
    Body[Body["Transport_TraceNotification"] = 5] = "Transport_TraceNotification";
    Body[Body["WebRtcTransport_IceSelectedTupleChangeNotification"] = 6] = "WebRtcTransport_IceSelectedTupleChangeNotification";
    Body[Body["WebRtcTransport_IceStateChangeNotification"] = 7] = "WebRtcTransport_IceStateChangeNotification";
    Body[Body["WebRtcTransport_DtlsStateChangeNotification"] = 8] = "WebRtcTransport_DtlsStateChangeNotification";
    Body[Body["PlainTransport_TupleNotification"] = 9] = "PlainTransport_TupleNotification";
    Body[Body["PlainTransport_RtcpTupleNotification"] = 10] = "PlainTransport_RtcpTupleNotification";
    Body[Body["DirectTransport_RtcpNotification"] = 11] = "DirectTransport_RtcpNotification";
    Body[Body["Producer_ScoreNotification"] = 12] = "Producer_ScoreNotification";
    Body[Body["Producer_TraceNotification"] = 13] = "Producer_TraceNotification";
    Body[Body["Producer_VideoOrientationChangeNotification"] = 14] = "Producer_VideoOrientationChangeNotification";
    Body[Body["Consumer_LayersChangeNotification"] = 15] = "Consumer_LayersChangeNotification";
    Body[Body["Consumer_RtpNotification"] = 16] = "Consumer_RtpNotification";
    Body[Body["Consumer_ScoreNotification"] = 17] = "Consumer_ScoreNotification";
    Body[Body["Consumer_TraceNotification"] = 18] = "Consumer_TraceNotification";
    Body[Body["DataConsumer_MessageNotification"] = 19] = "DataConsumer_MessageNotification";
    Body[Body["DataConsumer_BufferedAmountLowNotification"] = 20] = "DataConsumer_BufferedAmountLowNotification";
    Body[Body["ActiveSpeakerObserver_DominantSpeakerNotification"] = 21] = "ActiveSpeakerObserver_DominantSpeakerNotification";
    Body[Body["AudioLevelObserver_VolumesNotification"] = 22] = "AudioLevelObserver_VolumesNotification";
})(Body || (exports.Body = Body = {}));
function unionToBody(type, accessor) {
    switch (Body[type]) {
        case 'NONE': return null;
        case 'Transport_SendRtcpNotification': return accessor(new send_rtcp_notification_1.SendRtcpNotification());
        case 'Transport_SctpStateChangeNotification': return accessor(new sctp_state_change_notification_1.SctpStateChangeNotification());
        case 'Producer_SendNotification': return accessor(new send_notification_2.SendNotification());
        case 'DataProducer_SendNotification': return accessor(new send_notification_1.SendNotification());
        case 'Transport_TraceNotification': return accessor(new trace_notification_3.TraceNotification());
        case 'WebRtcTransport_IceSelectedTupleChangeNotification': return accessor(new ice_selected_tuple_change_notification_1.IceSelectedTupleChangeNotification());
        case 'WebRtcTransport_IceStateChangeNotification': return accessor(new ice_state_change_notification_1.IceStateChangeNotification());
        case 'WebRtcTransport_DtlsStateChangeNotification': return accessor(new dtls_state_change_notification_1.DtlsStateChangeNotification());
        case 'PlainTransport_TupleNotification': return accessor(new tuple_notification_1.TupleNotification());
        case 'PlainTransport_RtcpTupleNotification': return accessor(new rtcp_tuple_notification_1.RtcpTupleNotification());
        case 'DirectTransport_RtcpNotification': return accessor(new rtcp_notification_1.RtcpNotification());
        case 'Producer_ScoreNotification': return accessor(new score_notification_2.ScoreNotification());
        case 'Producer_TraceNotification': return accessor(new trace_notification_2.TraceNotification());
        case 'Producer_VideoOrientationChangeNotification': return accessor(new video_orientation_change_notification_1.VideoOrientationChangeNotification());
        case 'Consumer_LayersChangeNotification': return accessor(new layers_change_notification_1.LayersChangeNotification());
        case 'Consumer_RtpNotification': return accessor(new rtp_notification_1.RtpNotification());
        case 'Consumer_ScoreNotification': return accessor(new score_notification_1.ScoreNotification());
        case 'Consumer_TraceNotification': return accessor(new trace_notification_1.TraceNotification());
        case 'DataConsumer_MessageNotification': return accessor(new message_notification_1.MessageNotification());
        case 'DataConsumer_BufferedAmountLowNotification': return accessor(new buffered_amount_low_notification_1.BufferedAmountLowNotification());
        case 'ActiveSpeakerObserver_DominantSpeakerNotification': return accessor(new dominant_speaker_notification_1.DominantSpeakerNotification());
        case 'AudioLevelObserver_VolumesNotification': return accessor(new volumes_notification_1.VolumesNotification());
        default: return null;
    }
}
exports.unionToBody = unionToBody;
function unionListToBody(type, accessor, index) {
    switch (Body[type]) {
        case 'NONE': return null;
        case 'Transport_SendRtcpNotification': return accessor(index, new send_rtcp_notification_1.SendRtcpNotification());
        case 'Transport_SctpStateChangeNotification': return accessor(index, new sctp_state_change_notification_1.SctpStateChangeNotification());
        case 'Producer_SendNotification': return accessor(index, new send_notification_2.SendNotification());
        case 'DataProducer_SendNotification': return accessor(index, new send_notification_1.SendNotification());
        case 'Transport_TraceNotification': return accessor(index, new trace_notification_3.TraceNotification());
        case 'WebRtcTransport_IceSelectedTupleChangeNotification': return accessor(index, new ice_selected_tuple_change_notification_1.IceSelectedTupleChangeNotification());
        case 'WebRtcTransport_IceStateChangeNotification': return accessor(index, new ice_state_change_notification_1.IceStateChangeNotification());
        case 'WebRtcTransport_DtlsStateChangeNotification': return accessor(index, new dtls_state_change_notification_1.DtlsStateChangeNotification());
        case 'PlainTransport_TupleNotification': return accessor(index, new tuple_notification_1.TupleNotification());
        case 'PlainTransport_RtcpTupleNotification': return accessor(index, new rtcp_tuple_notification_1.RtcpTupleNotification());
        case 'DirectTransport_RtcpNotification': return accessor(index, new rtcp_notification_1.RtcpNotification());
        case 'Producer_ScoreNotification': return accessor(index, new score_notification_2.ScoreNotification());
        case 'Producer_TraceNotification': return accessor(index, new trace_notification_2.TraceNotification());
        case 'Producer_VideoOrientationChangeNotification': return accessor(index, new video_orientation_change_notification_1.VideoOrientationChangeNotification());
        case 'Consumer_LayersChangeNotification': return accessor(index, new layers_change_notification_1.LayersChangeNotification());
        case 'Consumer_RtpNotification': return accessor(index, new rtp_notification_1.RtpNotification());
        case 'Consumer_ScoreNotification': return accessor(index, new score_notification_1.ScoreNotification());
        case 'Consumer_TraceNotification': return accessor(index, new trace_notification_1.TraceNotification());
        case 'DataConsumer_MessageNotification': return accessor(index, new message_notification_1.MessageNotification());
        case 'DataConsumer_BufferedAmountLowNotification': return accessor(index, new buffered_amount_low_notification_1.BufferedAmountLowNotification());
        case 'ActiveSpeakerObserver_DominantSpeakerNotification': return accessor(index, new dominant_speaker_notification_1.DominantSpeakerNotification());
        case 'AudioLevelObserver_VolumesNotification': return accessor(index, new volumes_notification_1.VolumesNotification());
        default: return null;
    }
}
exports.unionListToBody = unionListToBody;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/notification/event.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/notification/event.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Event = void 0;
var Event;
(function (Event) {
    Event[Event["TRANSPORT_SEND_RTCP"] = 0] = "TRANSPORT_SEND_RTCP";
    Event[Event["PRODUCER_SEND"] = 1] = "PRODUCER_SEND";
    Event[Event["DATAPRODUCER_SEND"] = 2] = "DATAPRODUCER_SEND";
    Event[Event["WORKER_RUNNING"] = 3] = "WORKER_RUNNING";
    Event[Event["TRANSPORT_SCTP_STATE_CHANGE"] = 4] = "TRANSPORT_SCTP_STATE_CHANGE";
    Event[Event["TRANSPORT_TRACE"] = 5] = "TRANSPORT_TRACE";
    Event[Event["WEBRTCTRANSPORT_ICE_SELECTED_TUPLE_CHANGE"] = 6] = "WEBRTCTRANSPORT_ICE_SELECTED_TUPLE_CHANGE";
    Event[Event["WEBRTCTRANSPORT_ICE_STATE_CHANGE"] = 7] = "WEBRTCTRANSPORT_ICE_STATE_CHANGE";
    Event[Event["WEBRTCTRANSPORT_DTLS_STATE_CHANGE"] = 8] = "WEBRTCTRANSPORT_DTLS_STATE_CHANGE";
    Event[Event["PLAINTRANSPORT_TUPLE"] = 9] = "PLAINTRANSPORT_TUPLE";
    Event[Event["PLAINTRANSPORT_RTCP_TUPLE"] = 10] = "PLAINTRANSPORT_RTCP_TUPLE";
    Event[Event["DIRECTTRANSPORT_RTCP"] = 11] = "DIRECTTRANSPORT_RTCP";
    Event[Event["PRODUCER_SCORE"] = 12] = "PRODUCER_SCORE";
    Event[Event["PRODUCER_TRACE"] = 13] = "PRODUCER_TRACE";
    Event[Event["PRODUCER_VIDEO_ORIENTATION_CHANGE"] = 14] = "PRODUCER_VIDEO_ORIENTATION_CHANGE";
    Event[Event["CONSUMER_PRODUCER_PAUSE"] = 15] = "CONSUMER_PRODUCER_PAUSE";
    Event[Event["CONSUMER_PRODUCER_RESUME"] = 16] = "CONSUMER_PRODUCER_RESUME";
    Event[Event["CONSUMER_PRODUCER_CLOSE"] = 17] = "CONSUMER_PRODUCER_CLOSE";
    Event[Event["CONSUMER_LAYERS_CHANGE"] = 18] = "CONSUMER_LAYERS_CHANGE";
    Event[Event["CONSUMER_RTP"] = 19] = "CONSUMER_RTP";
    Event[Event["CONSUMER_SCORE"] = 20] = "CONSUMER_SCORE";
    Event[Event["CONSUMER_TRACE"] = 21] = "CONSUMER_TRACE";
    Event[Event["DATACONSUMER_BUFFERED_AMOUNT_LOW"] = 22] = "DATACONSUMER_BUFFERED_AMOUNT_LOW";
    Event[Event["DATACONSUMER_SCTP_SENDBUFFER_FULL"] = 23] = "DATACONSUMER_SCTP_SENDBUFFER_FULL";
    Event[Event["DATACONSUMER_DATAPRODUCER_PAUSE"] = 24] = "DATACONSUMER_DATAPRODUCER_PAUSE";
    Event[Event["DATACONSUMER_DATAPRODUCER_RESUME"] = 25] = "DATACONSUMER_DATAPRODUCER_RESUME";
    Event[Event["DATACONSUMER_DATAPRODUCER_CLOSE"] = 26] = "DATACONSUMER_DATAPRODUCER_CLOSE";
    Event[Event["DATACONSUMER_MESSAGE"] = 27] = "DATACONSUMER_MESSAGE";
    Event[Event["ACTIVESPEAKEROBSERVER_DOMINANT_SPEAKER"] = 28] = "ACTIVESPEAKEROBSERVER_DOMINANT_SPEAKER";
    Event[Event["AUDIOLEVELOBSERVER_SILENCE"] = 29] = "AUDIOLEVELOBSERVER_SILENCE";
    Event[Event["AUDIOLEVELOBSERVER_VOLUMES"] = 30] = "AUDIOLEVELOBSERVER_VOLUMES";
})(Event || (exports.Event = Event = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/notification/notification.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/notification/notification.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationT = exports.Notification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const body_1 = __webpack_require__(/*! ../../fbs/notification/body */ "../../node_modules/mediasoup/node/lib/fbs/notification/body.js");
const event_1 = __webpack_require__(/*! ../../fbs/notification/event */ "../../node_modules/mediasoup/node/lib/fbs/notification/event.js");
class Notification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsNotification(bb, obj) {
        return (obj || new Notification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Notification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    handlerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    event() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : event_1.Event.TRANSPORT_SEND_RTCP;
    }
    bodyType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : body_1.Body.NONE;
    }
    body(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startNotification(builder) {
        builder.startObject(4);
    }
    static addHandlerId(builder, handlerIdOffset) {
        builder.addFieldOffset(0, handlerIdOffset, 0);
    }
    static addEvent(builder, event) {
        builder.addFieldInt8(1, event, event_1.Event.TRANSPORT_SEND_RTCP);
    }
    static addBodyType(builder, bodyType) {
        builder.addFieldInt8(2, bodyType, body_1.Body.NONE);
    }
    static addBody(builder, bodyOffset) {
        builder.addFieldOffset(3, bodyOffset, 0);
    }
    static endNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // handler_id
        return offset;
    }
    static createNotification(builder, handlerIdOffset, event, bodyType, bodyOffset) {
        Notification.startNotification(builder);
        Notification.addHandlerId(builder, handlerIdOffset);
        Notification.addEvent(builder, event);
        Notification.addBodyType(builder, bodyType);
        Notification.addBody(builder, bodyOffset);
        return Notification.endNotification(builder);
    }
    unpack() {
        return new NotificationT(this.handlerId(), this.event(), this.bodyType(), (() => {
            const temp = (0, body_1.unionToBody)(this.bodyType(), this.body.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.handlerId = this.handlerId();
        _o.event = this.event();
        _o.bodyType = this.bodyType();
        _o.body = (() => {
            const temp = (0, body_1.unionToBody)(this.bodyType(), this.body.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
exports.Notification = Notification;
class NotificationT {
    handlerId;
    event;
    bodyType;
    body;
    constructor(handlerId = null, event = event_1.Event.TRANSPORT_SEND_RTCP, bodyType = body_1.Body.NONE, body = null) {
        this.handlerId = handlerId;
        this.event = event;
        this.bodyType = bodyType;
        this.body = body;
    }
    pack(builder) {
        const handlerId = (this.handlerId !== null ? builder.createString(this.handlerId) : 0);
        const body = builder.createObjectOffset(this.body);
        return Notification.createNotification(builder, handlerId, this.event, this.bodyType, body);
    }
}
exports.NotificationT = NotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/pipe-transport.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PipeTransportOptionsT = exports.PipeTransportOptions = exports.GetStatsResponseT = exports.GetStatsResponse = exports.DumpResponseT = exports.DumpResponse = exports.ConnectResponseT = exports.ConnectResponse = exports.ConnectRequestT = exports.ConnectRequest = void 0;
var connect_request_1 = __webpack_require__(/*! ./pipe-transport/connect-request */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/connect-request.js");
Object.defineProperty(exports, "ConnectRequest", ({ enumerable: true, get: function () { return connect_request_1.ConnectRequest; } }));
Object.defineProperty(exports, "ConnectRequestT", ({ enumerable: true, get: function () { return connect_request_1.ConnectRequestT; } }));
var connect_response_1 = __webpack_require__(/*! ./pipe-transport/connect-response */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/connect-response.js");
Object.defineProperty(exports, "ConnectResponse", ({ enumerable: true, get: function () { return connect_response_1.ConnectResponse; } }));
Object.defineProperty(exports, "ConnectResponseT", ({ enumerable: true, get: function () { return connect_response_1.ConnectResponseT; } }));
var dump_response_1 = __webpack_require__(/*! ./pipe-transport/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var get_stats_response_1 = __webpack_require__(/*! ./pipe-transport/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/get-stats-response.js");
Object.defineProperty(exports, "GetStatsResponse", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponse; } }));
Object.defineProperty(exports, "GetStatsResponseT", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponseT; } }));
var pipe_transport_options_1 = __webpack_require__(/*! ./pipe-transport/pipe-transport-options */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/pipe-transport-options.js");
Object.defineProperty(exports, "PipeTransportOptions", ({ enumerable: true, get: function () { return pipe_transport_options_1.PipeTransportOptions; } }));
Object.defineProperty(exports, "PipeTransportOptionsT", ({ enumerable: true, get: function () { return pipe_transport_options_1.PipeTransportOptionsT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/connect-request.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/pipe-transport/connect-request.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectRequestT = exports.ConnectRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const srtp_parameters_1 = __webpack_require__(/*! ../../fbs/srtp-parameters/srtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-parameters.js");
class ConnectRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConnectRequest(bb, obj) {
        return (obj || new ConnectRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConnectRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConnectRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ip(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    port() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : null;
    }
    srtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new srtp_parameters_1.SrtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startConnectRequest(builder) {
        builder.startObject(3);
    }
    static addIp(builder, ipOffset) {
        builder.addFieldOffset(0, ipOffset, 0);
    }
    static addPort(builder, port) {
        builder.addFieldInt16(1, port, 0);
    }
    static addSrtpParameters(builder, srtpParametersOffset) {
        builder.addFieldOffset(2, srtpParametersOffset, 0);
    }
    static endConnectRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // ip
        return offset;
    }
    unpack() {
        return new ConnectRequestT(this.ip(), this.port(), (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null));
    }
    unpackTo(_o) {
        _o.ip = this.ip();
        _o.port = this.port();
        _o.srtpParameters = (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null);
    }
}
exports.ConnectRequest = ConnectRequest;
class ConnectRequestT {
    ip;
    port;
    srtpParameters;
    constructor(ip = null, port = null, srtpParameters = null) {
        this.ip = ip;
        this.port = port;
        this.srtpParameters = srtpParameters;
    }
    pack(builder) {
        const ip = (this.ip !== null ? builder.createString(this.ip) : 0);
        const srtpParameters = (this.srtpParameters !== null ? this.srtpParameters.pack(builder) : 0);
        ConnectRequest.startConnectRequest(builder);
        ConnectRequest.addIp(builder, ip);
        if (this.port !== null)
            ConnectRequest.addPort(builder, this.port);
        ConnectRequest.addSrtpParameters(builder, srtpParameters);
        return ConnectRequest.endConnectRequest(builder);
    }
}
exports.ConnectRequestT = ConnectRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/connect-response.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/pipe-transport/connect-response.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectResponseT = exports.ConnectResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class ConnectResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConnectResponse(bb, obj) {
        return (obj || new ConnectResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConnectResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConnectResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startConnectResponse(builder) {
        builder.startObject(1);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(0, tupleOffset, 0);
    }
    static endConnectResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // tuple
        return offset;
    }
    static createConnectResponse(builder, tupleOffset) {
        ConnectResponse.startConnectResponse(builder);
        ConnectResponse.addTuple(builder, tupleOffset);
        return ConnectResponse.endConnectResponse(builder);
    }
    unpack() {
        return new ConnectResponseT((this.tuple() !== null ? this.tuple().unpack() : null));
    }
    unpackTo(_o) {
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
    }
}
exports.ConnectResponse = ConnectResponse;
class ConnectResponseT {
    tuple;
    constructor(tuple = null) {
        this.tuple = tuple;
    }
    pack(builder) {
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        return ConnectResponse.createConnectResponse(builder, tuple);
    }
}
exports.ConnectResponseT = ConnectResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/dump-response.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/pipe-transport/dump-response.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const srtp_parameters_1 = __webpack_require__(/*! ../../fbs/srtp-parameters/srtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-parameters.js");
const dump_1 = __webpack_require__(/*! ../../fbs/transport/dump */ "../../node_modules/mediasoup/node/lib/fbs/transport/dump.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtx() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    srtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new srtp_parameters_1.SrtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startDumpResponse(builder) {
        builder.startObject(4);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(1, tupleOffset, 0);
    }
    static addRtx(builder, rtx) {
        builder.addFieldInt8(2, +rtx, +false);
    }
    static addSrtpParameters(builder, srtpParametersOffset) {
        builder.addFieldOffset(3, srtpParametersOffset, 0);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 6); // tuple
        return offset;
    }
    unpack() {
        return new DumpResponseT((this.base() !== null ? this.base().unpack() : null), (this.tuple() !== null ? this.tuple().unpack() : null), this.rtx(), (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null));
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
        _o.rtx = this.rtx();
        _o.srtpParameters = (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null);
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    base;
    tuple;
    rtx;
    srtpParameters;
    constructor(base = null, tuple = null, rtx = false, srtpParameters = null) {
        this.base = base;
        this.tuple = tuple;
        this.rtx = rtx;
        this.srtpParameters = srtpParameters;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        const srtpParameters = (this.srtpParameters !== null ? this.srtpParameters.pack(builder) : 0);
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addBase(builder, base);
        DumpResponse.addTuple(builder, tuple);
        DumpResponse.addRtx(builder, this.rtx);
        DumpResponse.addSrtpParameters(builder, srtpParameters);
        return DumpResponse.endDumpResponse(builder);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/get-stats-response.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/pipe-transport/get-stats-response.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStatsResponseT = exports.GetStatsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const stats_1 = __webpack_require__(/*! ../../fbs/transport/stats */ "../../node_modules/mediasoup/node/lib/fbs/transport/stats.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class GetStatsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetStatsResponse(bb, obj) {
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetStatsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new stats_1.Stats()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startGetStatsResponse(builder) {
        builder.startObject(2);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(1, tupleOffset, 0);
    }
    static endGetStatsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 6); // tuple
        return offset;
    }
    unpack() {
        return new GetStatsResponseT((this.base() !== null ? this.base().unpack() : null), (this.tuple() !== null ? this.tuple().unpack() : null));
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
    }
}
exports.GetStatsResponse = GetStatsResponse;
class GetStatsResponseT {
    base;
    tuple;
    constructor(base = null, tuple = null) {
        this.base = base;
        this.tuple = tuple;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        GetStatsResponse.startGetStatsResponse(builder);
        GetStatsResponse.addBase(builder, base);
        GetStatsResponse.addTuple(builder, tuple);
        return GetStatsResponse.endGetStatsResponse(builder);
    }
}
exports.GetStatsResponseT = GetStatsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/pipe-transport-options.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/pipe-transport/pipe-transport-options.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PipeTransportOptionsT = exports.PipeTransportOptions = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const listen_info_1 = __webpack_require__(/*! ../../fbs/transport/listen-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/listen-info.js");
const options_1 = __webpack_require__(/*! ../../fbs/transport/options */ "../../node_modules/mediasoup/node/lib/fbs/transport/options.js");
class PipeTransportOptions {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPipeTransportOptions(bb, obj) {
        return (obj || new PipeTransportOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPipeTransportOptions(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new PipeTransportOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new options_1.Options()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    listenInfo(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new listen_info_1.ListenInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    enableRtx() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    enableSrtp() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startPipeTransportOptions(builder) {
        builder.startObject(4);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addListenInfo(builder, listenInfoOffset) {
        builder.addFieldOffset(1, listenInfoOffset, 0);
    }
    static addEnableRtx(builder, enableRtx) {
        builder.addFieldInt8(2, +enableRtx, +false);
    }
    static addEnableSrtp(builder, enableSrtp) {
        builder.addFieldInt8(3, +enableSrtp, +false);
    }
    static endPipeTransportOptions(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 6); // listen_info
        return offset;
    }
    unpack() {
        return new PipeTransportOptionsT((this.base() !== null ? this.base().unpack() : null), (this.listenInfo() !== null ? this.listenInfo().unpack() : null), this.enableRtx(), this.enableSrtp());
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.listenInfo = (this.listenInfo() !== null ? this.listenInfo().unpack() : null);
        _o.enableRtx = this.enableRtx();
        _o.enableSrtp = this.enableSrtp();
    }
}
exports.PipeTransportOptions = PipeTransportOptions;
class PipeTransportOptionsT {
    base;
    listenInfo;
    enableRtx;
    enableSrtp;
    constructor(base = null, listenInfo = null, enableRtx = false, enableSrtp = false) {
        this.base = base;
        this.listenInfo = listenInfo;
        this.enableRtx = enableRtx;
        this.enableSrtp = enableSrtp;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const listenInfo = (this.listenInfo !== null ? this.listenInfo.pack(builder) : 0);
        PipeTransportOptions.startPipeTransportOptions(builder);
        PipeTransportOptions.addBase(builder, base);
        PipeTransportOptions.addListenInfo(builder, listenInfo);
        PipeTransportOptions.addEnableRtx(builder, this.enableRtx);
        PipeTransportOptions.addEnableSrtp(builder, this.enableSrtp);
        return PipeTransportOptions.endPipeTransportOptions(builder);
    }
}
exports.PipeTransportOptionsT = PipeTransportOptionsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/plain-transport.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/plain-transport.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleNotificationT = exports.TupleNotification = exports.RtcpTupleNotificationT = exports.RtcpTupleNotification = exports.PlainTransportOptionsT = exports.PlainTransportOptions = exports.GetStatsResponseT = exports.GetStatsResponse = exports.DumpResponseT = exports.DumpResponse = exports.ConnectResponseT = exports.ConnectResponse = exports.ConnectRequestT = exports.ConnectRequest = void 0;
var connect_request_1 = __webpack_require__(/*! ./plain-transport/connect-request */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/connect-request.js");
Object.defineProperty(exports, "ConnectRequest", ({ enumerable: true, get: function () { return connect_request_1.ConnectRequest; } }));
Object.defineProperty(exports, "ConnectRequestT", ({ enumerable: true, get: function () { return connect_request_1.ConnectRequestT; } }));
var connect_response_1 = __webpack_require__(/*! ./plain-transport/connect-response */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/connect-response.js");
Object.defineProperty(exports, "ConnectResponse", ({ enumerable: true, get: function () { return connect_response_1.ConnectResponse; } }));
Object.defineProperty(exports, "ConnectResponseT", ({ enumerable: true, get: function () { return connect_response_1.ConnectResponseT; } }));
var dump_response_1 = __webpack_require__(/*! ./plain-transport/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var get_stats_response_1 = __webpack_require__(/*! ./plain-transport/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/get-stats-response.js");
Object.defineProperty(exports, "GetStatsResponse", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponse; } }));
Object.defineProperty(exports, "GetStatsResponseT", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponseT; } }));
var plain_transport_options_1 = __webpack_require__(/*! ./plain-transport/plain-transport-options */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/plain-transport-options.js");
Object.defineProperty(exports, "PlainTransportOptions", ({ enumerable: true, get: function () { return plain_transport_options_1.PlainTransportOptions; } }));
Object.defineProperty(exports, "PlainTransportOptionsT", ({ enumerable: true, get: function () { return plain_transport_options_1.PlainTransportOptionsT; } }));
var rtcp_tuple_notification_1 = __webpack_require__(/*! ./plain-transport/rtcp-tuple-notification */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/rtcp-tuple-notification.js");
Object.defineProperty(exports, "RtcpTupleNotification", ({ enumerable: true, get: function () { return rtcp_tuple_notification_1.RtcpTupleNotification; } }));
Object.defineProperty(exports, "RtcpTupleNotificationT", ({ enumerable: true, get: function () { return rtcp_tuple_notification_1.RtcpTupleNotificationT; } }));
var tuple_notification_1 = __webpack_require__(/*! ./plain-transport/tuple-notification */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/tuple-notification.js");
Object.defineProperty(exports, "TupleNotification", ({ enumerable: true, get: function () { return tuple_notification_1.TupleNotification; } }));
Object.defineProperty(exports, "TupleNotificationT", ({ enumerable: true, get: function () { return tuple_notification_1.TupleNotificationT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/connect-request.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/plain-transport/connect-request.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectRequestT = exports.ConnectRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const srtp_parameters_1 = __webpack_require__(/*! ../../fbs/srtp-parameters/srtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-parameters.js");
class ConnectRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConnectRequest(bb, obj) {
        return (obj || new ConnectRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConnectRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConnectRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ip(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    port() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : null;
    }
    rtcpPort() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : null;
    }
    srtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new srtp_parameters_1.SrtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startConnectRequest(builder) {
        builder.startObject(4);
    }
    static addIp(builder, ipOffset) {
        builder.addFieldOffset(0, ipOffset, 0);
    }
    static addPort(builder, port) {
        builder.addFieldInt16(1, port, 0);
    }
    static addRtcpPort(builder, rtcpPort) {
        builder.addFieldInt16(2, rtcpPort, 0);
    }
    static addSrtpParameters(builder, srtpParametersOffset) {
        builder.addFieldOffset(3, srtpParametersOffset, 0);
    }
    static endConnectRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new ConnectRequestT(this.ip(), this.port(), this.rtcpPort(), (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null));
    }
    unpackTo(_o) {
        _o.ip = this.ip();
        _o.port = this.port();
        _o.rtcpPort = this.rtcpPort();
        _o.srtpParameters = (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null);
    }
}
exports.ConnectRequest = ConnectRequest;
class ConnectRequestT {
    ip;
    port;
    rtcpPort;
    srtpParameters;
    constructor(ip = null, port = null, rtcpPort = null, srtpParameters = null) {
        this.ip = ip;
        this.port = port;
        this.rtcpPort = rtcpPort;
        this.srtpParameters = srtpParameters;
    }
    pack(builder) {
        const ip = (this.ip !== null ? builder.createString(this.ip) : 0);
        const srtpParameters = (this.srtpParameters !== null ? this.srtpParameters.pack(builder) : 0);
        ConnectRequest.startConnectRequest(builder);
        ConnectRequest.addIp(builder, ip);
        if (this.port !== null)
            ConnectRequest.addPort(builder, this.port);
        if (this.rtcpPort !== null)
            ConnectRequest.addRtcpPort(builder, this.rtcpPort);
        ConnectRequest.addSrtpParameters(builder, srtpParameters);
        return ConnectRequest.endConnectRequest(builder);
    }
}
exports.ConnectRequestT = ConnectRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/connect-response.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/plain-transport/connect-response.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectResponseT = exports.ConnectResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const srtp_parameters_1 = __webpack_require__(/*! ../../fbs/srtp-parameters/srtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-parameters.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class ConnectResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConnectResponse(bb, obj) {
        return (obj || new ConnectResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConnectResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConnectResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtcpTuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    srtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new srtp_parameters_1.SrtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startConnectResponse(builder) {
        builder.startObject(3);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(0, tupleOffset, 0);
    }
    static addRtcpTuple(builder, rtcpTupleOffset) {
        builder.addFieldOffset(1, rtcpTupleOffset, 0);
    }
    static addSrtpParameters(builder, srtpParametersOffset) {
        builder.addFieldOffset(2, srtpParametersOffset, 0);
    }
    static endConnectResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // tuple
        return offset;
    }
    unpack() {
        return new ConnectResponseT((this.tuple() !== null ? this.tuple().unpack() : null), (this.rtcpTuple() !== null ? this.rtcpTuple().unpack() : null), (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null));
    }
    unpackTo(_o) {
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
        _o.rtcpTuple = (this.rtcpTuple() !== null ? this.rtcpTuple().unpack() : null);
        _o.srtpParameters = (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null);
    }
}
exports.ConnectResponse = ConnectResponse;
class ConnectResponseT {
    tuple;
    rtcpTuple;
    srtpParameters;
    constructor(tuple = null, rtcpTuple = null, srtpParameters = null) {
        this.tuple = tuple;
        this.rtcpTuple = rtcpTuple;
        this.srtpParameters = srtpParameters;
    }
    pack(builder) {
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        const rtcpTuple = (this.rtcpTuple !== null ? this.rtcpTuple.pack(builder) : 0);
        const srtpParameters = (this.srtpParameters !== null ? this.srtpParameters.pack(builder) : 0);
        ConnectResponse.startConnectResponse(builder);
        ConnectResponse.addTuple(builder, tuple);
        ConnectResponse.addRtcpTuple(builder, rtcpTuple);
        ConnectResponse.addSrtpParameters(builder, srtpParameters);
        return ConnectResponse.endConnectResponse(builder);
    }
}
exports.ConnectResponseT = ConnectResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/dump-response.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/plain-transport/dump-response.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const srtp_parameters_1 = __webpack_require__(/*! ../../fbs/srtp-parameters/srtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-parameters.js");
const dump_1 = __webpack_require__(/*! ../../fbs/transport/dump */ "../../node_modules/mediasoup/node/lib/fbs/transport/dump.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtcpMux() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    comedia() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtcpTuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    srtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new srtp_parameters_1.SrtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startDumpResponse(builder) {
        builder.startObject(6);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addRtcpMux(builder, rtcpMux) {
        builder.addFieldInt8(1, +rtcpMux, +false);
    }
    static addComedia(builder, comedia) {
        builder.addFieldInt8(2, +comedia, +false);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(3, tupleOffset, 0);
    }
    static addRtcpTuple(builder, rtcpTupleOffset) {
        builder.addFieldOffset(4, rtcpTupleOffset, 0);
    }
    static addSrtpParameters(builder, srtpParametersOffset) {
        builder.addFieldOffset(5, srtpParametersOffset, 0);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 10); // tuple
        return offset;
    }
    unpack() {
        return new DumpResponseT((this.base() !== null ? this.base().unpack() : null), this.rtcpMux(), this.comedia(), (this.tuple() !== null ? this.tuple().unpack() : null), (this.rtcpTuple() !== null ? this.rtcpTuple().unpack() : null), (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null));
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.rtcpMux = this.rtcpMux();
        _o.comedia = this.comedia();
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
        _o.rtcpTuple = (this.rtcpTuple() !== null ? this.rtcpTuple().unpack() : null);
        _o.srtpParameters = (this.srtpParameters() !== null ? this.srtpParameters().unpack() : null);
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    base;
    rtcpMux;
    comedia;
    tuple;
    rtcpTuple;
    srtpParameters;
    constructor(base = null, rtcpMux = false, comedia = false, tuple = null, rtcpTuple = null, srtpParameters = null) {
        this.base = base;
        this.rtcpMux = rtcpMux;
        this.comedia = comedia;
        this.tuple = tuple;
        this.rtcpTuple = rtcpTuple;
        this.srtpParameters = srtpParameters;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        const rtcpTuple = (this.rtcpTuple !== null ? this.rtcpTuple.pack(builder) : 0);
        const srtpParameters = (this.srtpParameters !== null ? this.srtpParameters.pack(builder) : 0);
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addBase(builder, base);
        DumpResponse.addRtcpMux(builder, this.rtcpMux);
        DumpResponse.addComedia(builder, this.comedia);
        DumpResponse.addTuple(builder, tuple);
        DumpResponse.addRtcpTuple(builder, rtcpTuple);
        DumpResponse.addSrtpParameters(builder, srtpParameters);
        return DumpResponse.endDumpResponse(builder);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/get-stats-response.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/plain-transport/get-stats-response.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStatsResponseT = exports.GetStatsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const stats_1 = __webpack_require__(/*! ../../fbs/transport/stats */ "../../node_modules/mediasoup/node/lib/fbs/transport/stats.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class GetStatsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetStatsResponse(bb, obj) {
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetStatsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new stats_1.Stats()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtcpMux() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    comedia() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtcpTuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startGetStatsResponse(builder) {
        builder.startObject(5);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addRtcpMux(builder, rtcpMux) {
        builder.addFieldInt8(1, +rtcpMux, +false);
    }
    static addComedia(builder, comedia) {
        builder.addFieldInt8(2, +comedia, +false);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(3, tupleOffset, 0);
    }
    static addRtcpTuple(builder, rtcpTupleOffset) {
        builder.addFieldOffset(4, rtcpTupleOffset, 0);
    }
    static endGetStatsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 10); // tuple
        return offset;
    }
    unpack() {
        return new GetStatsResponseT((this.base() !== null ? this.base().unpack() : null), this.rtcpMux(), this.comedia(), (this.tuple() !== null ? this.tuple().unpack() : null), (this.rtcpTuple() !== null ? this.rtcpTuple().unpack() : null));
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.rtcpMux = this.rtcpMux();
        _o.comedia = this.comedia();
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
        _o.rtcpTuple = (this.rtcpTuple() !== null ? this.rtcpTuple().unpack() : null);
    }
}
exports.GetStatsResponse = GetStatsResponse;
class GetStatsResponseT {
    base;
    rtcpMux;
    comedia;
    tuple;
    rtcpTuple;
    constructor(base = null, rtcpMux = false, comedia = false, tuple = null, rtcpTuple = null) {
        this.base = base;
        this.rtcpMux = rtcpMux;
        this.comedia = comedia;
        this.tuple = tuple;
        this.rtcpTuple = rtcpTuple;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        const rtcpTuple = (this.rtcpTuple !== null ? this.rtcpTuple.pack(builder) : 0);
        GetStatsResponse.startGetStatsResponse(builder);
        GetStatsResponse.addBase(builder, base);
        GetStatsResponse.addRtcpMux(builder, this.rtcpMux);
        GetStatsResponse.addComedia(builder, this.comedia);
        GetStatsResponse.addTuple(builder, tuple);
        GetStatsResponse.addRtcpTuple(builder, rtcpTuple);
        return GetStatsResponse.endGetStatsResponse(builder);
    }
}
exports.GetStatsResponseT = GetStatsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/plain-transport-options.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/plain-transport/plain-transport-options.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlainTransportOptionsT = exports.PlainTransportOptions = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const listen_info_1 = __webpack_require__(/*! ../../fbs/transport/listen-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/listen-info.js");
const options_1 = __webpack_require__(/*! ../../fbs/transport/options */ "../../node_modules/mediasoup/node/lib/fbs/transport/options.js");
class PlainTransportOptions {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPlainTransportOptions(bb, obj) {
        return (obj || new PlainTransportOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPlainTransportOptions(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new PlainTransportOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new options_1.Options()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    listenInfo(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new listen_info_1.ListenInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtcpListenInfo(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new listen_info_1.ListenInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtcpMux() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    comedia() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    enableSrtp() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    srtpCryptoSuite() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    static startPlainTransportOptions(builder) {
        builder.startObject(7);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addListenInfo(builder, listenInfoOffset) {
        builder.addFieldOffset(1, listenInfoOffset, 0);
    }
    static addRtcpListenInfo(builder, rtcpListenInfoOffset) {
        builder.addFieldOffset(2, rtcpListenInfoOffset, 0);
    }
    static addRtcpMux(builder, rtcpMux) {
        builder.addFieldInt8(3, +rtcpMux, +false);
    }
    static addComedia(builder, comedia) {
        builder.addFieldInt8(4, +comedia, +false);
    }
    static addEnableSrtp(builder, enableSrtp) {
        builder.addFieldInt8(5, +enableSrtp, +false);
    }
    static addSrtpCryptoSuite(builder, srtpCryptoSuite) {
        builder.addFieldInt8(6, srtpCryptoSuite, 0);
    }
    static endPlainTransportOptions(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 6); // listen_info
        return offset;
    }
    unpack() {
        return new PlainTransportOptionsT((this.base() !== null ? this.base().unpack() : null), (this.listenInfo() !== null ? this.listenInfo().unpack() : null), (this.rtcpListenInfo() !== null ? this.rtcpListenInfo().unpack() : null), this.rtcpMux(), this.comedia(), this.enableSrtp(), this.srtpCryptoSuite());
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.listenInfo = (this.listenInfo() !== null ? this.listenInfo().unpack() : null);
        _o.rtcpListenInfo = (this.rtcpListenInfo() !== null ? this.rtcpListenInfo().unpack() : null);
        _o.rtcpMux = this.rtcpMux();
        _o.comedia = this.comedia();
        _o.enableSrtp = this.enableSrtp();
        _o.srtpCryptoSuite = this.srtpCryptoSuite();
    }
}
exports.PlainTransportOptions = PlainTransportOptions;
class PlainTransportOptionsT {
    base;
    listenInfo;
    rtcpListenInfo;
    rtcpMux;
    comedia;
    enableSrtp;
    srtpCryptoSuite;
    constructor(base = null, listenInfo = null, rtcpListenInfo = null, rtcpMux = false, comedia = false, enableSrtp = false, srtpCryptoSuite = null) {
        this.base = base;
        this.listenInfo = listenInfo;
        this.rtcpListenInfo = rtcpListenInfo;
        this.rtcpMux = rtcpMux;
        this.comedia = comedia;
        this.enableSrtp = enableSrtp;
        this.srtpCryptoSuite = srtpCryptoSuite;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const listenInfo = (this.listenInfo !== null ? this.listenInfo.pack(builder) : 0);
        const rtcpListenInfo = (this.rtcpListenInfo !== null ? this.rtcpListenInfo.pack(builder) : 0);
        PlainTransportOptions.startPlainTransportOptions(builder);
        PlainTransportOptions.addBase(builder, base);
        PlainTransportOptions.addListenInfo(builder, listenInfo);
        PlainTransportOptions.addRtcpListenInfo(builder, rtcpListenInfo);
        PlainTransportOptions.addRtcpMux(builder, this.rtcpMux);
        PlainTransportOptions.addComedia(builder, this.comedia);
        PlainTransportOptions.addEnableSrtp(builder, this.enableSrtp);
        if (this.srtpCryptoSuite !== null)
            PlainTransportOptions.addSrtpCryptoSuite(builder, this.srtpCryptoSuite);
        return PlainTransportOptions.endPlainTransportOptions(builder);
    }
}
exports.PlainTransportOptionsT = PlainTransportOptionsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/rtcp-tuple-notification.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/plain-transport/rtcp-tuple-notification.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtcpTupleNotificationT = exports.RtcpTupleNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class RtcpTupleNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtcpTupleNotification(bb, obj) {
        return (obj || new RtcpTupleNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtcpTupleNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtcpTupleNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRtcpTupleNotification(builder) {
        builder.startObject(1);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(0, tupleOffset, 0);
    }
    static endRtcpTupleNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // tuple
        return offset;
    }
    static createRtcpTupleNotification(builder, tupleOffset) {
        RtcpTupleNotification.startRtcpTupleNotification(builder);
        RtcpTupleNotification.addTuple(builder, tupleOffset);
        return RtcpTupleNotification.endRtcpTupleNotification(builder);
    }
    unpack() {
        return new RtcpTupleNotificationT((this.tuple() !== null ? this.tuple().unpack() : null));
    }
    unpackTo(_o) {
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
    }
}
exports.RtcpTupleNotification = RtcpTupleNotification;
class RtcpTupleNotificationT {
    tuple;
    constructor(tuple = null) {
        this.tuple = tuple;
    }
    pack(builder) {
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        return RtcpTupleNotification.createRtcpTupleNotification(builder, tuple);
    }
}
exports.RtcpTupleNotificationT = RtcpTupleNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/tuple-notification.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/plain-transport/tuple-notification.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleNotificationT = exports.TupleNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class TupleNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTupleNotification(bb, obj) {
        return (obj || new TupleNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTupleNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TupleNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startTupleNotification(builder) {
        builder.startObject(1);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(0, tupleOffset, 0);
    }
    static endTupleNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // tuple
        return offset;
    }
    static createTupleNotification(builder, tupleOffset) {
        TupleNotification.startTupleNotification(builder);
        TupleNotification.addTuple(builder, tupleOffset);
        return TupleNotification.endTupleNotification(builder);
    }
    unpack() {
        return new TupleNotificationT((this.tuple() !== null ? this.tuple().unpack() : null));
    }
    unpackTo(_o) {
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
    }
}
exports.TupleNotification = TupleNotification;
class TupleNotificationT {
    tuple;
    constructor(tuple = null) {
        this.tuple = tuple;
    }
    pack(builder) {
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        return TupleNotification.createTupleNotification(builder, tuple);
    }
}
exports.TupleNotificationT = TupleNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer.js":
/*!*************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VideoOrientationChangeNotificationT = exports.VideoOrientationChangeNotification = exports.TraceNotificationT = exports.TraceNotification = exports.TraceInfo = exports.TraceEventType = exports.SrTraceInfoT = exports.SrTraceInfo = exports.SendNotificationT = exports.SendNotification = exports.ScoreNotificationT = exports.ScoreNotification = exports.ScoreT = exports.Score = exports.RtpTraceInfoT = exports.RtpTraceInfo = exports.PliTraceInfoT = exports.PliTraceInfo = exports.KeyFrameTraceInfoT = exports.KeyFrameTraceInfo = exports.GetStatsResponseT = exports.GetStatsResponse = exports.FirTraceInfoT = exports.FirTraceInfo = exports.EnableTraceEventRequestT = exports.EnableTraceEventRequest = exports.DumpResponseT = exports.DumpResponse = void 0;
var dump_response_1 = __webpack_require__(/*! ./producer/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/producer/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var enable_trace_event_request_1 = __webpack_require__(/*! ./producer/enable-trace-event-request */ "../../node_modules/mediasoup/node/lib/fbs/producer/enable-trace-event-request.js");
Object.defineProperty(exports, "EnableTraceEventRequest", ({ enumerable: true, get: function () { return enable_trace_event_request_1.EnableTraceEventRequest; } }));
Object.defineProperty(exports, "EnableTraceEventRequestT", ({ enumerable: true, get: function () { return enable_trace_event_request_1.EnableTraceEventRequestT; } }));
var fir_trace_info_1 = __webpack_require__(/*! ./producer/fir-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/fir-trace-info.js");
Object.defineProperty(exports, "FirTraceInfo", ({ enumerable: true, get: function () { return fir_trace_info_1.FirTraceInfo; } }));
Object.defineProperty(exports, "FirTraceInfoT", ({ enumerable: true, get: function () { return fir_trace_info_1.FirTraceInfoT; } }));
var get_stats_response_1 = __webpack_require__(/*! ./producer/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/producer/get-stats-response.js");
Object.defineProperty(exports, "GetStatsResponse", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponse; } }));
Object.defineProperty(exports, "GetStatsResponseT", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponseT; } }));
var key_frame_trace_info_1 = __webpack_require__(/*! ./producer/key-frame-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/key-frame-trace-info.js");
Object.defineProperty(exports, "KeyFrameTraceInfo", ({ enumerable: true, get: function () { return key_frame_trace_info_1.KeyFrameTraceInfo; } }));
Object.defineProperty(exports, "KeyFrameTraceInfoT", ({ enumerable: true, get: function () { return key_frame_trace_info_1.KeyFrameTraceInfoT; } }));
var pli_trace_info_1 = __webpack_require__(/*! ./producer/pli-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/pli-trace-info.js");
Object.defineProperty(exports, "PliTraceInfo", ({ enumerable: true, get: function () { return pli_trace_info_1.PliTraceInfo; } }));
Object.defineProperty(exports, "PliTraceInfoT", ({ enumerable: true, get: function () { return pli_trace_info_1.PliTraceInfoT; } }));
var rtp_trace_info_1 = __webpack_require__(/*! ./producer/rtp-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/rtp-trace-info.js");
Object.defineProperty(exports, "RtpTraceInfo", ({ enumerable: true, get: function () { return rtp_trace_info_1.RtpTraceInfo; } }));
Object.defineProperty(exports, "RtpTraceInfoT", ({ enumerable: true, get: function () { return rtp_trace_info_1.RtpTraceInfoT; } }));
var score_1 = __webpack_require__(/*! ./producer/score */ "../../node_modules/mediasoup/node/lib/fbs/producer/score.js");
Object.defineProperty(exports, "Score", ({ enumerable: true, get: function () { return score_1.Score; } }));
Object.defineProperty(exports, "ScoreT", ({ enumerable: true, get: function () { return score_1.ScoreT; } }));
var score_notification_1 = __webpack_require__(/*! ./producer/score-notification */ "../../node_modules/mediasoup/node/lib/fbs/producer/score-notification.js");
Object.defineProperty(exports, "ScoreNotification", ({ enumerable: true, get: function () { return score_notification_1.ScoreNotification; } }));
Object.defineProperty(exports, "ScoreNotificationT", ({ enumerable: true, get: function () { return score_notification_1.ScoreNotificationT; } }));
var send_notification_1 = __webpack_require__(/*! ./producer/send-notification */ "../../node_modules/mediasoup/node/lib/fbs/producer/send-notification.js");
Object.defineProperty(exports, "SendNotification", ({ enumerable: true, get: function () { return send_notification_1.SendNotification; } }));
Object.defineProperty(exports, "SendNotificationT", ({ enumerable: true, get: function () { return send_notification_1.SendNotificationT; } }));
var sr_trace_info_1 = __webpack_require__(/*! ./producer/sr-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/sr-trace-info.js");
Object.defineProperty(exports, "SrTraceInfo", ({ enumerable: true, get: function () { return sr_trace_info_1.SrTraceInfo; } }));
Object.defineProperty(exports, "SrTraceInfoT", ({ enumerable: true, get: function () { return sr_trace_info_1.SrTraceInfoT; } }));
var trace_event_type_1 = __webpack_require__(/*! ./producer/trace-event-type */ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-event-type.js");
Object.defineProperty(exports, "TraceEventType", ({ enumerable: true, get: function () { return trace_event_type_1.TraceEventType; } }));
var trace_info_1 = __webpack_require__(/*! ./producer/trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-info.js");
Object.defineProperty(exports, "TraceInfo", ({ enumerable: true, get: function () { return trace_info_1.TraceInfo; } }));
var trace_notification_1 = __webpack_require__(/*! ./producer/trace-notification */ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-notification.js");
Object.defineProperty(exports, "TraceNotification", ({ enumerable: true, get: function () { return trace_notification_1.TraceNotification; } }));
Object.defineProperty(exports, "TraceNotificationT", ({ enumerable: true, get: function () { return trace_notification_1.TraceNotificationT; } }));
var video_orientation_change_notification_1 = __webpack_require__(/*! ./producer/video-orientation-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/producer/video-orientation-change-notification.js");
Object.defineProperty(exports, "VideoOrientationChangeNotification", ({ enumerable: true, get: function () { return video_orientation_change_notification_1.VideoOrientationChangeNotification; } }));
Object.defineProperty(exports, "VideoOrientationChangeNotificationT", ({ enumerable: true, get: function () { return video_orientation_change_notification_1.VideoOrientationChangeNotificationT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/dump-response.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/dump-response.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const media_kind_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/media-kind */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js");
const rtp_mapping_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-mapping */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-mapping.js");
const rtp_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-parameters.js");
const type_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/type */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/type.js");
const dump_1 = __webpack_require__(/*! ../../fbs/rtp-stream/dump */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/dump.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    kind() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : media_kind_1.MediaKind.AUDIO;
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_1.Type.SIMPLE;
    }
    rtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new rtp_parameters_1.RtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtpMapping(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new rtp_mapping_1.RtpMapping()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtpStreams(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    rtpStreamsLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    traceEventTypes(index) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    traceEventTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    traceEventTypesArray() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDumpResponse(builder) {
        builder.startObject(8);
    }
    static addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    }
    static addKind(builder, kind) {
        builder.addFieldInt8(1, kind, media_kind_1.MediaKind.AUDIO);
    }
    static addType(builder, type) {
        builder.addFieldInt8(2, type, type_1.Type.SIMPLE);
    }
    static addRtpParameters(builder, rtpParametersOffset) {
        builder.addFieldOffset(3, rtpParametersOffset, 0);
    }
    static addRtpMapping(builder, rtpMappingOffset) {
        builder.addFieldOffset(4, rtpMappingOffset, 0);
    }
    static addRtpStreams(builder, rtpStreamsOffset) {
        builder.addFieldOffset(5, rtpStreamsOffset, 0);
    }
    static createRtpStreamsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRtpStreamsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTraceEventTypes(builder, traceEventTypesOffset) {
        builder.addFieldOffset(6, traceEventTypesOffset, 0);
    }
    static createTraceEventTypesVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startTraceEventTypesVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(7, +paused, +false);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // id
        builder.requiredField(offset, 10); // rtp_parameters
        builder.requiredField(offset, 12); // rtp_mapping
        builder.requiredField(offset, 14); // rtp_streams
        builder.requiredField(offset, 16); // trace_event_types
        return offset;
    }
    unpack() {
        return new DumpResponseT(this.id(), this.kind(), this.type(), (this.rtpParameters() !== null ? this.rtpParameters().unpack() : null), (this.rtpMapping() !== null ? this.rtpMapping().unpack() : null), this.bb.createObjList(this.rtpStreams.bind(this), this.rtpStreamsLength()), this.bb.createScalarList(this.traceEventTypes.bind(this), this.traceEventTypesLength()), this.paused());
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.kind = this.kind();
        _o.type = this.type();
        _o.rtpParameters = (this.rtpParameters() !== null ? this.rtpParameters().unpack() : null);
        _o.rtpMapping = (this.rtpMapping() !== null ? this.rtpMapping().unpack() : null);
        _o.rtpStreams = this.bb.createObjList(this.rtpStreams.bind(this), this.rtpStreamsLength());
        _o.traceEventTypes = this.bb.createScalarList(this.traceEventTypes.bind(this), this.traceEventTypesLength());
        _o.paused = this.paused();
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    id;
    kind;
    type;
    rtpParameters;
    rtpMapping;
    rtpStreams;
    traceEventTypes;
    paused;
    constructor(id = null, kind = media_kind_1.MediaKind.AUDIO, type = type_1.Type.SIMPLE, rtpParameters = null, rtpMapping = null, rtpStreams = [], traceEventTypes = [], paused = false) {
        this.id = id;
        this.kind = kind;
        this.type = type;
        this.rtpParameters = rtpParameters;
        this.rtpMapping = rtpMapping;
        this.rtpStreams = rtpStreams;
        this.traceEventTypes = traceEventTypes;
        this.paused = paused;
    }
    pack(builder) {
        const id = (this.id !== null ? builder.createString(this.id) : 0);
        const rtpParameters = (this.rtpParameters !== null ? this.rtpParameters.pack(builder) : 0);
        const rtpMapping = (this.rtpMapping !== null ? this.rtpMapping.pack(builder) : 0);
        const rtpStreams = DumpResponse.createRtpStreamsVector(builder, builder.createObjectOffsetList(this.rtpStreams));
        const traceEventTypes = DumpResponse.createTraceEventTypesVector(builder, this.traceEventTypes);
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addId(builder, id);
        DumpResponse.addKind(builder, this.kind);
        DumpResponse.addType(builder, this.type);
        DumpResponse.addRtpParameters(builder, rtpParameters);
        DumpResponse.addRtpMapping(builder, rtpMapping);
        DumpResponse.addRtpStreams(builder, rtpStreams);
        DumpResponse.addTraceEventTypes(builder, traceEventTypes);
        DumpResponse.addPaused(builder, this.paused);
        return DumpResponse.endDumpResponse(builder);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/enable-trace-event-request.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/enable-trace-event-request.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnableTraceEventRequestT = exports.EnableTraceEventRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class EnableTraceEventRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEnableTraceEventRequest(bb, obj) {
        return (obj || new EnableTraceEventRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEnableTraceEventRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EnableTraceEventRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    events(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    eventsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    eventsArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startEnableTraceEventRequest(builder) {
        builder.startObject(1);
    }
    static addEvents(builder, eventsOffset) {
        builder.addFieldOffset(0, eventsOffset, 0);
    }
    static createEventsVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startEventsVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endEnableTraceEventRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // events
        return offset;
    }
    static createEnableTraceEventRequest(builder, eventsOffset) {
        EnableTraceEventRequest.startEnableTraceEventRequest(builder);
        EnableTraceEventRequest.addEvents(builder, eventsOffset);
        return EnableTraceEventRequest.endEnableTraceEventRequest(builder);
    }
    unpack() {
        return new EnableTraceEventRequestT(this.bb.createScalarList(this.events.bind(this), this.eventsLength()));
    }
    unpackTo(_o) {
        _o.events = this.bb.createScalarList(this.events.bind(this), this.eventsLength());
    }
}
exports.EnableTraceEventRequest = EnableTraceEventRequest;
class EnableTraceEventRequestT {
    events;
    constructor(events = []) {
        this.events = events;
    }
    pack(builder) {
        const events = EnableTraceEventRequest.createEventsVector(builder, this.events);
        return EnableTraceEventRequest.createEnableTraceEventRequest(builder, events);
    }
}
exports.EnableTraceEventRequestT = EnableTraceEventRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/fir-trace-info.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/fir-trace-info.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FirTraceInfoT = exports.FirTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class FirTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFirTraceInfo(bb, obj) {
        return (obj || new FirTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFirTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FirTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startFirTraceInfo(builder) {
        builder.startObject(1);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(0, ssrc, 0);
    }
    static endFirTraceInfo(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFirTraceInfo(builder, ssrc) {
        FirTraceInfo.startFirTraceInfo(builder);
        FirTraceInfo.addSsrc(builder, ssrc);
        return FirTraceInfo.endFirTraceInfo(builder);
    }
    unpack() {
        return new FirTraceInfoT(this.ssrc());
    }
    unpackTo(_o) {
        _o.ssrc = this.ssrc();
    }
}
exports.FirTraceInfo = FirTraceInfo;
class FirTraceInfoT {
    ssrc;
    constructor(ssrc = 0) {
        this.ssrc = ssrc;
    }
    pack(builder) {
        return FirTraceInfo.createFirTraceInfo(builder, this.ssrc);
    }
}
exports.FirTraceInfoT = FirTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/get-stats-response.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/get-stats-response.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStatsResponseT = exports.GetStatsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const stats_1 = __webpack_require__(/*! ../../fbs/rtp-stream/stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats.js");
class GetStatsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetStatsResponse(bb, obj) {
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetStatsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    stats(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new stats_1.Stats()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    statsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startGetStatsResponse(builder) {
        builder.startObject(1);
    }
    static addStats(builder, statsOffset) {
        builder.addFieldOffset(0, statsOffset, 0);
    }
    static createStatsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startStatsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endGetStatsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // stats
        return offset;
    }
    static createGetStatsResponse(builder, statsOffset) {
        GetStatsResponse.startGetStatsResponse(builder);
        GetStatsResponse.addStats(builder, statsOffset);
        return GetStatsResponse.endGetStatsResponse(builder);
    }
    unpack() {
        return new GetStatsResponseT(this.bb.createObjList(this.stats.bind(this), this.statsLength()));
    }
    unpackTo(_o) {
        _o.stats = this.bb.createObjList(this.stats.bind(this), this.statsLength());
    }
}
exports.GetStatsResponse = GetStatsResponse;
class GetStatsResponseT {
    stats;
    constructor(stats = []) {
        this.stats = stats;
    }
    pack(builder) {
        const stats = GetStatsResponse.createStatsVector(builder, builder.createObjectOffsetList(this.stats));
        return GetStatsResponse.createGetStatsResponse(builder, stats);
    }
}
exports.GetStatsResponseT = GetStatsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/key-frame-trace-info.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/key-frame-trace-info.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyFrameTraceInfoT = exports.KeyFrameTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dump_1 = __webpack_require__(/*! ../../fbs/rtp-packet/dump */ "../../node_modules/mediasoup/node/lib/fbs/rtp-packet/dump.js");
class KeyFrameTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsKeyFrameTraceInfo(bb, obj) {
        return (obj || new KeyFrameTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyFrameTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new KeyFrameTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    rtpPacket(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isRtx() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startKeyFrameTraceInfo(builder) {
        builder.startObject(2);
    }
    static addRtpPacket(builder, rtpPacketOffset) {
        builder.addFieldOffset(0, rtpPacketOffset, 0);
    }
    static addIsRtx(builder, isRtx) {
        builder.addFieldInt8(1, +isRtx, +false);
    }
    static endKeyFrameTraceInfo(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // rtp_packet
        return offset;
    }
    static createKeyFrameTraceInfo(builder, rtpPacketOffset, isRtx) {
        KeyFrameTraceInfo.startKeyFrameTraceInfo(builder);
        KeyFrameTraceInfo.addRtpPacket(builder, rtpPacketOffset);
        KeyFrameTraceInfo.addIsRtx(builder, isRtx);
        return KeyFrameTraceInfo.endKeyFrameTraceInfo(builder);
    }
    unpack() {
        return new KeyFrameTraceInfoT((this.rtpPacket() !== null ? this.rtpPacket().unpack() : null), this.isRtx());
    }
    unpackTo(_o) {
        _o.rtpPacket = (this.rtpPacket() !== null ? this.rtpPacket().unpack() : null);
        _o.isRtx = this.isRtx();
    }
}
exports.KeyFrameTraceInfo = KeyFrameTraceInfo;
class KeyFrameTraceInfoT {
    rtpPacket;
    isRtx;
    constructor(rtpPacket = null, isRtx = false) {
        this.rtpPacket = rtpPacket;
        this.isRtx = isRtx;
    }
    pack(builder) {
        const rtpPacket = (this.rtpPacket !== null ? this.rtpPacket.pack(builder) : 0);
        return KeyFrameTraceInfo.createKeyFrameTraceInfo(builder, rtpPacket, this.isRtx);
    }
}
exports.KeyFrameTraceInfoT = KeyFrameTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/pli-trace-info.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/pli-trace-info.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PliTraceInfoT = exports.PliTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class PliTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPliTraceInfo(bb, obj) {
        return (obj || new PliTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPliTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new PliTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startPliTraceInfo(builder) {
        builder.startObject(1);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(0, ssrc, 0);
    }
    static endPliTraceInfo(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createPliTraceInfo(builder, ssrc) {
        PliTraceInfo.startPliTraceInfo(builder);
        PliTraceInfo.addSsrc(builder, ssrc);
        return PliTraceInfo.endPliTraceInfo(builder);
    }
    unpack() {
        return new PliTraceInfoT(this.ssrc());
    }
    unpackTo(_o) {
        _o.ssrc = this.ssrc();
    }
}
exports.PliTraceInfo = PliTraceInfo;
class PliTraceInfoT {
    ssrc;
    constructor(ssrc = 0) {
        this.ssrc = ssrc;
    }
    pack(builder) {
        return PliTraceInfo.createPliTraceInfo(builder, this.ssrc);
    }
}
exports.PliTraceInfoT = PliTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/rtp-trace-info.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/rtp-trace-info.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpTraceInfoT = exports.RtpTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dump_1 = __webpack_require__(/*! ../../fbs/rtp-packet/dump */ "../../node_modules/mediasoup/node/lib/fbs/rtp-packet/dump.js");
class RtpTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpTraceInfo(bb, obj) {
        return (obj || new RtpTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    rtpPacket(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isRtx() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startRtpTraceInfo(builder) {
        builder.startObject(2);
    }
    static addRtpPacket(builder, rtpPacketOffset) {
        builder.addFieldOffset(0, rtpPacketOffset, 0);
    }
    static addIsRtx(builder, isRtx) {
        builder.addFieldInt8(1, +isRtx, +false);
    }
    static endRtpTraceInfo(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // rtp_packet
        return offset;
    }
    static createRtpTraceInfo(builder, rtpPacketOffset, isRtx) {
        RtpTraceInfo.startRtpTraceInfo(builder);
        RtpTraceInfo.addRtpPacket(builder, rtpPacketOffset);
        RtpTraceInfo.addIsRtx(builder, isRtx);
        return RtpTraceInfo.endRtpTraceInfo(builder);
    }
    unpack() {
        return new RtpTraceInfoT((this.rtpPacket() !== null ? this.rtpPacket().unpack() : null), this.isRtx());
    }
    unpackTo(_o) {
        _o.rtpPacket = (this.rtpPacket() !== null ? this.rtpPacket().unpack() : null);
        _o.isRtx = this.isRtx();
    }
}
exports.RtpTraceInfo = RtpTraceInfo;
class RtpTraceInfoT {
    rtpPacket;
    isRtx;
    constructor(rtpPacket = null, isRtx = false) {
        this.rtpPacket = rtpPacket;
        this.isRtx = isRtx;
    }
    pack(builder) {
        const rtpPacket = (this.rtpPacket !== null ? this.rtpPacket.pack(builder) : 0);
        return RtpTraceInfo.createRtpTraceInfo(builder, rtpPacket, this.isRtx);
    }
}
exports.RtpTraceInfoT = RtpTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/score-notification.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/score-notification.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScoreNotificationT = exports.ScoreNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const score_1 = __webpack_require__(/*! ../../fbs/producer/score */ "../../node_modules/mediasoup/node/lib/fbs/producer/score.js");
class ScoreNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsScoreNotification(bb, obj) {
        return (obj || new ScoreNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsScoreNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ScoreNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    scores(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new score_1.Score()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    scoresLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startScoreNotification(builder) {
        builder.startObject(1);
    }
    static addScores(builder, scoresOffset) {
        builder.addFieldOffset(0, scoresOffset, 0);
    }
    static createScoresVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startScoresVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endScoreNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // scores
        return offset;
    }
    static createScoreNotification(builder, scoresOffset) {
        ScoreNotification.startScoreNotification(builder);
        ScoreNotification.addScores(builder, scoresOffset);
        return ScoreNotification.endScoreNotification(builder);
    }
    unpack() {
        return new ScoreNotificationT(this.bb.createObjList(this.scores.bind(this), this.scoresLength()));
    }
    unpackTo(_o) {
        _o.scores = this.bb.createObjList(this.scores.bind(this), this.scoresLength());
    }
}
exports.ScoreNotification = ScoreNotification;
class ScoreNotificationT {
    scores;
    constructor(scores = []) {
        this.scores = scores;
    }
    pack(builder) {
        const scores = ScoreNotification.createScoresVector(builder, builder.createObjectOffsetList(this.scores));
        return ScoreNotification.createScoreNotification(builder, scores);
    }
}
exports.ScoreNotificationT = ScoreNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/score.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/score.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScoreT = exports.Score = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Score {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsScore(bb, obj) {
        return (obj || new Score()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsScore(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Score()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    encodingIdx() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    rid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    score() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startScore(builder) {
        builder.startObject(4);
    }
    static addEncodingIdx(builder, encodingIdx) {
        builder.addFieldInt32(0, encodingIdx, 0);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(1, ssrc, 0);
    }
    static addRid(builder, ridOffset) {
        builder.addFieldOffset(2, ridOffset, 0);
    }
    static addScore(builder, score) {
        builder.addFieldInt8(3, score, 0);
    }
    static endScore(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createScore(builder, encodingIdx, ssrc, ridOffset, score) {
        Score.startScore(builder);
        Score.addEncodingIdx(builder, encodingIdx);
        Score.addSsrc(builder, ssrc);
        Score.addRid(builder, ridOffset);
        Score.addScore(builder, score);
        return Score.endScore(builder);
    }
    unpack() {
        return new ScoreT(this.encodingIdx(), this.ssrc(), this.rid(), this.score());
    }
    unpackTo(_o) {
        _o.encodingIdx = this.encodingIdx();
        _o.ssrc = this.ssrc();
        _o.rid = this.rid();
        _o.score = this.score();
    }
}
exports.Score = Score;
class ScoreT {
    encodingIdx;
    ssrc;
    rid;
    score;
    constructor(encodingIdx = 0, ssrc = 0, rid = null, score = 0) {
        this.encodingIdx = encodingIdx;
        this.ssrc = ssrc;
        this.rid = rid;
        this.score = score;
    }
    pack(builder) {
        const rid = (this.rid !== null ? builder.createString(this.rid) : 0);
        return Score.createScore(builder, this.encodingIdx, this.ssrc, rid, this.score);
    }
}
exports.ScoreT = ScoreT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/send-notification.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/send-notification.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendNotificationT = exports.SendNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SendNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSendNotification(bb, obj) {
        return (obj || new SendNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSendNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SendNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    data(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSendNotification(builder) {
        builder.startObject(1);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(0, dataOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endSendNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data
        return offset;
    }
    static createSendNotification(builder, dataOffset) {
        SendNotification.startSendNotification(builder);
        SendNotification.addData(builder, dataOffset);
        return SendNotification.endSendNotification(builder);
    }
    unpack() {
        return new SendNotificationT(this.bb.createScalarList(this.data.bind(this), this.dataLength()));
    }
    unpackTo(_o) {
        _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());
    }
}
exports.SendNotification = SendNotification;
class SendNotificationT {
    data;
    constructor(data = []) {
        this.data = data;
    }
    pack(builder) {
        const data = SendNotification.createDataVector(builder, this.data);
        return SendNotification.createSendNotification(builder, data);
    }
}
exports.SendNotificationT = SendNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/sr-trace-info.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/sr-trace-info.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SrTraceInfoT = exports.SrTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SrTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSrTraceInfo(bb, obj) {
        return (obj || new SrTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSrTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SrTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    ntpSec() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    ntpFrac() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    rtpTs() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    packetCount() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    octetCount() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startSrTraceInfo(builder) {
        builder.startObject(6);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(0, ssrc, 0);
    }
    static addNtpSec(builder, ntpSec) {
        builder.addFieldInt32(1, ntpSec, 0);
    }
    static addNtpFrac(builder, ntpFrac) {
        builder.addFieldInt32(2, ntpFrac, 0);
    }
    static addRtpTs(builder, rtpTs) {
        builder.addFieldInt32(3, rtpTs, 0);
    }
    static addPacketCount(builder, packetCount) {
        builder.addFieldInt32(4, packetCount, 0);
    }
    static addOctetCount(builder, octetCount) {
        builder.addFieldInt32(5, octetCount, 0);
    }
    static endSrTraceInfo(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSrTraceInfo(builder, ssrc, ntpSec, ntpFrac, rtpTs, packetCount, octetCount) {
        SrTraceInfo.startSrTraceInfo(builder);
        SrTraceInfo.addSsrc(builder, ssrc);
        SrTraceInfo.addNtpSec(builder, ntpSec);
        SrTraceInfo.addNtpFrac(builder, ntpFrac);
        SrTraceInfo.addRtpTs(builder, rtpTs);
        SrTraceInfo.addPacketCount(builder, packetCount);
        SrTraceInfo.addOctetCount(builder, octetCount);
        return SrTraceInfo.endSrTraceInfo(builder);
    }
    unpack() {
        return new SrTraceInfoT(this.ssrc(), this.ntpSec(), this.ntpFrac(), this.rtpTs(), this.packetCount(), this.octetCount());
    }
    unpackTo(_o) {
        _o.ssrc = this.ssrc();
        _o.ntpSec = this.ntpSec();
        _o.ntpFrac = this.ntpFrac();
        _o.rtpTs = this.rtpTs();
        _o.packetCount = this.packetCount();
        _o.octetCount = this.octetCount();
    }
}
exports.SrTraceInfo = SrTraceInfo;
class SrTraceInfoT {
    ssrc;
    ntpSec;
    ntpFrac;
    rtpTs;
    packetCount;
    octetCount;
    constructor(ssrc = 0, ntpSec = 0, ntpFrac = 0, rtpTs = 0, packetCount = 0, octetCount = 0) {
        this.ssrc = ssrc;
        this.ntpSec = ntpSec;
        this.ntpFrac = ntpFrac;
        this.rtpTs = rtpTs;
        this.packetCount = packetCount;
        this.octetCount = octetCount;
    }
    pack(builder) {
        return SrTraceInfo.createSrTraceInfo(builder, this.ssrc, this.ntpSec, this.ntpFrac, this.rtpTs, this.packetCount, this.octetCount);
    }
}
exports.SrTraceInfoT = SrTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-event-type.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/trace-event-type.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceEventType = void 0;
var TraceEventType;
(function (TraceEventType) {
    TraceEventType[TraceEventType["KEYFRAME"] = 0] = "KEYFRAME";
    TraceEventType[TraceEventType["FIR"] = 1] = "FIR";
    TraceEventType[TraceEventType["NACK"] = 2] = "NACK";
    TraceEventType[TraceEventType["PLI"] = 3] = "PLI";
    TraceEventType[TraceEventType["RTP"] = 4] = "RTP";
    TraceEventType[TraceEventType["SR"] = 5] = "SR";
})(TraceEventType || (exports.TraceEventType = TraceEventType = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-info.js":
/*!************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/trace-info.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToTraceInfo = exports.unionToTraceInfo = exports.TraceInfo = void 0;
const fir_trace_info_1 = __webpack_require__(/*! ../../fbs/producer/fir-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/fir-trace-info.js");
const key_frame_trace_info_1 = __webpack_require__(/*! ../../fbs/producer/key-frame-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/key-frame-trace-info.js");
const pli_trace_info_1 = __webpack_require__(/*! ../../fbs/producer/pli-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/pli-trace-info.js");
const rtp_trace_info_1 = __webpack_require__(/*! ../../fbs/producer/rtp-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/rtp-trace-info.js");
const sr_trace_info_1 = __webpack_require__(/*! ../../fbs/producer/sr-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/sr-trace-info.js");
var TraceInfo;
(function (TraceInfo) {
    TraceInfo[TraceInfo["NONE"] = 0] = "NONE";
    TraceInfo[TraceInfo["KeyFrameTraceInfo"] = 1] = "KeyFrameTraceInfo";
    TraceInfo[TraceInfo["FirTraceInfo"] = 2] = "FirTraceInfo";
    TraceInfo[TraceInfo["PliTraceInfo"] = 3] = "PliTraceInfo";
    TraceInfo[TraceInfo["RtpTraceInfo"] = 4] = "RtpTraceInfo";
    TraceInfo[TraceInfo["SrTraceInfo"] = 5] = "SrTraceInfo";
})(TraceInfo || (exports.TraceInfo = TraceInfo = {}));
function unionToTraceInfo(type, accessor) {
    switch (TraceInfo[type]) {
        case 'NONE': return null;
        case 'KeyFrameTraceInfo': return accessor(new key_frame_trace_info_1.KeyFrameTraceInfo());
        case 'FirTraceInfo': return accessor(new fir_trace_info_1.FirTraceInfo());
        case 'PliTraceInfo': return accessor(new pli_trace_info_1.PliTraceInfo());
        case 'RtpTraceInfo': return accessor(new rtp_trace_info_1.RtpTraceInfo());
        case 'SrTraceInfo': return accessor(new sr_trace_info_1.SrTraceInfo());
        default: return null;
    }
}
exports.unionToTraceInfo = unionToTraceInfo;
function unionListToTraceInfo(type, accessor, index) {
    switch (TraceInfo[type]) {
        case 'NONE': return null;
        case 'KeyFrameTraceInfo': return accessor(index, new key_frame_trace_info_1.KeyFrameTraceInfo());
        case 'FirTraceInfo': return accessor(index, new fir_trace_info_1.FirTraceInfo());
        case 'PliTraceInfo': return accessor(index, new pli_trace_info_1.PliTraceInfo());
        case 'RtpTraceInfo': return accessor(index, new rtp_trace_info_1.RtpTraceInfo());
        case 'SrTraceInfo': return accessor(index, new sr_trace_info_1.SrTraceInfo());
        default: return null;
    }
}
exports.unionListToTraceInfo = unionListToTraceInfo;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-notification.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/trace-notification.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceNotificationT = exports.TraceNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const trace_direction_1 = __webpack_require__(/*! ../../fbs/common/trace-direction */ "../../node_modules/mediasoup/node/lib/fbs/common/trace-direction.js");
const trace_event_type_1 = __webpack_require__(/*! ../../fbs/producer/trace-event-type */ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-event-type.js");
const trace_info_1 = __webpack_require__(/*! ../../fbs/producer/trace-info */ "../../node_modules/mediasoup/node/lib/fbs/producer/trace-info.js");
class TraceNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTraceNotification(bb, obj) {
        return (obj || new TraceNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTraceNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TraceNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_event_type_1.TraceEventType.KEYFRAME;
    }
    timestamp() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    direction() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_direction_1.TraceDirection.DIRECTION_IN;
    }
    infoType() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_info_1.TraceInfo.NONE;
    }
    info(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startTraceNotification(builder) {
        builder.startObject(5);
    }
    static addType(builder, type) {
        builder.addFieldInt8(0, type, trace_event_type_1.TraceEventType.KEYFRAME);
    }
    static addTimestamp(builder, timestamp) {
        builder.addFieldInt64(1, timestamp, BigInt('0'));
    }
    static addDirection(builder, direction) {
        builder.addFieldInt8(2, direction, trace_direction_1.TraceDirection.DIRECTION_IN);
    }
    static addInfoType(builder, infoType) {
        builder.addFieldInt8(3, infoType, trace_info_1.TraceInfo.NONE);
    }
    static addInfo(builder, infoOffset) {
        builder.addFieldOffset(4, infoOffset, 0);
    }
    static endTraceNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTraceNotification(builder, type, timestamp, direction, infoType, infoOffset) {
        TraceNotification.startTraceNotification(builder);
        TraceNotification.addType(builder, type);
        TraceNotification.addTimestamp(builder, timestamp);
        TraceNotification.addDirection(builder, direction);
        TraceNotification.addInfoType(builder, infoType);
        TraceNotification.addInfo(builder, infoOffset);
        return TraceNotification.endTraceNotification(builder);
    }
    unpack() {
        return new TraceNotificationT(this.type(), this.timestamp(), this.direction(), this.infoType(), (() => {
            const temp = (0, trace_info_1.unionToTraceInfo)(this.infoType(), this.info.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.type = this.type();
        _o.timestamp = this.timestamp();
        _o.direction = this.direction();
        _o.infoType = this.infoType();
        _o.info = (() => {
            const temp = (0, trace_info_1.unionToTraceInfo)(this.infoType(), this.info.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
exports.TraceNotification = TraceNotification;
class TraceNotificationT {
    type;
    timestamp;
    direction;
    infoType;
    info;
    constructor(type = trace_event_type_1.TraceEventType.KEYFRAME, timestamp = BigInt('0'), direction = trace_direction_1.TraceDirection.DIRECTION_IN, infoType = trace_info_1.TraceInfo.NONE, info = null) {
        this.type = type;
        this.timestamp = timestamp;
        this.direction = direction;
        this.infoType = infoType;
        this.info = info;
    }
    pack(builder) {
        const info = builder.createObjectOffset(this.info);
        return TraceNotification.createTraceNotification(builder, this.type, this.timestamp, this.direction, this.infoType, info);
    }
}
exports.TraceNotificationT = TraceNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/producer/video-orientation-change-notification.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/producer/video-orientation-change-notification.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VideoOrientationChangeNotificationT = exports.VideoOrientationChangeNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class VideoOrientationChangeNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsVideoOrientationChangeNotification(bb, obj) {
        return (obj || new VideoOrientationChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsVideoOrientationChangeNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new VideoOrientationChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    camera() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    flip() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    rotation() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    static startVideoOrientationChangeNotification(builder) {
        builder.startObject(3);
    }
    static addCamera(builder, camera) {
        builder.addFieldInt8(0, +camera, +false);
    }
    static addFlip(builder, flip) {
        builder.addFieldInt8(1, +flip, +false);
    }
    static addRotation(builder, rotation) {
        builder.addFieldInt16(2, rotation, 0);
    }
    static endVideoOrientationChangeNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createVideoOrientationChangeNotification(builder, camera, flip, rotation) {
        VideoOrientationChangeNotification.startVideoOrientationChangeNotification(builder);
        VideoOrientationChangeNotification.addCamera(builder, camera);
        VideoOrientationChangeNotification.addFlip(builder, flip);
        VideoOrientationChangeNotification.addRotation(builder, rotation);
        return VideoOrientationChangeNotification.endVideoOrientationChangeNotification(builder);
    }
    unpack() {
        return new VideoOrientationChangeNotificationT(this.camera(), this.flip(), this.rotation());
    }
    unpackTo(_o) {
        _o.camera = this.camera();
        _o.flip = this.flip();
        _o.rotation = this.rotation();
    }
}
exports.VideoOrientationChangeNotification = VideoOrientationChangeNotification;
class VideoOrientationChangeNotificationT {
    camera;
    flip;
    rotation;
    constructor(camera = false, flip = false, rotation = 0) {
        this.camera = camera;
        this.flip = flip;
        this.rotation = rotation;
    }
    pack(builder) {
        return VideoOrientationChangeNotification.createVideoOrientationChangeNotification(builder, this.camera, this.flip, this.rotation);
    }
}
exports.VideoOrientationChangeNotificationT = VideoOrientationChangeNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/request.js":
/*!************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/request.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestT = exports.Request = exports.Method = exports.Body = void 0;
var body_1 = __webpack_require__(/*! ./request/body */ "../../node_modules/mediasoup/node/lib/fbs/request/body.js");
Object.defineProperty(exports, "Body", ({ enumerable: true, get: function () { return body_1.Body; } }));
var method_1 = __webpack_require__(/*! ./request/method */ "../../node_modules/mediasoup/node/lib/fbs/request/method.js");
Object.defineProperty(exports, "Method", ({ enumerable: true, get: function () { return method_1.Method; } }));
var request_1 = __webpack_require__(/*! ./request/request */ "../../node_modules/mediasoup/node/lib/fbs/request/request.js");
Object.defineProperty(exports, "Request", ({ enumerable: true, get: function () { return request_1.Request; } }));
Object.defineProperty(exports, "RequestT", ({ enumerable: true, get: function () { return request_1.RequestT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/request/body.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/request/body.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToBody = exports.unionToBody = exports.Body = void 0;
const enable_trace_event_request_1 = __webpack_require__(/*! ../../fbs/consumer/enable-trace-event-request */ "../../node_modules/mediasoup/node/lib/fbs/consumer/enable-trace-event-request.js");
const set_preferred_layers_request_1 = __webpack_require__(/*! ../../fbs/consumer/set-preferred-layers-request */ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-preferred-layers-request.js");
const set_priority_request_1 = __webpack_require__(/*! ../../fbs/consumer/set-priority-request */ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-priority-request.js");
const add_subchannel_request_1 = __webpack_require__(/*! ../../fbs/data-consumer/add-subchannel-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/add-subchannel-request.js");
const remove_subchannel_request_1 = __webpack_require__(/*! ../../fbs/data-consumer/remove-subchannel-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/remove-subchannel-request.js");
const send_request_1 = __webpack_require__(/*! ../../fbs/data-consumer/send-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/send-request.js");
const set_buffered_amount_low_threshold_request_1 = __webpack_require__(/*! ../../fbs/data-consumer/set-buffered-amount-low-threshold-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-buffered-amount-low-threshold-request.js");
const set_subchannels_request_1 = __webpack_require__(/*! ../../fbs/data-consumer/set-subchannels-request */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-subchannels-request.js");
const connect_request_1 = __webpack_require__(/*! ../../fbs/pipe-transport/connect-request */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/connect-request.js");
const connect_request_2 = __webpack_require__(/*! ../../fbs/plain-transport/connect-request */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/connect-request.js");
const enable_trace_event_request_2 = __webpack_require__(/*! ../../fbs/producer/enable-trace-event-request */ "../../node_modules/mediasoup/node/lib/fbs/producer/enable-trace-event-request.js");
const close_rtp_observer_request_1 = __webpack_require__(/*! ../../fbs/router/close-rtp-observer-request */ "../../node_modules/mediasoup/node/lib/fbs/router/close-rtp-observer-request.js");
const close_transport_request_1 = __webpack_require__(/*! ../../fbs/router/close-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/close-transport-request.js");
const create_active_speaker_observer_request_1 = __webpack_require__(/*! ../../fbs/router/create-active-speaker-observer-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-active-speaker-observer-request.js");
const create_audio_level_observer_request_1 = __webpack_require__(/*! ../../fbs/router/create-audio-level-observer-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-audio-level-observer-request.js");
const create_direct_transport_request_1 = __webpack_require__(/*! ../../fbs/router/create-direct-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-direct-transport-request.js");
const create_pipe_transport_request_1 = __webpack_require__(/*! ../../fbs/router/create-pipe-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-pipe-transport-request.js");
const create_plain_transport_request_1 = __webpack_require__(/*! ../../fbs/router/create-plain-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-plain-transport-request.js");
const create_web_rtc_transport_request_1 = __webpack_require__(/*! ../../fbs/router/create-web-rtc-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-web-rtc-transport-request.js");
const add_producer_request_1 = __webpack_require__(/*! ../../fbs/rtp-observer/add-producer-request */ "../../node_modules/mediasoup/node/lib/fbs/rtp-observer/add-producer-request.js");
const remove_producer_request_1 = __webpack_require__(/*! ../../fbs/rtp-observer/remove-producer-request */ "../../node_modules/mediasoup/node/lib/fbs/rtp-observer/remove-producer-request.js");
const close_consumer_request_1 = __webpack_require__(/*! ../../fbs/transport/close-consumer-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/close-consumer-request.js");
const close_data_consumer_request_1 = __webpack_require__(/*! ../../fbs/transport/close-data-consumer-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/close-data-consumer-request.js");
const close_data_producer_request_1 = __webpack_require__(/*! ../../fbs/transport/close-data-producer-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/close-data-producer-request.js");
const close_producer_request_1 = __webpack_require__(/*! ../../fbs/transport/close-producer-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/close-producer-request.js");
const consume_data_request_1 = __webpack_require__(/*! ../../fbs/transport/consume-data-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-data-request.js");
const consume_request_1 = __webpack_require__(/*! ../../fbs/transport/consume-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-request.js");
const enable_trace_event_request_3 = __webpack_require__(/*! ../../fbs/transport/enable-trace-event-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/enable-trace-event-request.js");
const produce_data_request_1 = __webpack_require__(/*! ../../fbs/transport/produce-data-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-data-request.js");
const produce_request_1 = __webpack_require__(/*! ../../fbs/transport/produce-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-request.js");
const set_max_incoming_bitrate_request_1 = __webpack_require__(/*! ../../fbs/transport/set-max-incoming-bitrate-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/set-max-incoming-bitrate-request.js");
const set_max_outgoing_bitrate_request_1 = __webpack_require__(/*! ../../fbs/transport/set-max-outgoing-bitrate-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/set-max-outgoing-bitrate-request.js");
const set_min_outgoing_bitrate_request_1 = __webpack_require__(/*! ../../fbs/transport/set-min-outgoing-bitrate-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/set-min-outgoing-bitrate-request.js");
const connect_request_3 = __webpack_require__(/*! ../../fbs/web-rtc-transport/connect-request */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/connect-request.js");
const close_router_request_1 = __webpack_require__(/*! ../../fbs/worker/close-router-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/close-router-request.js");
const close_web_rtc_server_request_1 = __webpack_require__(/*! ../../fbs/worker/close-web-rtc-server-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/close-web-rtc-server-request.js");
const create_router_request_1 = __webpack_require__(/*! ../../fbs/worker/create-router-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/create-router-request.js");
const create_web_rtc_server_request_1 = __webpack_require__(/*! ../../fbs/worker/create-web-rtc-server-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/create-web-rtc-server-request.js");
const update_settings_request_1 = __webpack_require__(/*! ../../fbs/worker/update-settings-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/update-settings-request.js");
var Body;
(function (Body) {
    Body[Body["NONE"] = 0] = "NONE";
    Body[Body["Worker_UpdateSettingsRequest"] = 1] = "Worker_UpdateSettingsRequest";
    Body[Body["Worker_CreateWebRtcServerRequest"] = 2] = "Worker_CreateWebRtcServerRequest";
    Body[Body["Worker_CloseWebRtcServerRequest"] = 3] = "Worker_CloseWebRtcServerRequest";
    Body[Body["Worker_CreateRouterRequest"] = 4] = "Worker_CreateRouterRequest";
    Body[Body["Worker_CloseRouterRequest"] = 5] = "Worker_CloseRouterRequest";
    Body[Body["Router_CreateWebRtcTransportRequest"] = 6] = "Router_CreateWebRtcTransportRequest";
    Body[Body["Router_CreatePlainTransportRequest"] = 7] = "Router_CreatePlainTransportRequest";
    Body[Body["Router_CreatePipeTransportRequest"] = 8] = "Router_CreatePipeTransportRequest";
    Body[Body["Router_CreateDirectTransportRequest"] = 9] = "Router_CreateDirectTransportRequest";
    Body[Body["Router_CreateActiveSpeakerObserverRequest"] = 10] = "Router_CreateActiveSpeakerObserverRequest";
    Body[Body["Router_CreateAudioLevelObserverRequest"] = 11] = "Router_CreateAudioLevelObserverRequest";
    Body[Body["Router_CloseTransportRequest"] = 12] = "Router_CloseTransportRequest";
    Body[Body["Router_CloseRtpObserverRequest"] = 13] = "Router_CloseRtpObserverRequest";
    Body[Body["Transport_SetMaxIncomingBitrateRequest"] = 14] = "Transport_SetMaxIncomingBitrateRequest";
    Body[Body["Transport_SetMaxOutgoingBitrateRequest"] = 15] = "Transport_SetMaxOutgoingBitrateRequest";
    Body[Body["Transport_SetMinOutgoingBitrateRequest"] = 16] = "Transport_SetMinOutgoingBitrateRequest";
    Body[Body["Transport_ProduceRequest"] = 17] = "Transport_ProduceRequest";
    Body[Body["Transport_ConsumeRequest"] = 18] = "Transport_ConsumeRequest";
    Body[Body["Transport_ProduceDataRequest"] = 19] = "Transport_ProduceDataRequest";
    Body[Body["Transport_ConsumeDataRequest"] = 20] = "Transport_ConsumeDataRequest";
    Body[Body["Transport_EnableTraceEventRequest"] = 21] = "Transport_EnableTraceEventRequest";
    Body[Body["Transport_CloseProducerRequest"] = 22] = "Transport_CloseProducerRequest";
    Body[Body["Transport_CloseConsumerRequest"] = 23] = "Transport_CloseConsumerRequest";
    Body[Body["Transport_CloseDataProducerRequest"] = 24] = "Transport_CloseDataProducerRequest";
    Body[Body["Transport_CloseDataConsumerRequest"] = 25] = "Transport_CloseDataConsumerRequest";
    Body[Body["PlainTransport_ConnectRequest"] = 26] = "PlainTransport_ConnectRequest";
    Body[Body["PipeTransport_ConnectRequest"] = 27] = "PipeTransport_ConnectRequest";
    Body[Body["WebRtcTransport_ConnectRequest"] = 28] = "WebRtcTransport_ConnectRequest";
    Body[Body["Producer_EnableTraceEventRequest"] = 29] = "Producer_EnableTraceEventRequest";
    Body[Body["Consumer_SetPreferredLayersRequest"] = 30] = "Consumer_SetPreferredLayersRequest";
    Body[Body["Consumer_SetPriorityRequest"] = 31] = "Consumer_SetPriorityRequest";
    Body[Body["Consumer_EnableTraceEventRequest"] = 32] = "Consumer_EnableTraceEventRequest";
    Body[Body["DataConsumer_SetBufferedAmountLowThresholdRequest"] = 33] = "DataConsumer_SetBufferedAmountLowThresholdRequest";
    Body[Body["DataConsumer_SendRequest"] = 34] = "DataConsumer_SendRequest";
    Body[Body["DataConsumer_SetSubchannelsRequest"] = 35] = "DataConsumer_SetSubchannelsRequest";
    Body[Body["DataConsumer_AddSubchannelRequest"] = 36] = "DataConsumer_AddSubchannelRequest";
    Body[Body["DataConsumer_RemoveSubchannelRequest"] = 37] = "DataConsumer_RemoveSubchannelRequest";
    Body[Body["RtpObserver_AddProducerRequest"] = 38] = "RtpObserver_AddProducerRequest";
    Body[Body["RtpObserver_RemoveProducerRequest"] = 39] = "RtpObserver_RemoveProducerRequest";
})(Body || (exports.Body = Body = {}));
function unionToBody(type, accessor) {
    switch (Body[type]) {
        case 'NONE': return null;
        case 'Worker_UpdateSettingsRequest': return accessor(new update_settings_request_1.UpdateSettingsRequest());
        case 'Worker_CreateWebRtcServerRequest': return accessor(new create_web_rtc_server_request_1.CreateWebRtcServerRequest());
        case 'Worker_CloseWebRtcServerRequest': return accessor(new close_web_rtc_server_request_1.CloseWebRtcServerRequest());
        case 'Worker_CreateRouterRequest': return accessor(new create_router_request_1.CreateRouterRequest());
        case 'Worker_CloseRouterRequest': return accessor(new close_router_request_1.CloseRouterRequest());
        case 'Router_CreateWebRtcTransportRequest': return accessor(new create_web_rtc_transport_request_1.CreateWebRtcTransportRequest());
        case 'Router_CreatePlainTransportRequest': return accessor(new create_plain_transport_request_1.CreatePlainTransportRequest());
        case 'Router_CreatePipeTransportRequest': return accessor(new create_pipe_transport_request_1.CreatePipeTransportRequest());
        case 'Router_CreateDirectTransportRequest': return accessor(new create_direct_transport_request_1.CreateDirectTransportRequest());
        case 'Router_CreateActiveSpeakerObserverRequest': return accessor(new create_active_speaker_observer_request_1.CreateActiveSpeakerObserverRequest());
        case 'Router_CreateAudioLevelObserverRequest': return accessor(new create_audio_level_observer_request_1.CreateAudioLevelObserverRequest());
        case 'Router_CloseTransportRequest': return accessor(new close_transport_request_1.CloseTransportRequest());
        case 'Router_CloseRtpObserverRequest': return accessor(new close_rtp_observer_request_1.CloseRtpObserverRequest());
        case 'Transport_SetMaxIncomingBitrateRequest': return accessor(new set_max_incoming_bitrate_request_1.SetMaxIncomingBitrateRequest());
        case 'Transport_SetMaxOutgoingBitrateRequest': return accessor(new set_max_outgoing_bitrate_request_1.SetMaxOutgoingBitrateRequest());
        case 'Transport_SetMinOutgoingBitrateRequest': return accessor(new set_min_outgoing_bitrate_request_1.SetMinOutgoingBitrateRequest());
        case 'Transport_ProduceRequest': return accessor(new produce_request_1.ProduceRequest());
        case 'Transport_ConsumeRequest': return accessor(new consume_request_1.ConsumeRequest());
        case 'Transport_ProduceDataRequest': return accessor(new produce_data_request_1.ProduceDataRequest());
        case 'Transport_ConsumeDataRequest': return accessor(new consume_data_request_1.ConsumeDataRequest());
        case 'Transport_EnableTraceEventRequest': return accessor(new enable_trace_event_request_3.EnableTraceEventRequest());
        case 'Transport_CloseProducerRequest': return accessor(new close_producer_request_1.CloseProducerRequest());
        case 'Transport_CloseConsumerRequest': return accessor(new close_consumer_request_1.CloseConsumerRequest());
        case 'Transport_CloseDataProducerRequest': return accessor(new close_data_producer_request_1.CloseDataProducerRequest());
        case 'Transport_CloseDataConsumerRequest': return accessor(new close_data_consumer_request_1.CloseDataConsumerRequest());
        case 'PlainTransport_ConnectRequest': return accessor(new connect_request_2.ConnectRequest());
        case 'PipeTransport_ConnectRequest': return accessor(new connect_request_1.ConnectRequest());
        case 'WebRtcTransport_ConnectRequest': return accessor(new connect_request_3.ConnectRequest());
        case 'Producer_EnableTraceEventRequest': return accessor(new enable_trace_event_request_2.EnableTraceEventRequest());
        case 'Consumer_SetPreferredLayersRequest': return accessor(new set_preferred_layers_request_1.SetPreferredLayersRequest());
        case 'Consumer_SetPriorityRequest': return accessor(new set_priority_request_1.SetPriorityRequest());
        case 'Consumer_EnableTraceEventRequest': return accessor(new enable_trace_event_request_1.EnableTraceEventRequest());
        case 'DataConsumer_SetBufferedAmountLowThresholdRequest': return accessor(new set_buffered_amount_low_threshold_request_1.SetBufferedAmountLowThresholdRequest());
        case 'DataConsumer_SendRequest': return accessor(new send_request_1.SendRequest());
        case 'DataConsumer_SetSubchannelsRequest': return accessor(new set_subchannels_request_1.SetSubchannelsRequest());
        case 'DataConsumer_AddSubchannelRequest': return accessor(new add_subchannel_request_1.AddSubchannelRequest());
        case 'DataConsumer_RemoveSubchannelRequest': return accessor(new remove_subchannel_request_1.RemoveSubchannelRequest());
        case 'RtpObserver_AddProducerRequest': return accessor(new add_producer_request_1.AddProducerRequest());
        case 'RtpObserver_RemoveProducerRequest': return accessor(new remove_producer_request_1.RemoveProducerRequest());
        default: return null;
    }
}
exports.unionToBody = unionToBody;
function unionListToBody(type, accessor, index) {
    switch (Body[type]) {
        case 'NONE': return null;
        case 'Worker_UpdateSettingsRequest': return accessor(index, new update_settings_request_1.UpdateSettingsRequest());
        case 'Worker_CreateWebRtcServerRequest': return accessor(index, new create_web_rtc_server_request_1.CreateWebRtcServerRequest());
        case 'Worker_CloseWebRtcServerRequest': return accessor(index, new close_web_rtc_server_request_1.CloseWebRtcServerRequest());
        case 'Worker_CreateRouterRequest': return accessor(index, new create_router_request_1.CreateRouterRequest());
        case 'Worker_CloseRouterRequest': return accessor(index, new close_router_request_1.CloseRouterRequest());
        case 'Router_CreateWebRtcTransportRequest': return accessor(index, new create_web_rtc_transport_request_1.CreateWebRtcTransportRequest());
        case 'Router_CreatePlainTransportRequest': return accessor(index, new create_plain_transport_request_1.CreatePlainTransportRequest());
        case 'Router_CreatePipeTransportRequest': return accessor(index, new create_pipe_transport_request_1.CreatePipeTransportRequest());
        case 'Router_CreateDirectTransportRequest': return accessor(index, new create_direct_transport_request_1.CreateDirectTransportRequest());
        case 'Router_CreateActiveSpeakerObserverRequest': return accessor(index, new create_active_speaker_observer_request_1.CreateActiveSpeakerObserverRequest());
        case 'Router_CreateAudioLevelObserverRequest': return accessor(index, new create_audio_level_observer_request_1.CreateAudioLevelObserverRequest());
        case 'Router_CloseTransportRequest': return accessor(index, new close_transport_request_1.CloseTransportRequest());
        case 'Router_CloseRtpObserverRequest': return accessor(index, new close_rtp_observer_request_1.CloseRtpObserverRequest());
        case 'Transport_SetMaxIncomingBitrateRequest': return accessor(index, new set_max_incoming_bitrate_request_1.SetMaxIncomingBitrateRequest());
        case 'Transport_SetMaxOutgoingBitrateRequest': return accessor(index, new set_max_outgoing_bitrate_request_1.SetMaxOutgoingBitrateRequest());
        case 'Transport_SetMinOutgoingBitrateRequest': return accessor(index, new set_min_outgoing_bitrate_request_1.SetMinOutgoingBitrateRequest());
        case 'Transport_ProduceRequest': return accessor(index, new produce_request_1.ProduceRequest());
        case 'Transport_ConsumeRequest': return accessor(index, new consume_request_1.ConsumeRequest());
        case 'Transport_ProduceDataRequest': return accessor(index, new produce_data_request_1.ProduceDataRequest());
        case 'Transport_ConsumeDataRequest': return accessor(index, new consume_data_request_1.ConsumeDataRequest());
        case 'Transport_EnableTraceEventRequest': return accessor(index, new enable_trace_event_request_3.EnableTraceEventRequest());
        case 'Transport_CloseProducerRequest': return accessor(index, new close_producer_request_1.CloseProducerRequest());
        case 'Transport_CloseConsumerRequest': return accessor(index, new close_consumer_request_1.CloseConsumerRequest());
        case 'Transport_CloseDataProducerRequest': return accessor(index, new close_data_producer_request_1.CloseDataProducerRequest());
        case 'Transport_CloseDataConsumerRequest': return accessor(index, new close_data_consumer_request_1.CloseDataConsumerRequest());
        case 'PlainTransport_ConnectRequest': return accessor(index, new connect_request_2.ConnectRequest());
        case 'PipeTransport_ConnectRequest': return accessor(index, new connect_request_1.ConnectRequest());
        case 'WebRtcTransport_ConnectRequest': return accessor(index, new connect_request_3.ConnectRequest());
        case 'Producer_EnableTraceEventRequest': return accessor(index, new enable_trace_event_request_2.EnableTraceEventRequest());
        case 'Consumer_SetPreferredLayersRequest': return accessor(index, new set_preferred_layers_request_1.SetPreferredLayersRequest());
        case 'Consumer_SetPriorityRequest': return accessor(index, new set_priority_request_1.SetPriorityRequest());
        case 'Consumer_EnableTraceEventRequest': return accessor(index, new enable_trace_event_request_1.EnableTraceEventRequest());
        case 'DataConsumer_SetBufferedAmountLowThresholdRequest': return accessor(index, new set_buffered_amount_low_threshold_request_1.SetBufferedAmountLowThresholdRequest());
        case 'DataConsumer_SendRequest': return accessor(index, new send_request_1.SendRequest());
        case 'DataConsumer_SetSubchannelsRequest': return accessor(index, new set_subchannels_request_1.SetSubchannelsRequest());
        case 'DataConsumer_AddSubchannelRequest': return accessor(index, new add_subchannel_request_1.AddSubchannelRequest());
        case 'DataConsumer_RemoveSubchannelRequest': return accessor(index, new remove_subchannel_request_1.RemoveSubchannelRequest());
        case 'RtpObserver_AddProducerRequest': return accessor(index, new add_producer_request_1.AddProducerRequest());
        case 'RtpObserver_RemoveProducerRequest': return accessor(index, new remove_producer_request_1.RemoveProducerRequest());
        default: return null;
    }
}
exports.unionListToBody = unionListToBody;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/request/method.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/request/method.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Method = void 0;
var Method;
(function (Method) {
    Method[Method["WORKER_CLOSE"] = 0] = "WORKER_CLOSE";
    Method[Method["WORKER_DUMP"] = 1] = "WORKER_DUMP";
    Method[Method["WORKER_GET_RESOURCE_USAGE"] = 2] = "WORKER_GET_RESOURCE_USAGE";
    Method[Method["WORKER_UPDATE_SETTINGS"] = 3] = "WORKER_UPDATE_SETTINGS";
    Method[Method["WORKER_CREATE_WEBRTCSERVER"] = 4] = "WORKER_CREATE_WEBRTCSERVER";
    Method[Method["WORKER_CREATE_ROUTER"] = 5] = "WORKER_CREATE_ROUTER";
    Method[Method["WORKER_WEBRTCSERVER_CLOSE"] = 6] = "WORKER_WEBRTCSERVER_CLOSE";
    Method[Method["WORKER_CLOSE_ROUTER"] = 7] = "WORKER_CLOSE_ROUTER";
    Method[Method["WEBRTCSERVER_DUMP"] = 8] = "WEBRTCSERVER_DUMP";
    Method[Method["ROUTER_DUMP"] = 9] = "ROUTER_DUMP";
    Method[Method["ROUTER_CREATE_WEBRTCTRANSPORT"] = 10] = "ROUTER_CREATE_WEBRTCTRANSPORT";
    Method[Method["ROUTER_CREATE_WEBRTCTRANSPORT_WITH_SERVER"] = 11] = "ROUTER_CREATE_WEBRTCTRANSPORT_WITH_SERVER";
    Method[Method["ROUTER_CREATE_PLAINTRANSPORT"] = 12] = "ROUTER_CREATE_PLAINTRANSPORT";
    Method[Method["ROUTER_CREATE_PIPETRANSPORT"] = 13] = "ROUTER_CREATE_PIPETRANSPORT";
    Method[Method["ROUTER_CREATE_DIRECTTRANSPORT"] = 14] = "ROUTER_CREATE_DIRECTTRANSPORT";
    Method[Method["ROUTER_CLOSE_TRANSPORT"] = 15] = "ROUTER_CLOSE_TRANSPORT";
    Method[Method["ROUTER_CREATE_ACTIVESPEAKEROBSERVER"] = 16] = "ROUTER_CREATE_ACTIVESPEAKEROBSERVER";
    Method[Method["ROUTER_CREATE_AUDIOLEVELOBSERVER"] = 17] = "ROUTER_CREATE_AUDIOLEVELOBSERVER";
    Method[Method["ROUTER_CLOSE_RTPOBSERVER"] = 18] = "ROUTER_CLOSE_RTPOBSERVER";
    Method[Method["TRANSPORT_DUMP"] = 19] = "TRANSPORT_DUMP";
    Method[Method["TRANSPORT_GET_STATS"] = 20] = "TRANSPORT_GET_STATS";
    Method[Method["TRANSPORT_CONNECT"] = 21] = "TRANSPORT_CONNECT";
    Method[Method["TRANSPORT_SET_MAX_INCOMING_BITRATE"] = 22] = "TRANSPORT_SET_MAX_INCOMING_BITRATE";
    Method[Method["TRANSPORT_SET_MAX_OUTGOING_BITRATE"] = 23] = "TRANSPORT_SET_MAX_OUTGOING_BITRATE";
    Method[Method["TRANSPORT_SET_MIN_OUTGOING_BITRATE"] = 24] = "TRANSPORT_SET_MIN_OUTGOING_BITRATE";
    Method[Method["TRANSPORT_RESTART_ICE"] = 25] = "TRANSPORT_RESTART_ICE";
    Method[Method["TRANSPORT_PRODUCE"] = 26] = "TRANSPORT_PRODUCE";
    Method[Method["TRANSPORT_PRODUCE_DATA"] = 27] = "TRANSPORT_PRODUCE_DATA";
    Method[Method["TRANSPORT_CONSUME"] = 28] = "TRANSPORT_CONSUME";
    Method[Method["TRANSPORT_CONSUME_DATA"] = 29] = "TRANSPORT_CONSUME_DATA";
    Method[Method["TRANSPORT_ENABLE_TRACE_EVENT"] = 30] = "TRANSPORT_ENABLE_TRACE_EVENT";
    Method[Method["TRANSPORT_CLOSE_PRODUCER"] = 31] = "TRANSPORT_CLOSE_PRODUCER";
    Method[Method["TRANSPORT_CLOSE_CONSUMER"] = 32] = "TRANSPORT_CLOSE_CONSUMER";
    Method[Method["TRANSPORT_CLOSE_DATAPRODUCER"] = 33] = "TRANSPORT_CLOSE_DATAPRODUCER";
    Method[Method["TRANSPORT_CLOSE_DATACONSUMER"] = 34] = "TRANSPORT_CLOSE_DATACONSUMER";
    Method[Method["PLAINTRANSPORT_CONNECT"] = 35] = "PLAINTRANSPORT_CONNECT";
    Method[Method["PIPETRANSPORT_CONNECT"] = 36] = "PIPETRANSPORT_CONNECT";
    Method[Method["WEBRTCTRANSPORT_CONNECT"] = 37] = "WEBRTCTRANSPORT_CONNECT";
    Method[Method["PRODUCER_DUMP"] = 38] = "PRODUCER_DUMP";
    Method[Method["PRODUCER_GET_STATS"] = 39] = "PRODUCER_GET_STATS";
    Method[Method["PRODUCER_PAUSE"] = 40] = "PRODUCER_PAUSE";
    Method[Method["PRODUCER_RESUME"] = 41] = "PRODUCER_RESUME";
    Method[Method["PRODUCER_ENABLE_TRACE_EVENT"] = 42] = "PRODUCER_ENABLE_TRACE_EVENT";
    Method[Method["CONSUMER_DUMP"] = 43] = "CONSUMER_DUMP";
    Method[Method["CONSUMER_GET_STATS"] = 44] = "CONSUMER_GET_STATS";
    Method[Method["CONSUMER_PAUSE"] = 45] = "CONSUMER_PAUSE";
    Method[Method["CONSUMER_RESUME"] = 46] = "CONSUMER_RESUME";
    Method[Method["CONSUMER_SET_PREFERRED_LAYERS"] = 47] = "CONSUMER_SET_PREFERRED_LAYERS";
    Method[Method["CONSUMER_SET_PRIORITY"] = 48] = "CONSUMER_SET_PRIORITY";
    Method[Method["CONSUMER_REQUEST_KEY_FRAME"] = 49] = "CONSUMER_REQUEST_KEY_FRAME";
    Method[Method["CONSUMER_ENABLE_TRACE_EVENT"] = 50] = "CONSUMER_ENABLE_TRACE_EVENT";
    Method[Method["DATAPRODUCER_DUMP"] = 51] = "DATAPRODUCER_DUMP";
    Method[Method["DATAPRODUCER_GET_STATS"] = 52] = "DATAPRODUCER_GET_STATS";
    Method[Method["DATAPRODUCER_PAUSE"] = 53] = "DATAPRODUCER_PAUSE";
    Method[Method["DATAPRODUCER_RESUME"] = 54] = "DATAPRODUCER_RESUME";
    Method[Method["DATACONSUMER_DUMP"] = 55] = "DATACONSUMER_DUMP";
    Method[Method["DATACONSUMER_GET_STATS"] = 56] = "DATACONSUMER_GET_STATS";
    Method[Method["DATACONSUMER_PAUSE"] = 57] = "DATACONSUMER_PAUSE";
    Method[Method["DATACONSUMER_RESUME"] = 58] = "DATACONSUMER_RESUME";
    Method[Method["DATACONSUMER_GET_BUFFERED_AMOUNT"] = 59] = "DATACONSUMER_GET_BUFFERED_AMOUNT";
    Method[Method["DATACONSUMER_SET_BUFFERED_AMOUNT_LOW_THRESHOLD"] = 60] = "DATACONSUMER_SET_BUFFERED_AMOUNT_LOW_THRESHOLD";
    Method[Method["DATACONSUMER_SEND"] = 61] = "DATACONSUMER_SEND";
    Method[Method["DATACONSUMER_SET_SUBCHANNELS"] = 62] = "DATACONSUMER_SET_SUBCHANNELS";
    Method[Method["DATACONSUMER_ADD_SUBCHANNEL"] = 63] = "DATACONSUMER_ADD_SUBCHANNEL";
    Method[Method["DATACONSUMER_REMOVE_SUBCHANNEL"] = 64] = "DATACONSUMER_REMOVE_SUBCHANNEL";
    Method[Method["RTPOBSERVER_PAUSE"] = 65] = "RTPOBSERVER_PAUSE";
    Method[Method["RTPOBSERVER_RESUME"] = 66] = "RTPOBSERVER_RESUME";
    Method[Method["RTPOBSERVER_ADD_PRODUCER"] = 67] = "RTPOBSERVER_ADD_PRODUCER";
    Method[Method["RTPOBSERVER_REMOVE_PRODUCER"] = 68] = "RTPOBSERVER_REMOVE_PRODUCER";
})(Method || (exports.Method = Method = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/request/request.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/request/request.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestT = exports.Request = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const body_1 = __webpack_require__(/*! ../../fbs/request/body */ "../../node_modules/mediasoup/node/lib/fbs/request/body.js");
const method_1 = __webpack_require__(/*! ../../fbs/request/method */ "../../node_modules/mediasoup/node/lib/fbs/request/method.js");
class Request {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRequest(bb, obj) {
        return (obj || new Request()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Request()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    method() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : method_1.Method.WORKER_CLOSE;
    }
    handlerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    bodyType() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : body_1.Body.NONE;
    }
    body(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startRequest(builder) {
        builder.startObject(5);
    }
    static addId(builder, id) {
        builder.addFieldInt32(0, id, 0);
    }
    static addMethod(builder, method) {
        builder.addFieldInt8(1, method, method_1.Method.WORKER_CLOSE);
    }
    static addHandlerId(builder, handlerIdOffset) {
        builder.addFieldOffset(2, handlerIdOffset, 0);
    }
    static addBodyType(builder, bodyType) {
        builder.addFieldInt8(3, bodyType, body_1.Body.NONE);
    }
    static addBody(builder, bodyOffset) {
        builder.addFieldOffset(4, bodyOffset, 0);
    }
    static endRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 8); // handler_id
        return offset;
    }
    static finishRequestBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedRequestBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createRequest(builder, id, method, handlerIdOffset, bodyType, bodyOffset) {
        Request.startRequest(builder);
        Request.addId(builder, id);
        Request.addMethod(builder, method);
        Request.addHandlerId(builder, handlerIdOffset);
        Request.addBodyType(builder, bodyType);
        Request.addBody(builder, bodyOffset);
        return Request.endRequest(builder);
    }
    unpack() {
        return new RequestT(this.id(), this.method(), this.handlerId(), this.bodyType(), (() => {
            const temp = (0, body_1.unionToBody)(this.bodyType(), this.body.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.method = this.method();
        _o.handlerId = this.handlerId();
        _o.bodyType = this.bodyType();
        _o.body = (() => {
            const temp = (0, body_1.unionToBody)(this.bodyType(), this.body.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
exports.Request = Request;
class RequestT {
    id;
    method;
    handlerId;
    bodyType;
    body;
    constructor(id = 0, method = method_1.Method.WORKER_CLOSE, handlerId = null, bodyType = body_1.Body.NONE, body = null) {
        this.id = id;
        this.method = method;
        this.handlerId = handlerId;
        this.bodyType = bodyType;
        this.body = body;
    }
    pack(builder) {
        const handlerId = (this.handlerId !== null ? builder.createString(this.handlerId) : 0);
        const body = builder.createObjectOffset(this.body);
        return Request.createRequest(builder, this.id, this.method, handlerId, this.bodyType, body);
    }
}
exports.RequestT = RequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/response.js":
/*!*************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/response.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResponseT = exports.Response = exports.Body = void 0;
var body_1 = __webpack_require__(/*! ./response/body */ "../../node_modules/mediasoup/node/lib/fbs/response/body.js");
Object.defineProperty(exports, "Body", ({ enumerable: true, get: function () { return body_1.Body; } }));
var response_1 = __webpack_require__(/*! ./response/response */ "../../node_modules/mediasoup/node/lib/fbs/response/response.js");
Object.defineProperty(exports, "Response", ({ enumerable: true, get: function () { return response_1.Response; } }));
Object.defineProperty(exports, "ResponseT", ({ enumerable: true, get: function () { return response_1.ResponseT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/response/body.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/response/body.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToBody = exports.unionToBody = exports.Body = void 0;
const dump_response_1 = __webpack_require__(/*! ../../fbs/consumer/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/consumer/dump-response.js");
const get_stats_response_1 = __webpack_require__(/*! ../../fbs/consumer/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/consumer/get-stats-response.js");
const set_preferred_layers_response_1 = __webpack_require__(/*! ../../fbs/consumer/set-preferred-layers-response */ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-preferred-layers-response.js");
const set_priority_response_1 = __webpack_require__(/*! ../../fbs/consumer/set-priority-response */ "../../node_modules/mediasoup/node/lib/fbs/consumer/set-priority-response.js");
const add_subchannel_response_1 = __webpack_require__(/*! ../../fbs/data-consumer/add-subchannel-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/add-subchannel-response.js");
const dump_response_2 = __webpack_require__(/*! ../../fbs/data-consumer/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/dump-response.js");
const get_buffered_amount_response_1 = __webpack_require__(/*! ../../fbs/data-consumer/get-buffered-amount-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/get-buffered-amount-response.js");
const get_stats_response_2 = __webpack_require__(/*! ../../fbs/data-consumer/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/get-stats-response.js");
const remove_subchannel_response_1 = __webpack_require__(/*! ../../fbs/data-consumer/remove-subchannel-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/remove-subchannel-response.js");
const set_subchannels_response_1 = __webpack_require__(/*! ../../fbs/data-consumer/set-subchannels-response */ "../../node_modules/mediasoup/node/lib/fbs/data-consumer/set-subchannels-response.js");
const dump_response_3 = __webpack_require__(/*! ../../fbs/data-producer/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/dump-response.js");
const get_stats_response_3 = __webpack_require__(/*! ../../fbs/data-producer/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/get-stats-response.js");
const dump_response_4 = __webpack_require__(/*! ../../fbs/direct-transport/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/dump-response.js");
const get_stats_response_4 = __webpack_require__(/*! ../../fbs/direct-transport/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/get-stats-response.js");
const connect_response_1 = __webpack_require__(/*! ../../fbs/pipe-transport/connect-response */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/connect-response.js");
const dump_response_5 = __webpack_require__(/*! ../../fbs/pipe-transport/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/dump-response.js");
const get_stats_response_5 = __webpack_require__(/*! ../../fbs/pipe-transport/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/get-stats-response.js");
const connect_response_2 = __webpack_require__(/*! ../../fbs/plain-transport/connect-response */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/connect-response.js");
const dump_response_6 = __webpack_require__(/*! ../../fbs/plain-transport/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/dump-response.js");
const get_stats_response_6 = __webpack_require__(/*! ../../fbs/plain-transport/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/get-stats-response.js");
const dump_response_7 = __webpack_require__(/*! ../../fbs/producer/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/producer/dump-response.js");
const get_stats_response_7 = __webpack_require__(/*! ../../fbs/producer/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/producer/get-stats-response.js");
const dump_response_8 = __webpack_require__(/*! ../../fbs/router/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/router/dump-response.js");
const consume_response_1 = __webpack_require__(/*! ../../fbs/transport/consume-response */ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-response.js");
const produce_response_1 = __webpack_require__(/*! ../../fbs/transport/produce-response */ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-response.js");
const restart_ice_response_1 = __webpack_require__(/*! ../../fbs/transport/restart-ice-response */ "../../node_modules/mediasoup/node/lib/fbs/transport/restart-ice-response.js");
const dump_response_9 = __webpack_require__(/*! ../../fbs/web-rtc-server/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/dump-response.js");
const connect_response_3 = __webpack_require__(/*! ../../fbs/web-rtc-transport/connect-response */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/connect-response.js");
const dump_response_10 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dump-response.js");
const get_stats_response_8 = __webpack_require__(/*! ../../fbs/web-rtc-transport/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/get-stats-response.js");
const dump_response_11 = __webpack_require__(/*! ../../fbs/worker/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/worker/dump-response.js");
const resource_usage_response_1 = __webpack_require__(/*! ../../fbs/worker/resource-usage-response */ "../../node_modules/mediasoup/node/lib/fbs/worker/resource-usage-response.js");
var Body;
(function (Body) {
    Body[Body["NONE"] = 0] = "NONE";
    Body[Body["Worker_DumpResponse"] = 1] = "Worker_DumpResponse";
    Body[Body["Worker_ResourceUsageResponse"] = 2] = "Worker_ResourceUsageResponse";
    Body[Body["WebRtcServer_DumpResponse"] = 3] = "WebRtcServer_DumpResponse";
    Body[Body["Router_DumpResponse"] = 4] = "Router_DumpResponse";
    Body[Body["Transport_ProduceResponse"] = 5] = "Transport_ProduceResponse";
    Body[Body["Transport_ConsumeResponse"] = 6] = "Transport_ConsumeResponse";
    Body[Body["Transport_RestartIceResponse"] = 7] = "Transport_RestartIceResponse";
    Body[Body["PlainTransport_ConnectResponse"] = 8] = "PlainTransport_ConnectResponse";
    Body[Body["PlainTransport_DumpResponse"] = 9] = "PlainTransport_DumpResponse";
    Body[Body["PlainTransport_GetStatsResponse"] = 10] = "PlainTransport_GetStatsResponse";
    Body[Body["PipeTransport_ConnectResponse"] = 11] = "PipeTransport_ConnectResponse";
    Body[Body["PipeTransport_DumpResponse"] = 12] = "PipeTransport_DumpResponse";
    Body[Body["PipeTransport_GetStatsResponse"] = 13] = "PipeTransport_GetStatsResponse";
    Body[Body["DirectTransport_DumpResponse"] = 14] = "DirectTransport_DumpResponse";
    Body[Body["DirectTransport_GetStatsResponse"] = 15] = "DirectTransport_GetStatsResponse";
    Body[Body["WebRtcTransport_ConnectResponse"] = 16] = "WebRtcTransport_ConnectResponse";
    Body[Body["WebRtcTransport_DumpResponse"] = 17] = "WebRtcTransport_DumpResponse";
    Body[Body["WebRtcTransport_GetStatsResponse"] = 18] = "WebRtcTransport_GetStatsResponse";
    Body[Body["Producer_DumpResponse"] = 19] = "Producer_DumpResponse";
    Body[Body["Producer_GetStatsResponse"] = 20] = "Producer_GetStatsResponse";
    Body[Body["Consumer_DumpResponse"] = 21] = "Consumer_DumpResponse";
    Body[Body["Consumer_GetStatsResponse"] = 22] = "Consumer_GetStatsResponse";
    Body[Body["Consumer_SetPreferredLayersResponse"] = 23] = "Consumer_SetPreferredLayersResponse";
    Body[Body["Consumer_SetPriorityResponse"] = 24] = "Consumer_SetPriorityResponse";
    Body[Body["DataProducer_DumpResponse"] = 25] = "DataProducer_DumpResponse";
    Body[Body["DataProducer_GetStatsResponse"] = 26] = "DataProducer_GetStatsResponse";
    Body[Body["DataConsumer_GetBufferedAmountResponse"] = 27] = "DataConsumer_GetBufferedAmountResponse";
    Body[Body["DataConsumer_DumpResponse"] = 28] = "DataConsumer_DumpResponse";
    Body[Body["DataConsumer_GetStatsResponse"] = 29] = "DataConsumer_GetStatsResponse";
    Body[Body["DataConsumer_SetSubchannelsResponse"] = 30] = "DataConsumer_SetSubchannelsResponse";
    Body[Body["DataConsumer_AddSubchannelResponse"] = 31] = "DataConsumer_AddSubchannelResponse";
    Body[Body["DataConsumer_RemoveSubchannelResponse"] = 32] = "DataConsumer_RemoveSubchannelResponse";
})(Body || (exports.Body = Body = {}));
function unionToBody(type, accessor) {
    switch (Body[type]) {
        case 'NONE': return null;
        case 'Worker_DumpResponse': return accessor(new dump_response_11.DumpResponse());
        case 'Worker_ResourceUsageResponse': return accessor(new resource_usage_response_1.ResourceUsageResponse());
        case 'WebRtcServer_DumpResponse': return accessor(new dump_response_9.DumpResponse());
        case 'Router_DumpResponse': return accessor(new dump_response_8.DumpResponse());
        case 'Transport_ProduceResponse': return accessor(new produce_response_1.ProduceResponse());
        case 'Transport_ConsumeResponse': return accessor(new consume_response_1.ConsumeResponse());
        case 'Transport_RestartIceResponse': return accessor(new restart_ice_response_1.RestartIceResponse());
        case 'PlainTransport_ConnectResponse': return accessor(new connect_response_2.ConnectResponse());
        case 'PlainTransport_DumpResponse': return accessor(new dump_response_6.DumpResponse());
        case 'PlainTransport_GetStatsResponse': return accessor(new get_stats_response_6.GetStatsResponse());
        case 'PipeTransport_ConnectResponse': return accessor(new connect_response_1.ConnectResponse());
        case 'PipeTransport_DumpResponse': return accessor(new dump_response_5.DumpResponse());
        case 'PipeTransport_GetStatsResponse': return accessor(new get_stats_response_5.GetStatsResponse());
        case 'DirectTransport_DumpResponse': return accessor(new dump_response_4.DumpResponse());
        case 'DirectTransport_GetStatsResponse': return accessor(new get_stats_response_4.GetStatsResponse());
        case 'WebRtcTransport_ConnectResponse': return accessor(new connect_response_3.ConnectResponse());
        case 'WebRtcTransport_DumpResponse': return accessor(new dump_response_10.DumpResponse());
        case 'WebRtcTransport_GetStatsResponse': return accessor(new get_stats_response_8.GetStatsResponse());
        case 'Producer_DumpResponse': return accessor(new dump_response_7.DumpResponse());
        case 'Producer_GetStatsResponse': return accessor(new get_stats_response_7.GetStatsResponse());
        case 'Consumer_DumpResponse': return accessor(new dump_response_1.DumpResponse());
        case 'Consumer_GetStatsResponse': return accessor(new get_stats_response_1.GetStatsResponse());
        case 'Consumer_SetPreferredLayersResponse': return accessor(new set_preferred_layers_response_1.SetPreferredLayersResponse());
        case 'Consumer_SetPriorityResponse': return accessor(new set_priority_response_1.SetPriorityResponse());
        case 'DataProducer_DumpResponse': return accessor(new dump_response_3.DumpResponse());
        case 'DataProducer_GetStatsResponse': return accessor(new get_stats_response_3.GetStatsResponse());
        case 'DataConsumer_GetBufferedAmountResponse': return accessor(new get_buffered_amount_response_1.GetBufferedAmountResponse());
        case 'DataConsumer_DumpResponse': return accessor(new dump_response_2.DumpResponse());
        case 'DataConsumer_GetStatsResponse': return accessor(new get_stats_response_2.GetStatsResponse());
        case 'DataConsumer_SetSubchannelsResponse': return accessor(new set_subchannels_response_1.SetSubchannelsResponse());
        case 'DataConsumer_AddSubchannelResponse': return accessor(new add_subchannel_response_1.AddSubchannelResponse());
        case 'DataConsumer_RemoveSubchannelResponse': return accessor(new remove_subchannel_response_1.RemoveSubchannelResponse());
        default: return null;
    }
}
exports.unionToBody = unionToBody;
function unionListToBody(type, accessor, index) {
    switch (Body[type]) {
        case 'NONE': return null;
        case 'Worker_DumpResponse': return accessor(index, new dump_response_11.DumpResponse());
        case 'Worker_ResourceUsageResponse': return accessor(index, new resource_usage_response_1.ResourceUsageResponse());
        case 'WebRtcServer_DumpResponse': return accessor(index, new dump_response_9.DumpResponse());
        case 'Router_DumpResponse': return accessor(index, new dump_response_8.DumpResponse());
        case 'Transport_ProduceResponse': return accessor(index, new produce_response_1.ProduceResponse());
        case 'Transport_ConsumeResponse': return accessor(index, new consume_response_1.ConsumeResponse());
        case 'Transport_RestartIceResponse': return accessor(index, new restart_ice_response_1.RestartIceResponse());
        case 'PlainTransport_ConnectResponse': return accessor(index, new connect_response_2.ConnectResponse());
        case 'PlainTransport_DumpResponse': return accessor(index, new dump_response_6.DumpResponse());
        case 'PlainTransport_GetStatsResponse': return accessor(index, new get_stats_response_6.GetStatsResponse());
        case 'PipeTransport_ConnectResponse': return accessor(index, new connect_response_1.ConnectResponse());
        case 'PipeTransport_DumpResponse': return accessor(index, new dump_response_5.DumpResponse());
        case 'PipeTransport_GetStatsResponse': return accessor(index, new get_stats_response_5.GetStatsResponse());
        case 'DirectTransport_DumpResponse': return accessor(index, new dump_response_4.DumpResponse());
        case 'DirectTransport_GetStatsResponse': return accessor(index, new get_stats_response_4.GetStatsResponse());
        case 'WebRtcTransport_ConnectResponse': return accessor(index, new connect_response_3.ConnectResponse());
        case 'WebRtcTransport_DumpResponse': return accessor(index, new dump_response_10.DumpResponse());
        case 'WebRtcTransport_GetStatsResponse': return accessor(index, new get_stats_response_8.GetStatsResponse());
        case 'Producer_DumpResponse': return accessor(index, new dump_response_7.DumpResponse());
        case 'Producer_GetStatsResponse': return accessor(index, new get_stats_response_7.GetStatsResponse());
        case 'Consumer_DumpResponse': return accessor(index, new dump_response_1.DumpResponse());
        case 'Consumer_GetStatsResponse': return accessor(index, new get_stats_response_1.GetStatsResponse());
        case 'Consumer_SetPreferredLayersResponse': return accessor(index, new set_preferred_layers_response_1.SetPreferredLayersResponse());
        case 'Consumer_SetPriorityResponse': return accessor(index, new set_priority_response_1.SetPriorityResponse());
        case 'DataProducer_DumpResponse': return accessor(index, new dump_response_3.DumpResponse());
        case 'DataProducer_GetStatsResponse': return accessor(index, new get_stats_response_3.GetStatsResponse());
        case 'DataConsumer_GetBufferedAmountResponse': return accessor(index, new get_buffered_amount_response_1.GetBufferedAmountResponse());
        case 'DataConsumer_DumpResponse': return accessor(index, new dump_response_2.DumpResponse());
        case 'DataConsumer_GetStatsResponse': return accessor(index, new get_stats_response_2.GetStatsResponse());
        case 'DataConsumer_SetSubchannelsResponse': return accessor(index, new set_subchannels_response_1.SetSubchannelsResponse());
        case 'DataConsumer_AddSubchannelResponse': return accessor(index, new add_subchannel_response_1.AddSubchannelResponse());
        case 'DataConsumer_RemoveSubchannelResponse': return accessor(index, new remove_subchannel_response_1.RemoveSubchannelResponse());
        default: return null;
    }
}
exports.unionListToBody = unionListToBody;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/response/response.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/response/response.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResponseT = exports.Response = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const body_1 = __webpack_require__(/*! ../../fbs/response/body */ "../../node_modules/mediasoup/node/lib/fbs/response/body.js");
class Response {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsResponse(bb, obj) {
        return (obj || new Response()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Response()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    accepted() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    bodyType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : body_1.Body.NONE;
    }
    body(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    error(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    reason(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startResponse(builder) {
        builder.startObject(6);
    }
    static addId(builder, id) {
        builder.addFieldInt32(0, id, 0);
    }
    static addAccepted(builder, accepted) {
        builder.addFieldInt8(1, +accepted, +false);
    }
    static addBodyType(builder, bodyType) {
        builder.addFieldInt8(2, bodyType, body_1.Body.NONE);
    }
    static addBody(builder, bodyOffset) {
        builder.addFieldOffset(3, bodyOffset, 0);
    }
    static addError(builder, errorOffset) {
        builder.addFieldOffset(4, errorOffset, 0);
    }
    static addReason(builder, reasonOffset) {
        builder.addFieldOffset(5, reasonOffset, 0);
    }
    static endResponse(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createResponse(builder, id, accepted, bodyType, bodyOffset, errorOffset, reasonOffset) {
        Response.startResponse(builder);
        Response.addId(builder, id);
        Response.addAccepted(builder, accepted);
        Response.addBodyType(builder, bodyType);
        Response.addBody(builder, bodyOffset);
        Response.addError(builder, errorOffset);
        Response.addReason(builder, reasonOffset);
        return Response.endResponse(builder);
    }
    unpack() {
        return new ResponseT(this.id(), this.accepted(), this.bodyType(), (() => {
            const temp = (0, body_1.unionToBody)(this.bodyType(), this.body.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), this.error(), this.reason());
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.accepted = this.accepted();
        _o.bodyType = this.bodyType();
        _o.body = (() => {
            const temp = (0, body_1.unionToBody)(this.bodyType(), this.body.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.error = this.error();
        _o.reason = this.reason();
    }
}
exports.Response = Response;
class ResponseT {
    id;
    accepted;
    bodyType;
    body;
    error;
    reason;
    constructor(id = 0, accepted = false, bodyType = body_1.Body.NONE, body = null, error = null, reason = null) {
        this.id = id;
        this.accepted = accepted;
        this.bodyType = bodyType;
        this.body = body;
        this.error = error;
        this.reason = reason;
    }
    pack(builder) {
        const body = builder.createObjectOffset(this.body);
        const error = (this.error !== null ? builder.createString(this.error) : 0);
        const reason = (this.reason !== null ? builder.createString(this.reason) : 0);
        return Response.createResponse(builder, this.id, this.accepted, this.bodyType, body, error, reason);
    }
}
exports.ResponseT = ResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router.js":
/*!***********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = exports.CreateWebRtcTransportRequestT = exports.CreateWebRtcTransportRequest = exports.CreatePlainTransportRequestT = exports.CreatePlainTransportRequest = exports.CreatePipeTransportRequestT = exports.CreatePipeTransportRequest = exports.CreateDirectTransportRequestT = exports.CreateDirectTransportRequest = exports.CreateAudioLevelObserverRequestT = exports.CreateAudioLevelObserverRequest = exports.CreateActiveSpeakerObserverRequestT = exports.CreateActiveSpeakerObserverRequest = exports.CloseTransportRequestT = exports.CloseTransportRequest = exports.CloseRtpObserverRequestT = exports.CloseRtpObserverRequest = void 0;
var close_rtp_observer_request_1 = __webpack_require__(/*! ./router/close-rtp-observer-request */ "../../node_modules/mediasoup/node/lib/fbs/router/close-rtp-observer-request.js");
Object.defineProperty(exports, "CloseRtpObserverRequest", ({ enumerable: true, get: function () { return close_rtp_observer_request_1.CloseRtpObserverRequest; } }));
Object.defineProperty(exports, "CloseRtpObserverRequestT", ({ enumerable: true, get: function () { return close_rtp_observer_request_1.CloseRtpObserverRequestT; } }));
var close_transport_request_1 = __webpack_require__(/*! ./router/close-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/close-transport-request.js");
Object.defineProperty(exports, "CloseTransportRequest", ({ enumerable: true, get: function () { return close_transport_request_1.CloseTransportRequest; } }));
Object.defineProperty(exports, "CloseTransportRequestT", ({ enumerable: true, get: function () { return close_transport_request_1.CloseTransportRequestT; } }));
var create_active_speaker_observer_request_1 = __webpack_require__(/*! ./router/create-active-speaker-observer-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-active-speaker-observer-request.js");
Object.defineProperty(exports, "CreateActiveSpeakerObserverRequest", ({ enumerable: true, get: function () { return create_active_speaker_observer_request_1.CreateActiveSpeakerObserverRequest; } }));
Object.defineProperty(exports, "CreateActiveSpeakerObserverRequestT", ({ enumerable: true, get: function () { return create_active_speaker_observer_request_1.CreateActiveSpeakerObserverRequestT; } }));
var create_audio_level_observer_request_1 = __webpack_require__(/*! ./router/create-audio-level-observer-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-audio-level-observer-request.js");
Object.defineProperty(exports, "CreateAudioLevelObserverRequest", ({ enumerable: true, get: function () { return create_audio_level_observer_request_1.CreateAudioLevelObserverRequest; } }));
Object.defineProperty(exports, "CreateAudioLevelObserverRequestT", ({ enumerable: true, get: function () { return create_audio_level_observer_request_1.CreateAudioLevelObserverRequestT; } }));
var create_direct_transport_request_1 = __webpack_require__(/*! ./router/create-direct-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-direct-transport-request.js");
Object.defineProperty(exports, "CreateDirectTransportRequest", ({ enumerable: true, get: function () { return create_direct_transport_request_1.CreateDirectTransportRequest; } }));
Object.defineProperty(exports, "CreateDirectTransportRequestT", ({ enumerable: true, get: function () { return create_direct_transport_request_1.CreateDirectTransportRequestT; } }));
var create_pipe_transport_request_1 = __webpack_require__(/*! ./router/create-pipe-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-pipe-transport-request.js");
Object.defineProperty(exports, "CreatePipeTransportRequest", ({ enumerable: true, get: function () { return create_pipe_transport_request_1.CreatePipeTransportRequest; } }));
Object.defineProperty(exports, "CreatePipeTransportRequestT", ({ enumerable: true, get: function () { return create_pipe_transport_request_1.CreatePipeTransportRequestT; } }));
var create_plain_transport_request_1 = __webpack_require__(/*! ./router/create-plain-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-plain-transport-request.js");
Object.defineProperty(exports, "CreatePlainTransportRequest", ({ enumerable: true, get: function () { return create_plain_transport_request_1.CreatePlainTransportRequest; } }));
Object.defineProperty(exports, "CreatePlainTransportRequestT", ({ enumerable: true, get: function () { return create_plain_transport_request_1.CreatePlainTransportRequestT; } }));
var create_web_rtc_transport_request_1 = __webpack_require__(/*! ./router/create-web-rtc-transport-request */ "../../node_modules/mediasoup/node/lib/fbs/router/create-web-rtc-transport-request.js");
Object.defineProperty(exports, "CreateWebRtcTransportRequest", ({ enumerable: true, get: function () { return create_web_rtc_transport_request_1.CreateWebRtcTransportRequest; } }));
Object.defineProperty(exports, "CreateWebRtcTransportRequestT", ({ enumerable: true, get: function () { return create_web_rtc_transport_request_1.CreateWebRtcTransportRequestT; } }));
var dump_response_1 = __webpack_require__(/*! ./router/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/router/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/close-rtp-observer-request.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/close-rtp-observer-request.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseRtpObserverRequestT = exports.CloseRtpObserverRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CloseRtpObserverRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCloseRtpObserverRequest(bb, obj) {
        return (obj || new CloseRtpObserverRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCloseRtpObserverRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CloseRtpObserverRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    rtpObserverId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCloseRtpObserverRequest(builder) {
        builder.startObject(1);
    }
    static addRtpObserverId(builder, rtpObserverIdOffset) {
        builder.addFieldOffset(0, rtpObserverIdOffset, 0);
    }
    static endCloseRtpObserverRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // rtp_observer_id
        return offset;
    }
    static createCloseRtpObserverRequest(builder, rtpObserverIdOffset) {
        CloseRtpObserverRequest.startCloseRtpObserverRequest(builder);
        CloseRtpObserverRequest.addRtpObserverId(builder, rtpObserverIdOffset);
        return CloseRtpObserverRequest.endCloseRtpObserverRequest(builder);
    }
    unpack() {
        return new CloseRtpObserverRequestT(this.rtpObserverId());
    }
    unpackTo(_o) {
        _o.rtpObserverId = this.rtpObserverId();
    }
}
exports.CloseRtpObserverRequest = CloseRtpObserverRequest;
class CloseRtpObserverRequestT {
    rtpObserverId;
    constructor(rtpObserverId = null) {
        this.rtpObserverId = rtpObserverId;
    }
    pack(builder) {
        const rtpObserverId = (this.rtpObserverId !== null ? builder.createString(this.rtpObserverId) : 0);
        return CloseRtpObserverRequest.createCloseRtpObserverRequest(builder, rtpObserverId);
    }
}
exports.CloseRtpObserverRequestT = CloseRtpObserverRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/close-transport-request.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/close-transport-request.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseTransportRequestT = exports.CloseTransportRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CloseTransportRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCloseTransportRequest(bb, obj) {
        return (obj || new CloseTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCloseTransportRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CloseTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    transportId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCloseTransportRequest(builder) {
        builder.startObject(1);
    }
    static addTransportId(builder, transportIdOffset) {
        builder.addFieldOffset(0, transportIdOffset, 0);
    }
    static endCloseTransportRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // transport_id
        return offset;
    }
    static createCloseTransportRequest(builder, transportIdOffset) {
        CloseTransportRequest.startCloseTransportRequest(builder);
        CloseTransportRequest.addTransportId(builder, transportIdOffset);
        return CloseTransportRequest.endCloseTransportRequest(builder);
    }
    unpack() {
        return new CloseTransportRequestT(this.transportId());
    }
    unpackTo(_o) {
        _o.transportId = this.transportId();
    }
}
exports.CloseTransportRequest = CloseTransportRequest;
class CloseTransportRequestT {
    transportId;
    constructor(transportId = null) {
        this.transportId = transportId;
    }
    pack(builder) {
        const transportId = (this.transportId !== null ? builder.createString(this.transportId) : 0);
        return CloseTransportRequest.createCloseTransportRequest(builder, transportId);
    }
}
exports.CloseTransportRequestT = CloseTransportRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/create-active-speaker-observer-request.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/create-active-speaker-observer-request.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateActiveSpeakerObserverRequestT = exports.CreateActiveSpeakerObserverRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const active_speaker_observer_options_1 = __webpack_require__(/*! ../../fbs/active-speaker-observer/active-speaker-observer-options */ "../../node_modules/mediasoup/node/lib/fbs/active-speaker-observer/active-speaker-observer-options.js");
class CreateActiveSpeakerObserverRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCreateActiveSpeakerObserverRequest(bb, obj) {
        return (obj || new CreateActiveSpeakerObserverRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCreateActiveSpeakerObserverRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CreateActiveSpeakerObserverRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    rtpObserverId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    options(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new active_speaker_observer_options_1.ActiveSpeakerObserverOptions()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startCreateActiveSpeakerObserverRequest(builder) {
        builder.startObject(2);
    }
    static addRtpObserverId(builder, rtpObserverIdOffset) {
        builder.addFieldOffset(0, rtpObserverIdOffset, 0);
    }
    static addOptions(builder, optionsOffset) {
        builder.addFieldOffset(1, optionsOffset, 0);
    }
    static endCreateActiveSpeakerObserverRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // rtp_observer_id
        builder.requiredField(offset, 6); // options
        return offset;
    }
    unpack() {
        return new CreateActiveSpeakerObserverRequestT(this.rtpObserverId(), (this.options() !== null ? this.options().unpack() : null));
    }
    unpackTo(_o) {
        _o.rtpObserverId = this.rtpObserverId();
        _o.options = (this.options() !== null ? this.options().unpack() : null);
    }
}
exports.CreateActiveSpeakerObserverRequest = CreateActiveSpeakerObserverRequest;
class CreateActiveSpeakerObserverRequestT {
    rtpObserverId;
    options;
    constructor(rtpObserverId = null, options = null) {
        this.rtpObserverId = rtpObserverId;
        this.options = options;
    }
    pack(builder) {
        const rtpObserverId = (this.rtpObserverId !== null ? builder.createString(this.rtpObserverId) : 0);
        const options = (this.options !== null ? this.options.pack(builder) : 0);
        CreateActiveSpeakerObserverRequest.startCreateActiveSpeakerObserverRequest(builder);
        CreateActiveSpeakerObserverRequest.addRtpObserverId(builder, rtpObserverId);
        CreateActiveSpeakerObserverRequest.addOptions(builder, options);
        return CreateActiveSpeakerObserverRequest.endCreateActiveSpeakerObserverRequest(builder);
    }
}
exports.CreateActiveSpeakerObserverRequestT = CreateActiveSpeakerObserverRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/create-audio-level-observer-request.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/create-audio-level-observer-request.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateAudioLevelObserverRequestT = exports.CreateAudioLevelObserverRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const audio_level_observer_options_1 = __webpack_require__(/*! ../../fbs/audio-level-observer/audio-level-observer-options */ "../../node_modules/mediasoup/node/lib/fbs/audio-level-observer/audio-level-observer-options.js");
class CreateAudioLevelObserverRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCreateAudioLevelObserverRequest(bb, obj) {
        return (obj || new CreateAudioLevelObserverRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCreateAudioLevelObserverRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CreateAudioLevelObserverRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    rtpObserverId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    options(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new audio_level_observer_options_1.AudioLevelObserverOptions()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startCreateAudioLevelObserverRequest(builder) {
        builder.startObject(2);
    }
    static addRtpObserverId(builder, rtpObserverIdOffset) {
        builder.addFieldOffset(0, rtpObserverIdOffset, 0);
    }
    static addOptions(builder, optionsOffset) {
        builder.addFieldOffset(1, optionsOffset, 0);
    }
    static endCreateAudioLevelObserverRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // rtp_observer_id
        builder.requiredField(offset, 6); // options
        return offset;
    }
    unpack() {
        return new CreateAudioLevelObserverRequestT(this.rtpObserverId(), (this.options() !== null ? this.options().unpack() : null));
    }
    unpackTo(_o) {
        _o.rtpObserverId = this.rtpObserverId();
        _o.options = (this.options() !== null ? this.options().unpack() : null);
    }
}
exports.CreateAudioLevelObserverRequest = CreateAudioLevelObserverRequest;
class CreateAudioLevelObserverRequestT {
    rtpObserverId;
    options;
    constructor(rtpObserverId = null, options = null) {
        this.rtpObserverId = rtpObserverId;
        this.options = options;
    }
    pack(builder) {
        const rtpObserverId = (this.rtpObserverId !== null ? builder.createString(this.rtpObserverId) : 0);
        const options = (this.options !== null ? this.options.pack(builder) : 0);
        CreateAudioLevelObserverRequest.startCreateAudioLevelObserverRequest(builder);
        CreateAudioLevelObserverRequest.addRtpObserverId(builder, rtpObserverId);
        CreateAudioLevelObserverRequest.addOptions(builder, options);
        return CreateAudioLevelObserverRequest.endCreateAudioLevelObserverRequest(builder);
    }
}
exports.CreateAudioLevelObserverRequestT = CreateAudioLevelObserverRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/create-direct-transport-request.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/create-direct-transport-request.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateDirectTransportRequestT = exports.CreateDirectTransportRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const direct_transport_options_1 = __webpack_require__(/*! ../../fbs/direct-transport/direct-transport-options */ "../../node_modules/mediasoup/node/lib/fbs/direct-transport/direct-transport-options.js");
class CreateDirectTransportRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCreateDirectTransportRequest(bb, obj) {
        return (obj || new CreateDirectTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCreateDirectTransportRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CreateDirectTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    transportId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    options(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new direct_transport_options_1.DirectTransportOptions()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startCreateDirectTransportRequest(builder) {
        builder.startObject(2);
    }
    static addTransportId(builder, transportIdOffset) {
        builder.addFieldOffset(0, transportIdOffset, 0);
    }
    static addOptions(builder, optionsOffset) {
        builder.addFieldOffset(1, optionsOffset, 0);
    }
    static endCreateDirectTransportRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // transport_id
        builder.requiredField(offset, 6); // options
        return offset;
    }
    unpack() {
        return new CreateDirectTransportRequestT(this.transportId(), (this.options() !== null ? this.options().unpack() : null));
    }
    unpackTo(_o) {
        _o.transportId = this.transportId();
        _o.options = (this.options() !== null ? this.options().unpack() : null);
    }
}
exports.CreateDirectTransportRequest = CreateDirectTransportRequest;
class CreateDirectTransportRequestT {
    transportId;
    options;
    constructor(transportId = null, options = null) {
        this.transportId = transportId;
        this.options = options;
    }
    pack(builder) {
        const transportId = (this.transportId !== null ? builder.createString(this.transportId) : 0);
        const options = (this.options !== null ? this.options.pack(builder) : 0);
        CreateDirectTransportRequest.startCreateDirectTransportRequest(builder);
        CreateDirectTransportRequest.addTransportId(builder, transportId);
        CreateDirectTransportRequest.addOptions(builder, options);
        return CreateDirectTransportRequest.endCreateDirectTransportRequest(builder);
    }
}
exports.CreateDirectTransportRequestT = CreateDirectTransportRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/create-pipe-transport-request.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/create-pipe-transport-request.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePipeTransportRequestT = exports.CreatePipeTransportRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const pipe_transport_options_1 = __webpack_require__(/*! ../../fbs/pipe-transport/pipe-transport-options */ "../../node_modules/mediasoup/node/lib/fbs/pipe-transport/pipe-transport-options.js");
class CreatePipeTransportRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCreatePipeTransportRequest(bb, obj) {
        return (obj || new CreatePipeTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCreatePipeTransportRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CreatePipeTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    transportId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    options(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new pipe_transport_options_1.PipeTransportOptions()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startCreatePipeTransportRequest(builder) {
        builder.startObject(2);
    }
    static addTransportId(builder, transportIdOffset) {
        builder.addFieldOffset(0, transportIdOffset, 0);
    }
    static addOptions(builder, optionsOffset) {
        builder.addFieldOffset(1, optionsOffset, 0);
    }
    static endCreatePipeTransportRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // transport_id
        builder.requiredField(offset, 6); // options
        return offset;
    }
    unpack() {
        return new CreatePipeTransportRequestT(this.transportId(), (this.options() !== null ? this.options().unpack() : null));
    }
    unpackTo(_o) {
        _o.transportId = this.transportId();
        _o.options = (this.options() !== null ? this.options().unpack() : null);
    }
}
exports.CreatePipeTransportRequest = CreatePipeTransportRequest;
class CreatePipeTransportRequestT {
    transportId;
    options;
    constructor(transportId = null, options = null) {
        this.transportId = transportId;
        this.options = options;
    }
    pack(builder) {
        const transportId = (this.transportId !== null ? builder.createString(this.transportId) : 0);
        const options = (this.options !== null ? this.options.pack(builder) : 0);
        CreatePipeTransportRequest.startCreatePipeTransportRequest(builder);
        CreatePipeTransportRequest.addTransportId(builder, transportId);
        CreatePipeTransportRequest.addOptions(builder, options);
        return CreatePipeTransportRequest.endCreatePipeTransportRequest(builder);
    }
}
exports.CreatePipeTransportRequestT = CreatePipeTransportRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/create-plain-transport-request.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/create-plain-transport-request.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePlainTransportRequestT = exports.CreatePlainTransportRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const plain_transport_options_1 = __webpack_require__(/*! ../../fbs/plain-transport/plain-transport-options */ "../../node_modules/mediasoup/node/lib/fbs/plain-transport/plain-transport-options.js");
class CreatePlainTransportRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCreatePlainTransportRequest(bb, obj) {
        return (obj || new CreatePlainTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCreatePlainTransportRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CreatePlainTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    transportId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    options(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new plain_transport_options_1.PlainTransportOptions()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startCreatePlainTransportRequest(builder) {
        builder.startObject(2);
    }
    static addTransportId(builder, transportIdOffset) {
        builder.addFieldOffset(0, transportIdOffset, 0);
    }
    static addOptions(builder, optionsOffset) {
        builder.addFieldOffset(1, optionsOffset, 0);
    }
    static endCreatePlainTransportRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // transport_id
        builder.requiredField(offset, 6); // options
        return offset;
    }
    unpack() {
        return new CreatePlainTransportRequestT(this.transportId(), (this.options() !== null ? this.options().unpack() : null));
    }
    unpackTo(_o) {
        _o.transportId = this.transportId();
        _o.options = (this.options() !== null ? this.options().unpack() : null);
    }
}
exports.CreatePlainTransportRequest = CreatePlainTransportRequest;
class CreatePlainTransportRequestT {
    transportId;
    options;
    constructor(transportId = null, options = null) {
        this.transportId = transportId;
        this.options = options;
    }
    pack(builder) {
        const transportId = (this.transportId !== null ? builder.createString(this.transportId) : 0);
        const options = (this.options !== null ? this.options.pack(builder) : 0);
        CreatePlainTransportRequest.startCreatePlainTransportRequest(builder);
        CreatePlainTransportRequest.addTransportId(builder, transportId);
        CreatePlainTransportRequest.addOptions(builder, options);
        return CreatePlainTransportRequest.endCreatePlainTransportRequest(builder);
    }
}
exports.CreatePlainTransportRequestT = CreatePlainTransportRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/create-web-rtc-transport-request.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/create-web-rtc-transport-request.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateWebRtcTransportRequestT = exports.CreateWebRtcTransportRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const web_rtc_transport_options_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/web-rtc-transport-options */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/web-rtc-transport-options.js");
class CreateWebRtcTransportRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCreateWebRtcTransportRequest(bb, obj) {
        return (obj || new CreateWebRtcTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCreateWebRtcTransportRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CreateWebRtcTransportRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    transportId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    options(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new web_rtc_transport_options_1.WebRtcTransportOptions()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startCreateWebRtcTransportRequest(builder) {
        builder.startObject(2);
    }
    static addTransportId(builder, transportIdOffset) {
        builder.addFieldOffset(0, transportIdOffset, 0);
    }
    static addOptions(builder, optionsOffset) {
        builder.addFieldOffset(1, optionsOffset, 0);
    }
    static endCreateWebRtcTransportRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // transport_id
        builder.requiredField(offset, 6); // options
        return offset;
    }
    unpack() {
        return new CreateWebRtcTransportRequestT(this.transportId(), (this.options() !== null ? this.options().unpack() : null));
    }
    unpackTo(_o) {
        _o.transportId = this.transportId();
        _o.options = (this.options() !== null ? this.options().unpack() : null);
    }
}
exports.CreateWebRtcTransportRequest = CreateWebRtcTransportRequest;
class CreateWebRtcTransportRequestT {
    transportId;
    options;
    constructor(transportId = null, options = null) {
        this.transportId = transportId;
        this.options = options;
    }
    pack(builder) {
        const transportId = (this.transportId !== null ? builder.createString(this.transportId) : 0);
        const options = (this.options !== null ? this.options.pack(builder) : 0);
        CreateWebRtcTransportRequest.startCreateWebRtcTransportRequest(builder);
        CreateWebRtcTransportRequest.addTransportId(builder, transportId);
        CreateWebRtcTransportRequest.addOptions(builder, options);
        return CreateWebRtcTransportRequest.endCreateWebRtcTransportRequest(builder);
    }
}
exports.CreateWebRtcTransportRequestT = CreateWebRtcTransportRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/router/dump-response.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/router/dump-response.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const string_string_1 = __webpack_require__(/*! ../../fbs/common/string-string */ "../../node_modules/mediasoup/node/lib/fbs/common/string-string.js");
const string_string_array_1 = __webpack_require__(/*! ../../fbs/common/string-string-array */ "../../node_modules/mediasoup/node/lib/fbs/common/string-string-array.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    transportIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    transportIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    rtpObserverIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    rtpObserverIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    mapProducerIdConsumerIds(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new string_string_array_1.StringStringArray()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    mapProducerIdConsumerIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    mapConsumerIdProducerId(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new string_string_1.StringString()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    mapConsumerIdProducerIdLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    mapProducerIdObserverIds(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new string_string_array_1.StringStringArray()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    mapProducerIdObserverIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    mapDataProducerIdDataConsumerIds(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new string_string_array_1.StringStringArray()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    mapDataProducerIdDataConsumerIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    mapDataConsumerIdDataProducerId(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? (obj || new string_string_1.StringString()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    mapDataConsumerIdDataProducerIdLength() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startDumpResponse(builder) {
        builder.startObject(8);
    }
    static addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    }
    static addTransportIds(builder, transportIdsOffset) {
        builder.addFieldOffset(1, transportIdsOffset, 0);
    }
    static createTransportIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTransportIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRtpObserverIds(builder, rtpObserverIdsOffset) {
        builder.addFieldOffset(2, rtpObserverIdsOffset, 0);
    }
    static createRtpObserverIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRtpObserverIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addMapProducerIdConsumerIds(builder, mapProducerIdConsumerIdsOffset) {
        builder.addFieldOffset(3, mapProducerIdConsumerIdsOffset, 0);
    }
    static createMapProducerIdConsumerIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startMapProducerIdConsumerIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addMapConsumerIdProducerId(builder, mapConsumerIdProducerIdOffset) {
        builder.addFieldOffset(4, mapConsumerIdProducerIdOffset, 0);
    }
    static createMapConsumerIdProducerIdVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startMapConsumerIdProducerIdVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addMapProducerIdObserverIds(builder, mapProducerIdObserverIdsOffset) {
        builder.addFieldOffset(5, mapProducerIdObserverIdsOffset, 0);
    }
    static createMapProducerIdObserverIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startMapProducerIdObserverIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addMapDataProducerIdDataConsumerIds(builder, mapDataProducerIdDataConsumerIdsOffset) {
        builder.addFieldOffset(6, mapDataProducerIdDataConsumerIdsOffset, 0);
    }
    static createMapDataProducerIdDataConsumerIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startMapDataProducerIdDataConsumerIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addMapDataConsumerIdDataProducerId(builder, mapDataConsumerIdDataProducerIdOffset) {
        builder.addFieldOffset(7, mapDataConsumerIdDataProducerIdOffset, 0);
    }
    static createMapDataConsumerIdDataProducerIdVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startMapDataConsumerIdDataProducerIdVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // id
        builder.requiredField(offset, 6); // transport_ids
        builder.requiredField(offset, 8); // rtp_observer_ids
        builder.requiredField(offset, 10); // map_producer_id_consumer_ids
        builder.requiredField(offset, 12); // map_consumer_id_producer_id
        builder.requiredField(offset, 14); // map_producer_id_observer_ids
        builder.requiredField(offset, 16); // map_data_producer_id_data_consumer_ids
        builder.requiredField(offset, 18); // map_data_consumer_id_data_producer_id
        return offset;
    }
    static createDumpResponse(builder, idOffset, transportIdsOffset, rtpObserverIdsOffset, mapProducerIdConsumerIdsOffset, mapConsumerIdProducerIdOffset, mapProducerIdObserverIdsOffset, mapDataProducerIdDataConsumerIdsOffset, mapDataConsumerIdDataProducerIdOffset) {
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addId(builder, idOffset);
        DumpResponse.addTransportIds(builder, transportIdsOffset);
        DumpResponse.addRtpObserverIds(builder, rtpObserverIdsOffset);
        DumpResponse.addMapProducerIdConsumerIds(builder, mapProducerIdConsumerIdsOffset);
        DumpResponse.addMapConsumerIdProducerId(builder, mapConsumerIdProducerIdOffset);
        DumpResponse.addMapProducerIdObserverIds(builder, mapProducerIdObserverIdsOffset);
        DumpResponse.addMapDataProducerIdDataConsumerIds(builder, mapDataProducerIdDataConsumerIdsOffset);
        DumpResponse.addMapDataConsumerIdDataProducerId(builder, mapDataConsumerIdDataProducerIdOffset);
        return DumpResponse.endDumpResponse(builder);
    }
    unpack() {
        return new DumpResponseT(this.id(), this.bb.createScalarList(this.transportIds.bind(this), this.transportIdsLength()), this.bb.createScalarList(this.rtpObserverIds.bind(this), this.rtpObserverIdsLength()), this.bb.createObjList(this.mapProducerIdConsumerIds.bind(this), this.mapProducerIdConsumerIdsLength()), this.bb.createObjList(this.mapConsumerIdProducerId.bind(this), this.mapConsumerIdProducerIdLength()), this.bb.createObjList(this.mapProducerIdObserverIds.bind(this), this.mapProducerIdObserverIdsLength()), this.bb.createObjList(this.mapDataProducerIdDataConsumerIds.bind(this), this.mapDataProducerIdDataConsumerIdsLength()), this.bb.createObjList(this.mapDataConsumerIdDataProducerId.bind(this), this.mapDataConsumerIdDataProducerIdLength()));
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.transportIds = this.bb.createScalarList(this.transportIds.bind(this), this.transportIdsLength());
        _o.rtpObserverIds = this.bb.createScalarList(this.rtpObserverIds.bind(this), this.rtpObserverIdsLength());
        _o.mapProducerIdConsumerIds = this.bb.createObjList(this.mapProducerIdConsumerIds.bind(this), this.mapProducerIdConsumerIdsLength());
        _o.mapConsumerIdProducerId = this.bb.createObjList(this.mapConsumerIdProducerId.bind(this), this.mapConsumerIdProducerIdLength());
        _o.mapProducerIdObserverIds = this.bb.createObjList(this.mapProducerIdObserverIds.bind(this), this.mapProducerIdObserverIdsLength());
        _o.mapDataProducerIdDataConsumerIds = this.bb.createObjList(this.mapDataProducerIdDataConsumerIds.bind(this), this.mapDataProducerIdDataConsumerIdsLength());
        _o.mapDataConsumerIdDataProducerId = this.bb.createObjList(this.mapDataConsumerIdDataProducerId.bind(this), this.mapDataConsumerIdDataProducerIdLength());
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    id;
    transportIds;
    rtpObserverIds;
    mapProducerIdConsumerIds;
    mapConsumerIdProducerId;
    mapProducerIdObserverIds;
    mapDataProducerIdDataConsumerIds;
    mapDataConsumerIdDataProducerId;
    constructor(id = null, transportIds = [], rtpObserverIds = [], mapProducerIdConsumerIds = [], mapConsumerIdProducerId = [], mapProducerIdObserverIds = [], mapDataProducerIdDataConsumerIds = [], mapDataConsumerIdDataProducerId = []) {
        this.id = id;
        this.transportIds = transportIds;
        this.rtpObserverIds = rtpObserverIds;
        this.mapProducerIdConsumerIds = mapProducerIdConsumerIds;
        this.mapConsumerIdProducerId = mapConsumerIdProducerId;
        this.mapProducerIdObserverIds = mapProducerIdObserverIds;
        this.mapDataProducerIdDataConsumerIds = mapDataProducerIdDataConsumerIds;
        this.mapDataConsumerIdDataProducerId = mapDataConsumerIdDataProducerId;
    }
    pack(builder) {
        const id = (this.id !== null ? builder.createString(this.id) : 0);
        const transportIds = DumpResponse.createTransportIdsVector(builder, builder.createObjectOffsetList(this.transportIds));
        const rtpObserverIds = DumpResponse.createRtpObserverIdsVector(builder, builder.createObjectOffsetList(this.rtpObserverIds));
        const mapProducerIdConsumerIds = DumpResponse.createMapProducerIdConsumerIdsVector(builder, builder.createObjectOffsetList(this.mapProducerIdConsumerIds));
        const mapConsumerIdProducerId = DumpResponse.createMapConsumerIdProducerIdVector(builder, builder.createObjectOffsetList(this.mapConsumerIdProducerId));
        const mapProducerIdObserverIds = DumpResponse.createMapProducerIdObserverIdsVector(builder, builder.createObjectOffsetList(this.mapProducerIdObserverIds));
        const mapDataProducerIdDataConsumerIds = DumpResponse.createMapDataProducerIdDataConsumerIdsVector(builder, builder.createObjectOffsetList(this.mapDataProducerIdDataConsumerIds));
        const mapDataConsumerIdDataProducerId = DumpResponse.createMapDataConsumerIdDataProducerIdVector(builder, builder.createObjectOffsetList(this.mapDataConsumerIdDataProducerId));
        return DumpResponse.createDumpResponse(builder, id, transportIds, rtpObserverIds, mapProducerIdConsumerIds, mapConsumerIdProducerId, mapProducerIdObserverIds, mapDataProducerIdDataConsumerIds, mapDataConsumerIdDataProducerId);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-observer.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-observer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveProducerRequestT = exports.RemoveProducerRequest = exports.AddProducerRequestT = exports.AddProducerRequest = void 0;
var add_producer_request_1 = __webpack_require__(/*! ./rtp-observer/add-producer-request */ "../../node_modules/mediasoup/node/lib/fbs/rtp-observer/add-producer-request.js");
Object.defineProperty(exports, "AddProducerRequest", ({ enumerable: true, get: function () { return add_producer_request_1.AddProducerRequest; } }));
Object.defineProperty(exports, "AddProducerRequestT", ({ enumerable: true, get: function () { return add_producer_request_1.AddProducerRequestT; } }));
var remove_producer_request_1 = __webpack_require__(/*! ./rtp-observer/remove-producer-request */ "../../node_modules/mediasoup/node/lib/fbs/rtp-observer/remove-producer-request.js");
Object.defineProperty(exports, "RemoveProducerRequest", ({ enumerable: true, get: function () { return remove_producer_request_1.RemoveProducerRequest; } }));
Object.defineProperty(exports, "RemoveProducerRequestT", ({ enumerable: true, get: function () { return remove_producer_request_1.RemoveProducerRequestT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-observer/add-producer-request.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-observer/add-producer-request.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddProducerRequestT = exports.AddProducerRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class AddProducerRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsAddProducerRequest(bb, obj) {
        return (obj || new AddProducerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsAddProducerRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new AddProducerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    producerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startAddProducerRequest(builder) {
        builder.startObject(1);
    }
    static addProducerId(builder, producerIdOffset) {
        builder.addFieldOffset(0, producerIdOffset, 0);
    }
    static endAddProducerRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // producer_id
        return offset;
    }
    static createAddProducerRequest(builder, producerIdOffset) {
        AddProducerRequest.startAddProducerRequest(builder);
        AddProducerRequest.addProducerId(builder, producerIdOffset);
        return AddProducerRequest.endAddProducerRequest(builder);
    }
    unpack() {
        return new AddProducerRequestT(this.producerId());
    }
    unpackTo(_o) {
        _o.producerId = this.producerId();
    }
}
exports.AddProducerRequest = AddProducerRequest;
class AddProducerRequestT {
    producerId;
    constructor(producerId = null) {
        this.producerId = producerId;
    }
    pack(builder) {
        const producerId = (this.producerId !== null ? builder.createString(this.producerId) : 0);
        return AddProducerRequest.createAddProducerRequest(builder, producerId);
    }
}
exports.AddProducerRequestT = AddProducerRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-observer/remove-producer-request.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-observer/remove-producer-request.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveProducerRequestT = exports.RemoveProducerRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RemoveProducerRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRemoveProducerRequest(bb, obj) {
        return (obj || new RemoveProducerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRemoveProducerRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RemoveProducerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    producerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startRemoveProducerRequest(builder) {
        builder.startObject(1);
    }
    static addProducerId(builder, producerIdOffset) {
        builder.addFieldOffset(0, producerIdOffset, 0);
    }
    static endRemoveProducerRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // producer_id
        return offset;
    }
    static createRemoveProducerRequest(builder, producerIdOffset) {
        RemoveProducerRequest.startRemoveProducerRequest(builder);
        RemoveProducerRequest.addProducerId(builder, producerIdOffset);
        return RemoveProducerRequest.endRemoveProducerRequest(builder);
    }
    unpack() {
        return new RemoveProducerRequestT(this.producerId());
    }
    unpackTo(_o) {
        _o.producerId = this.producerId();
    }
}
exports.RemoveProducerRequest = RemoveProducerRequest;
class RemoveProducerRequestT {
    producerId;
    constructor(producerId = null) {
        this.producerId = producerId;
    }
    pack(builder) {
        const producerId = (this.producerId !== null ? builder.createString(this.producerId) : 0);
        return RemoveProducerRequest.createRemoveProducerRequest(builder, producerId);
    }
}
exports.RemoveProducerRequestT = RemoveProducerRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-packet/dump.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-packet/dump.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpT = exports.Dump = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Dump {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDump(bb, obj) {
        return (obj || new Dump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDump(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Dump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    payloadType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    sequenceNumber() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    timestamp() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    marker() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    isKeyFrame() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    size() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    payloadSize() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    spatialLayer() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    temporalLayer() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    mid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    rid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    rrid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    wideSequenceNumber() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : null;
    }
    static startDump(builder) {
        builder.startObject(14);
    }
    static addPayloadType(builder, payloadType) {
        builder.addFieldInt8(0, payloadType, 0);
    }
    static addSequenceNumber(builder, sequenceNumber) {
        builder.addFieldInt16(1, sequenceNumber, 0);
    }
    static addTimestamp(builder, timestamp) {
        builder.addFieldInt32(2, timestamp, 0);
    }
    static addMarker(builder, marker) {
        builder.addFieldInt8(3, +marker, +false);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(4, ssrc, 0);
    }
    static addIsKeyFrame(builder, isKeyFrame) {
        builder.addFieldInt8(5, +isKeyFrame, +false);
    }
    static addSize(builder, size) {
        builder.addFieldInt64(6, size, BigInt('0'));
    }
    static addPayloadSize(builder, payloadSize) {
        builder.addFieldInt64(7, payloadSize, BigInt('0'));
    }
    static addSpatialLayer(builder, spatialLayer) {
        builder.addFieldInt8(8, spatialLayer, 0);
    }
    static addTemporalLayer(builder, temporalLayer) {
        builder.addFieldInt8(9, temporalLayer, 0);
    }
    static addMid(builder, midOffset) {
        builder.addFieldOffset(10, midOffset, 0);
    }
    static addRid(builder, ridOffset) {
        builder.addFieldOffset(11, ridOffset, 0);
    }
    static addRrid(builder, rridOffset) {
        builder.addFieldOffset(12, rridOffset, 0);
    }
    static addWideSequenceNumber(builder, wideSequenceNumber) {
        builder.addFieldInt16(13, wideSequenceNumber, 0);
    }
    static endDump(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDump(builder, payloadType, sequenceNumber, timestamp, marker, ssrc, isKeyFrame, size, payloadSize, spatialLayer, temporalLayer, midOffset, ridOffset, rridOffset, wideSequenceNumber) {
        Dump.startDump(builder);
        Dump.addPayloadType(builder, payloadType);
        Dump.addSequenceNumber(builder, sequenceNumber);
        Dump.addTimestamp(builder, timestamp);
        Dump.addMarker(builder, marker);
        Dump.addSsrc(builder, ssrc);
        Dump.addIsKeyFrame(builder, isKeyFrame);
        Dump.addSize(builder, size);
        Dump.addPayloadSize(builder, payloadSize);
        Dump.addSpatialLayer(builder, spatialLayer);
        Dump.addTemporalLayer(builder, temporalLayer);
        Dump.addMid(builder, midOffset);
        Dump.addRid(builder, ridOffset);
        Dump.addRrid(builder, rridOffset);
        if (wideSequenceNumber !== null)
            Dump.addWideSequenceNumber(builder, wideSequenceNumber);
        return Dump.endDump(builder);
    }
    unpack() {
        return new DumpT(this.payloadType(), this.sequenceNumber(), this.timestamp(), this.marker(), this.ssrc(), this.isKeyFrame(), this.size(), this.payloadSize(), this.spatialLayer(), this.temporalLayer(), this.mid(), this.rid(), this.rrid(), this.wideSequenceNumber());
    }
    unpackTo(_o) {
        _o.payloadType = this.payloadType();
        _o.sequenceNumber = this.sequenceNumber();
        _o.timestamp = this.timestamp();
        _o.marker = this.marker();
        _o.ssrc = this.ssrc();
        _o.isKeyFrame = this.isKeyFrame();
        _o.size = this.size();
        _o.payloadSize = this.payloadSize();
        _o.spatialLayer = this.spatialLayer();
        _o.temporalLayer = this.temporalLayer();
        _o.mid = this.mid();
        _o.rid = this.rid();
        _o.rrid = this.rrid();
        _o.wideSequenceNumber = this.wideSequenceNumber();
    }
}
exports.Dump = Dump;
class DumpT {
    payloadType;
    sequenceNumber;
    timestamp;
    marker;
    ssrc;
    isKeyFrame;
    size;
    payloadSize;
    spatialLayer;
    temporalLayer;
    mid;
    rid;
    rrid;
    wideSequenceNumber;
    constructor(payloadType = 0, sequenceNumber = 0, timestamp = 0, marker = false, ssrc = 0, isKeyFrame = false, size = BigInt('0'), payloadSize = BigInt('0'), spatialLayer = 0, temporalLayer = 0, mid = null, rid = null, rrid = null, wideSequenceNumber = null) {
        this.payloadType = payloadType;
        this.sequenceNumber = sequenceNumber;
        this.timestamp = timestamp;
        this.marker = marker;
        this.ssrc = ssrc;
        this.isKeyFrame = isKeyFrame;
        this.size = size;
        this.payloadSize = payloadSize;
        this.spatialLayer = spatialLayer;
        this.temporalLayer = temporalLayer;
        this.mid = mid;
        this.rid = rid;
        this.rrid = rrid;
        this.wideSequenceNumber = wideSequenceNumber;
    }
    pack(builder) {
        const mid = (this.mid !== null ? builder.createString(this.mid) : 0);
        const rid = (this.rid !== null ? builder.createString(this.rid) : 0);
        const rrid = (this.rrid !== null ? builder.createString(this.rrid) : 0);
        return Dump.createDump(builder, this.payloadType, this.sequenceNumber, this.timestamp, this.marker, this.ssrc, this.isKeyFrame, this.size, this.payloadSize, this.spatialLayer, this.temporalLayer, mid, rid, rrid, this.wideSequenceNumber);
    }
}
exports.DumpT = DumpT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Value = exports.Type = exports.StringT = exports.String = exports.RtxT = exports.Rtx = exports.RtpParametersT = exports.RtpParameters = exports.RtpMappingT = exports.RtpMapping = exports.RtpHeaderExtensionUri = exports.RtpHeaderExtensionParametersT = exports.RtpHeaderExtensionParameters = exports.RtpEncodingParametersT = exports.RtpEncodingParameters = exports.RtpCodecParametersT = exports.RtpCodecParameters = exports.RtcpParametersT = exports.RtcpParameters = exports.RtcpFeedbackT = exports.RtcpFeedback = exports.ParameterT = exports.Parameter = exports.MediaKind = exports.Integer32ArrayT = exports.Integer32Array = exports.Integer32T = exports.Integer32 = exports.EncodingMappingT = exports.EncodingMapping = exports.DoubleT = exports.Double = exports.CodecMappingT = exports.CodecMapping = exports.BooleanT = exports.Boolean = void 0;
var boolean_1 = __webpack_require__(/*! ./rtp-parameters/boolean */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/boolean.js");
Object.defineProperty(exports, "Boolean", ({ enumerable: true, get: function () { return boolean_1.Boolean; } }));
Object.defineProperty(exports, "BooleanT", ({ enumerable: true, get: function () { return boolean_1.BooleanT; } }));
var codec_mapping_1 = __webpack_require__(/*! ./rtp-parameters/codec-mapping */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/codec-mapping.js");
Object.defineProperty(exports, "CodecMapping", ({ enumerable: true, get: function () { return codec_mapping_1.CodecMapping; } }));
Object.defineProperty(exports, "CodecMappingT", ({ enumerable: true, get: function () { return codec_mapping_1.CodecMappingT; } }));
var double_1 = __webpack_require__(/*! ./rtp-parameters/double */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/double.js");
Object.defineProperty(exports, "Double", ({ enumerable: true, get: function () { return double_1.Double; } }));
Object.defineProperty(exports, "DoubleT", ({ enumerable: true, get: function () { return double_1.DoubleT; } }));
var encoding_mapping_1 = __webpack_require__(/*! ./rtp-parameters/encoding-mapping */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/encoding-mapping.js");
Object.defineProperty(exports, "EncodingMapping", ({ enumerable: true, get: function () { return encoding_mapping_1.EncodingMapping; } }));
Object.defineProperty(exports, "EncodingMappingT", ({ enumerable: true, get: function () { return encoding_mapping_1.EncodingMappingT; } }));
var integer32_1 = __webpack_require__(/*! ./rtp-parameters/integer32 */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/integer32.js");
Object.defineProperty(exports, "Integer32", ({ enumerable: true, get: function () { return integer32_1.Integer32; } }));
Object.defineProperty(exports, "Integer32T", ({ enumerable: true, get: function () { return integer32_1.Integer32T; } }));
var integer32_array_1 = __webpack_require__(/*! ./rtp-parameters/integer32-array */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/integer32-array.js");
Object.defineProperty(exports, "Integer32Array", ({ enumerable: true, get: function () { return integer32_array_1.Integer32Array; } }));
Object.defineProperty(exports, "Integer32ArrayT", ({ enumerable: true, get: function () { return integer32_array_1.Integer32ArrayT; } }));
var media_kind_1 = __webpack_require__(/*! ./rtp-parameters/media-kind */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js");
Object.defineProperty(exports, "MediaKind", ({ enumerable: true, get: function () { return media_kind_1.MediaKind; } }));
var parameter_1 = __webpack_require__(/*! ./rtp-parameters/parameter */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/parameter.js");
Object.defineProperty(exports, "Parameter", ({ enumerable: true, get: function () { return parameter_1.Parameter; } }));
Object.defineProperty(exports, "ParameterT", ({ enumerable: true, get: function () { return parameter_1.ParameterT; } }));
var rtcp_feedback_1 = __webpack_require__(/*! ./rtp-parameters/rtcp-feedback */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtcp-feedback.js");
Object.defineProperty(exports, "RtcpFeedback", ({ enumerable: true, get: function () { return rtcp_feedback_1.RtcpFeedback; } }));
Object.defineProperty(exports, "RtcpFeedbackT", ({ enumerable: true, get: function () { return rtcp_feedback_1.RtcpFeedbackT; } }));
var rtcp_parameters_1 = __webpack_require__(/*! ./rtp-parameters/rtcp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtcp-parameters.js");
Object.defineProperty(exports, "RtcpParameters", ({ enumerable: true, get: function () { return rtcp_parameters_1.RtcpParameters; } }));
Object.defineProperty(exports, "RtcpParametersT", ({ enumerable: true, get: function () { return rtcp_parameters_1.RtcpParametersT; } }));
var rtp_codec_parameters_1 = __webpack_require__(/*! ./rtp-parameters/rtp-codec-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-codec-parameters.js");
Object.defineProperty(exports, "RtpCodecParameters", ({ enumerable: true, get: function () { return rtp_codec_parameters_1.RtpCodecParameters; } }));
Object.defineProperty(exports, "RtpCodecParametersT", ({ enumerable: true, get: function () { return rtp_codec_parameters_1.RtpCodecParametersT; } }));
var rtp_encoding_parameters_1 = __webpack_require__(/*! ./rtp-parameters/rtp-encoding-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-encoding-parameters.js");
Object.defineProperty(exports, "RtpEncodingParameters", ({ enumerable: true, get: function () { return rtp_encoding_parameters_1.RtpEncodingParameters; } }));
Object.defineProperty(exports, "RtpEncodingParametersT", ({ enumerable: true, get: function () { return rtp_encoding_parameters_1.RtpEncodingParametersT; } }));
var rtp_header_extension_parameters_1 = __webpack_require__(/*! ./rtp-parameters/rtp-header-extension-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-header-extension-parameters.js");
Object.defineProperty(exports, "RtpHeaderExtensionParameters", ({ enumerable: true, get: function () { return rtp_header_extension_parameters_1.RtpHeaderExtensionParameters; } }));
Object.defineProperty(exports, "RtpHeaderExtensionParametersT", ({ enumerable: true, get: function () { return rtp_header_extension_parameters_1.RtpHeaderExtensionParametersT; } }));
var rtp_header_extension_uri_1 = __webpack_require__(/*! ./rtp-parameters/rtp-header-extension-uri */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-header-extension-uri.js");
Object.defineProperty(exports, "RtpHeaderExtensionUri", ({ enumerable: true, get: function () { return rtp_header_extension_uri_1.RtpHeaderExtensionUri; } }));
var rtp_mapping_1 = __webpack_require__(/*! ./rtp-parameters/rtp-mapping */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-mapping.js");
Object.defineProperty(exports, "RtpMapping", ({ enumerable: true, get: function () { return rtp_mapping_1.RtpMapping; } }));
Object.defineProperty(exports, "RtpMappingT", ({ enumerable: true, get: function () { return rtp_mapping_1.RtpMappingT; } }));
var rtp_parameters_1 = __webpack_require__(/*! ./rtp-parameters/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-parameters.js");
Object.defineProperty(exports, "RtpParameters", ({ enumerable: true, get: function () { return rtp_parameters_1.RtpParameters; } }));
Object.defineProperty(exports, "RtpParametersT", ({ enumerable: true, get: function () { return rtp_parameters_1.RtpParametersT; } }));
var rtx_1 = __webpack_require__(/*! ./rtp-parameters/rtx */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtx.js");
Object.defineProperty(exports, "Rtx", ({ enumerable: true, get: function () { return rtx_1.Rtx; } }));
Object.defineProperty(exports, "RtxT", ({ enumerable: true, get: function () { return rtx_1.RtxT; } }));
var string_1 = __webpack_require__(/*! ./rtp-parameters/string */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/string.js");
Object.defineProperty(exports, "String", ({ enumerable: true, get: function () { return string_1.String; } }));
Object.defineProperty(exports, "StringT", ({ enumerable: true, get: function () { return string_1.StringT; } }));
var type_1 = __webpack_require__(/*! ./rtp-parameters/type */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/type.js");
Object.defineProperty(exports, "Type", ({ enumerable: true, get: function () { return type_1.Type; } }));
var value_1 = __webpack_require__(/*! ./rtp-parameters/value */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/value.js");
Object.defineProperty(exports, "Value", ({ enumerable: true, get: function () { return value_1.Value; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/boolean.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/boolean.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BooleanT = exports.Boolean = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Boolean {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBoolean(bb, obj) {
        return (obj || new Boolean()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBoolean(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Boolean()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    value() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startBoolean(builder) {
        builder.startObject(1);
    }
    static addValue(builder, value) {
        builder.addFieldInt8(0, value, 0);
    }
    static endBoolean(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBoolean(builder, value) {
        Boolean.startBoolean(builder);
        Boolean.addValue(builder, value);
        return Boolean.endBoolean(builder);
    }
    unpack() {
        return new BooleanT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
exports.Boolean = Boolean;
class BooleanT {
    value;
    constructor(value = 0) {
        this.value = value;
    }
    pack(builder) {
        return Boolean.createBoolean(builder, this.value);
    }
}
exports.BooleanT = BooleanT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/codec-mapping.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/codec-mapping.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodecMappingT = exports.CodecMapping = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CodecMapping {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCodecMapping(bb, obj) {
        return (obj || new CodecMapping()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCodecMapping(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CodecMapping()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    payloadType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    mappedPayloadType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startCodecMapping(builder) {
        builder.startObject(2);
    }
    static addPayloadType(builder, payloadType) {
        builder.addFieldInt8(0, payloadType, 0);
    }
    static addMappedPayloadType(builder, mappedPayloadType) {
        builder.addFieldInt8(1, mappedPayloadType, 0);
    }
    static endCodecMapping(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createCodecMapping(builder, payloadType, mappedPayloadType) {
        CodecMapping.startCodecMapping(builder);
        CodecMapping.addPayloadType(builder, payloadType);
        CodecMapping.addMappedPayloadType(builder, mappedPayloadType);
        return CodecMapping.endCodecMapping(builder);
    }
    unpack() {
        return new CodecMappingT(this.payloadType(), this.mappedPayloadType());
    }
    unpackTo(_o) {
        _o.payloadType = this.payloadType();
        _o.mappedPayloadType = this.mappedPayloadType();
    }
}
exports.CodecMapping = CodecMapping;
class CodecMappingT {
    payloadType;
    mappedPayloadType;
    constructor(payloadType = 0, mappedPayloadType = 0) {
        this.payloadType = payloadType;
        this.mappedPayloadType = mappedPayloadType;
    }
    pack(builder) {
        return CodecMapping.createCodecMapping(builder, this.payloadType, this.mappedPayloadType);
    }
}
exports.CodecMappingT = CodecMappingT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/double.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/double.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DoubleT = exports.Double = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Double {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDouble(bb, obj) {
        return (obj || new Double()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDouble(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Double()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    value() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    static startDouble(builder) {
        builder.startObject(1);
    }
    static addValue(builder, value) {
        builder.addFieldFloat64(0, value, 0.0);
    }
    static endDouble(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDouble(builder, value) {
        Double.startDouble(builder);
        Double.addValue(builder, value);
        return Double.endDouble(builder);
    }
    unpack() {
        return new DoubleT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
exports.Double = Double;
class DoubleT {
    value;
    constructor(value = 0.0) {
        this.value = value;
    }
    pack(builder) {
        return Double.createDouble(builder, this.value);
    }
}
exports.DoubleT = DoubleT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/encoding-mapping.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/encoding-mapping.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EncodingMappingT = exports.EncodingMapping = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class EncodingMapping {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEncodingMapping(bb, obj) {
        return (obj || new EncodingMapping()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEncodingMapping(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EncodingMapping()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    rid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    scalabilityMode(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    mappedSsrc() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startEncodingMapping(builder) {
        builder.startObject(4);
    }
    static addRid(builder, ridOffset) {
        builder.addFieldOffset(0, ridOffset, 0);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(1, ssrc, 0);
    }
    static addScalabilityMode(builder, scalabilityModeOffset) {
        builder.addFieldOffset(2, scalabilityModeOffset, 0);
    }
    static addMappedSsrc(builder, mappedSsrc) {
        builder.addFieldInt32(3, mappedSsrc, 0);
    }
    static endEncodingMapping(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createEncodingMapping(builder, ridOffset, ssrc, scalabilityModeOffset, mappedSsrc) {
        EncodingMapping.startEncodingMapping(builder);
        EncodingMapping.addRid(builder, ridOffset);
        if (ssrc !== null)
            EncodingMapping.addSsrc(builder, ssrc);
        EncodingMapping.addScalabilityMode(builder, scalabilityModeOffset);
        EncodingMapping.addMappedSsrc(builder, mappedSsrc);
        return EncodingMapping.endEncodingMapping(builder);
    }
    unpack() {
        return new EncodingMappingT(this.rid(), this.ssrc(), this.scalabilityMode(), this.mappedSsrc());
    }
    unpackTo(_o) {
        _o.rid = this.rid();
        _o.ssrc = this.ssrc();
        _o.scalabilityMode = this.scalabilityMode();
        _o.mappedSsrc = this.mappedSsrc();
    }
}
exports.EncodingMapping = EncodingMapping;
class EncodingMappingT {
    rid;
    ssrc;
    scalabilityMode;
    mappedSsrc;
    constructor(rid = null, ssrc = null, scalabilityMode = null, mappedSsrc = 0) {
        this.rid = rid;
        this.ssrc = ssrc;
        this.scalabilityMode = scalabilityMode;
        this.mappedSsrc = mappedSsrc;
    }
    pack(builder) {
        const rid = (this.rid !== null ? builder.createString(this.rid) : 0);
        const scalabilityMode = (this.scalabilityMode !== null ? builder.createString(this.scalabilityMode) : 0);
        return EncodingMapping.createEncodingMapping(builder, rid, this.ssrc, scalabilityMode, this.mappedSsrc);
    }
}
exports.EncodingMappingT = EncodingMappingT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/integer32-array.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/integer32-array.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Integer32ArrayT = exports.Integer32Array = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Integer32Array {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsInteger32Array(bb, obj) {
        return (obj || new Integer32Array()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInteger32Array(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Integer32Array()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    value(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    valueLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    valueArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startInteger32Array(builder) {
        builder.startObject(1);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(0, valueOffset, 0);
    }
    static createValueVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startValueVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endInteger32Array(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createInteger32Array(builder, valueOffset) {
        Integer32Array.startInteger32Array(builder);
        Integer32Array.addValue(builder, valueOffset);
        return Integer32Array.endInteger32Array(builder);
    }
    unpack() {
        return new Integer32ArrayT(this.bb.createScalarList(this.value.bind(this), this.valueLength()));
    }
    unpackTo(_o) {
        _o.value = this.bb.createScalarList(this.value.bind(this), this.valueLength());
    }
}
exports.Integer32Array = Integer32Array;
class Integer32ArrayT {
    value;
    constructor(value = []) {
        this.value = value;
    }
    pack(builder) {
        const value = Integer32Array.createValueVector(builder, this.value);
        return Integer32Array.createInteger32Array(builder, value);
    }
}
exports.Integer32ArrayT = Integer32ArrayT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/integer32.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/integer32.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Integer32T = exports.Integer32 = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Integer32 {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsInteger32(bb, obj) {
        return (obj || new Integer32()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInteger32(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Integer32()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    value() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startInteger32(builder) {
        builder.startObject(1);
    }
    static addValue(builder, value) {
        builder.addFieldInt32(0, value, 0);
    }
    static endInteger32(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createInteger32(builder, value) {
        Integer32.startInteger32(builder);
        Integer32.addValue(builder, value);
        return Integer32.endInteger32(builder);
    }
    unpack() {
        return new Integer32T(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
exports.Integer32 = Integer32;
class Integer32T {
    value;
    constructor(value = 0) {
        this.value = value;
    }
    pack(builder) {
        return Integer32.createInteger32(builder, this.value);
    }
}
exports.Integer32T = Integer32T;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediaKind = void 0;
var MediaKind;
(function (MediaKind) {
    MediaKind[MediaKind["AUDIO"] = 0] = "AUDIO";
    MediaKind[MediaKind["VIDEO"] = 1] = "VIDEO";
})(MediaKind || (exports.MediaKind = MediaKind = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/parameter.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/parameter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterT = exports.Parameter = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const value_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/value */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/value.js");
class Parameter {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsParameter(bb, obj) {
        return (obj || new Parameter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsParameter(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Parameter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    valueType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : value_1.Value.NONE;
    }
    value(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startParameter(builder) {
        builder.startObject(3);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addValueType(builder, valueType) {
        builder.addFieldInt8(1, valueType, value_1.Value.NONE);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(2, valueOffset, 0);
    }
    static endParameter(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // name
        builder.requiredField(offset, 8); // value
        return offset;
    }
    static createParameter(builder, nameOffset, valueType, valueOffset) {
        Parameter.startParameter(builder);
        Parameter.addName(builder, nameOffset);
        Parameter.addValueType(builder, valueType);
        Parameter.addValue(builder, valueOffset);
        return Parameter.endParameter(builder);
    }
    unpack() {
        return new ParameterT(this.name(), this.valueType(), (() => {
            const temp = (0, value_1.unionToValue)(this.valueType(), this.value.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.valueType = this.valueType();
        _o.value = (() => {
            const temp = (0, value_1.unionToValue)(this.valueType(), this.value.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
exports.Parameter = Parameter;
class ParameterT {
    name;
    valueType;
    value;
    constructor(name = null, valueType = value_1.Value.NONE, value = null) {
        this.name = name;
        this.valueType = valueType;
        this.value = value;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const value = builder.createObjectOffset(this.value);
        return Parameter.createParameter(builder, name, this.valueType, value);
    }
}
exports.ParameterT = ParameterT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtcp-feedback.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtcp-feedback.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtcpFeedbackT = exports.RtcpFeedback = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RtcpFeedback {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtcpFeedback(bb, obj) {
        return (obj || new RtcpFeedback()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtcpFeedback(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtcpFeedback()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    type(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    parameter(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startRtcpFeedback(builder) {
        builder.startObject(2);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(0, typeOffset, 0);
    }
    static addParameter(builder, parameterOffset) {
        builder.addFieldOffset(1, parameterOffset, 0);
    }
    static endRtcpFeedback(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // type
        return offset;
    }
    static createRtcpFeedback(builder, typeOffset, parameterOffset) {
        RtcpFeedback.startRtcpFeedback(builder);
        RtcpFeedback.addType(builder, typeOffset);
        RtcpFeedback.addParameter(builder, parameterOffset);
        return RtcpFeedback.endRtcpFeedback(builder);
    }
    unpack() {
        return new RtcpFeedbackT(this.type(), this.parameter());
    }
    unpackTo(_o) {
        _o.type = this.type();
        _o.parameter = this.parameter();
    }
}
exports.RtcpFeedback = RtcpFeedback;
class RtcpFeedbackT {
    type;
    parameter;
    constructor(type = null, parameter = null) {
        this.type = type;
        this.parameter = parameter;
    }
    pack(builder) {
        const type = (this.type !== null ? builder.createString(this.type) : 0);
        const parameter = (this.parameter !== null ? builder.createString(this.parameter) : 0);
        return RtcpFeedback.createRtcpFeedback(builder, type, parameter);
    }
}
exports.RtcpFeedbackT = RtcpFeedbackT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtcp-parameters.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtcp-parameters.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtcpParametersT = exports.RtcpParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RtcpParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtcpParameters(bb, obj) {
        return (obj || new RtcpParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtcpParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtcpParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    cname(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    reducedSize() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : true;
    }
    static startRtcpParameters(builder) {
        builder.startObject(2);
    }
    static addCname(builder, cnameOffset) {
        builder.addFieldOffset(0, cnameOffset, 0);
    }
    static addReducedSize(builder, reducedSize) {
        builder.addFieldInt8(1, +reducedSize, +true);
    }
    static endRtcpParameters(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRtcpParameters(builder, cnameOffset, reducedSize) {
        RtcpParameters.startRtcpParameters(builder);
        RtcpParameters.addCname(builder, cnameOffset);
        RtcpParameters.addReducedSize(builder, reducedSize);
        return RtcpParameters.endRtcpParameters(builder);
    }
    unpack() {
        return new RtcpParametersT(this.cname(), this.reducedSize());
    }
    unpackTo(_o) {
        _o.cname = this.cname();
        _o.reducedSize = this.reducedSize();
    }
}
exports.RtcpParameters = RtcpParameters;
class RtcpParametersT {
    cname;
    reducedSize;
    constructor(cname = null, reducedSize = true) {
        this.cname = cname;
        this.reducedSize = reducedSize;
    }
    pack(builder) {
        const cname = (this.cname !== null ? builder.createString(this.cname) : 0);
        return RtcpParameters.createRtcpParameters(builder, cname, this.reducedSize);
    }
}
exports.RtcpParametersT = RtcpParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-codec-parameters.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-codec-parameters.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpCodecParametersT = exports.RtpCodecParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const parameter_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/parameter */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/parameter.js");
const rtcp_feedback_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtcp-feedback */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtcp-feedback.js");
class RtpCodecParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpCodecParameters(bb, obj) {
        return (obj || new RtpCodecParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpCodecParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpCodecParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mimeType(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    payloadType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    clockRate() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    channels() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    parameters(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new parameter_1.Parameter()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    parametersLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    rtcpFeedback(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new rtcp_feedback_1.RtcpFeedback()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    rtcpFeedbackLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRtpCodecParameters(builder) {
        builder.startObject(6);
    }
    static addMimeType(builder, mimeTypeOffset) {
        builder.addFieldOffset(0, mimeTypeOffset, 0);
    }
    static addPayloadType(builder, payloadType) {
        builder.addFieldInt8(1, payloadType, 0);
    }
    static addClockRate(builder, clockRate) {
        builder.addFieldInt32(2, clockRate, 0);
    }
    static addChannels(builder, channels) {
        builder.addFieldInt8(3, channels, 0);
    }
    static addParameters(builder, parametersOffset) {
        builder.addFieldOffset(4, parametersOffset, 0);
    }
    static createParametersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startParametersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRtcpFeedback(builder, rtcpFeedbackOffset) {
        builder.addFieldOffset(5, rtcpFeedbackOffset, 0);
    }
    static createRtcpFeedbackVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRtcpFeedbackVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRtpCodecParameters(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // mime_type
        return offset;
    }
    static createRtpCodecParameters(builder, mimeTypeOffset, payloadType, clockRate, channels, parametersOffset, rtcpFeedbackOffset) {
        RtpCodecParameters.startRtpCodecParameters(builder);
        RtpCodecParameters.addMimeType(builder, mimeTypeOffset);
        RtpCodecParameters.addPayloadType(builder, payloadType);
        RtpCodecParameters.addClockRate(builder, clockRate);
        if (channels !== null)
            RtpCodecParameters.addChannels(builder, channels);
        RtpCodecParameters.addParameters(builder, parametersOffset);
        RtpCodecParameters.addRtcpFeedback(builder, rtcpFeedbackOffset);
        return RtpCodecParameters.endRtpCodecParameters(builder);
    }
    unpack() {
        return new RtpCodecParametersT(this.mimeType(), this.payloadType(), this.clockRate(), this.channels(), this.bb.createObjList(this.parameters.bind(this), this.parametersLength()), this.bb.createObjList(this.rtcpFeedback.bind(this), this.rtcpFeedbackLength()));
    }
    unpackTo(_o) {
        _o.mimeType = this.mimeType();
        _o.payloadType = this.payloadType();
        _o.clockRate = this.clockRate();
        _o.channels = this.channels();
        _o.parameters = this.bb.createObjList(this.parameters.bind(this), this.parametersLength());
        _o.rtcpFeedback = this.bb.createObjList(this.rtcpFeedback.bind(this), this.rtcpFeedbackLength());
    }
}
exports.RtpCodecParameters = RtpCodecParameters;
class RtpCodecParametersT {
    mimeType;
    payloadType;
    clockRate;
    channels;
    parameters;
    rtcpFeedback;
    constructor(mimeType = null, payloadType = 0, clockRate = 0, channels = null, parameters = [], rtcpFeedback = []) {
        this.mimeType = mimeType;
        this.payloadType = payloadType;
        this.clockRate = clockRate;
        this.channels = channels;
        this.parameters = parameters;
        this.rtcpFeedback = rtcpFeedback;
    }
    pack(builder) {
        const mimeType = (this.mimeType !== null ? builder.createString(this.mimeType) : 0);
        const parameters = RtpCodecParameters.createParametersVector(builder, builder.createObjectOffsetList(this.parameters));
        const rtcpFeedback = RtpCodecParameters.createRtcpFeedbackVector(builder, builder.createObjectOffsetList(this.rtcpFeedback));
        return RtpCodecParameters.createRtpCodecParameters(builder, mimeType, this.payloadType, this.clockRate, this.channels, parameters, rtcpFeedback);
    }
}
exports.RtpCodecParametersT = RtpCodecParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-encoding-parameters.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-encoding-parameters.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpEncodingParametersT = exports.RtpEncodingParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const rtx_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtx */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtx.js");
class RtpEncodingParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpEncodingParameters(bb, obj) {
        return (obj || new RtpEncodingParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpEncodingParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpEncodingParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    rid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    codecPayloadType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    rtx(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new rtx_1.Rtx()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dtx() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    scalabilityMode(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    maxBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    static startRtpEncodingParameters(builder) {
        builder.startObject(7);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(0, ssrc, 0);
    }
    static addRid(builder, ridOffset) {
        builder.addFieldOffset(1, ridOffset, 0);
    }
    static addCodecPayloadType(builder, codecPayloadType) {
        builder.addFieldInt8(2, codecPayloadType, 0);
    }
    static addRtx(builder, rtxOffset) {
        builder.addFieldOffset(3, rtxOffset, 0);
    }
    static addDtx(builder, dtx) {
        builder.addFieldInt8(4, +dtx, +false);
    }
    static addScalabilityMode(builder, scalabilityModeOffset) {
        builder.addFieldOffset(5, scalabilityModeOffset, 0);
    }
    static addMaxBitrate(builder, maxBitrate) {
        builder.addFieldInt32(6, maxBitrate, 0);
    }
    static endRtpEncodingParameters(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new RtpEncodingParametersT(this.ssrc(), this.rid(), this.codecPayloadType(), (this.rtx() !== null ? this.rtx().unpack() : null), this.dtx(), this.scalabilityMode(), this.maxBitrate());
    }
    unpackTo(_o) {
        _o.ssrc = this.ssrc();
        _o.rid = this.rid();
        _o.codecPayloadType = this.codecPayloadType();
        _o.rtx = (this.rtx() !== null ? this.rtx().unpack() : null);
        _o.dtx = this.dtx();
        _o.scalabilityMode = this.scalabilityMode();
        _o.maxBitrate = this.maxBitrate();
    }
}
exports.RtpEncodingParameters = RtpEncodingParameters;
class RtpEncodingParametersT {
    ssrc;
    rid;
    codecPayloadType;
    rtx;
    dtx;
    scalabilityMode;
    maxBitrate;
    constructor(ssrc = null, rid = null, codecPayloadType = null, rtx = null, dtx = false, scalabilityMode = null, maxBitrate = null) {
        this.ssrc = ssrc;
        this.rid = rid;
        this.codecPayloadType = codecPayloadType;
        this.rtx = rtx;
        this.dtx = dtx;
        this.scalabilityMode = scalabilityMode;
        this.maxBitrate = maxBitrate;
    }
    pack(builder) {
        const rid = (this.rid !== null ? builder.createString(this.rid) : 0);
        const rtx = (this.rtx !== null ? this.rtx.pack(builder) : 0);
        const scalabilityMode = (this.scalabilityMode !== null ? builder.createString(this.scalabilityMode) : 0);
        RtpEncodingParameters.startRtpEncodingParameters(builder);
        if (this.ssrc !== null)
            RtpEncodingParameters.addSsrc(builder, this.ssrc);
        RtpEncodingParameters.addRid(builder, rid);
        if (this.codecPayloadType !== null)
            RtpEncodingParameters.addCodecPayloadType(builder, this.codecPayloadType);
        RtpEncodingParameters.addRtx(builder, rtx);
        RtpEncodingParameters.addDtx(builder, this.dtx);
        RtpEncodingParameters.addScalabilityMode(builder, scalabilityMode);
        if (this.maxBitrate !== null)
            RtpEncodingParameters.addMaxBitrate(builder, this.maxBitrate);
        return RtpEncodingParameters.endRtpEncodingParameters(builder);
    }
}
exports.RtpEncodingParametersT = RtpEncodingParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-header-extension-parameters.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-header-extension-parameters.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpHeaderExtensionParametersT = exports.RtpHeaderExtensionParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const parameter_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/parameter */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/parameter.js");
const rtp_header_extension_uri_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-header-extension-uri */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-header-extension-uri.js");
class RtpHeaderExtensionParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpHeaderExtensionParameters(bb, obj) {
        return (obj || new RtpHeaderExtensionParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpHeaderExtensionParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpHeaderExtensionParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    uri() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : rtp_header_extension_uri_1.RtpHeaderExtensionUri.Mid;
    }
    id() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    encrypt() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    parameters(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new parameter_1.Parameter()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    parametersLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRtpHeaderExtensionParameters(builder) {
        builder.startObject(4);
    }
    static addUri(builder, uri) {
        builder.addFieldInt8(0, uri, rtp_header_extension_uri_1.RtpHeaderExtensionUri.Mid);
    }
    static addId(builder, id) {
        builder.addFieldInt8(1, id, 0);
    }
    static addEncrypt(builder, encrypt) {
        builder.addFieldInt8(2, +encrypt, +false);
    }
    static addParameters(builder, parametersOffset) {
        builder.addFieldOffset(3, parametersOffset, 0);
    }
    static createParametersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startParametersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRtpHeaderExtensionParameters(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRtpHeaderExtensionParameters(builder, uri, id, encrypt, parametersOffset) {
        RtpHeaderExtensionParameters.startRtpHeaderExtensionParameters(builder);
        RtpHeaderExtensionParameters.addUri(builder, uri);
        RtpHeaderExtensionParameters.addId(builder, id);
        RtpHeaderExtensionParameters.addEncrypt(builder, encrypt);
        RtpHeaderExtensionParameters.addParameters(builder, parametersOffset);
        return RtpHeaderExtensionParameters.endRtpHeaderExtensionParameters(builder);
    }
    unpack() {
        return new RtpHeaderExtensionParametersT(this.uri(), this.id(), this.encrypt(), this.bb.createObjList(this.parameters.bind(this), this.parametersLength()));
    }
    unpackTo(_o) {
        _o.uri = this.uri();
        _o.id = this.id();
        _o.encrypt = this.encrypt();
        _o.parameters = this.bb.createObjList(this.parameters.bind(this), this.parametersLength());
    }
}
exports.RtpHeaderExtensionParameters = RtpHeaderExtensionParameters;
class RtpHeaderExtensionParametersT {
    uri;
    id;
    encrypt;
    parameters;
    constructor(uri = rtp_header_extension_uri_1.RtpHeaderExtensionUri.Mid, id = 0, encrypt = false, parameters = []) {
        this.uri = uri;
        this.id = id;
        this.encrypt = encrypt;
        this.parameters = parameters;
    }
    pack(builder) {
        const parameters = RtpHeaderExtensionParameters.createParametersVector(builder, builder.createObjectOffsetList(this.parameters));
        return RtpHeaderExtensionParameters.createRtpHeaderExtensionParameters(builder, this.uri, this.id, this.encrypt, parameters);
    }
}
exports.RtpHeaderExtensionParametersT = RtpHeaderExtensionParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-header-extension-uri.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-header-extension-uri.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpHeaderExtensionUri = void 0;
var RtpHeaderExtensionUri;
(function (RtpHeaderExtensionUri) {
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["Mid"] = 0] = "Mid";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["RtpStreamId"] = 1] = "RtpStreamId";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["RepairRtpStreamId"] = 2] = "RepairRtpStreamId";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["FrameMarkingDraft07"] = 3] = "FrameMarkingDraft07";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["FrameMarking"] = 4] = "FrameMarking";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["AudioLevel"] = 5] = "AudioLevel";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["VideoOrientation"] = 6] = "VideoOrientation";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["TimeOffset"] = 7] = "TimeOffset";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["TransportWideCcDraft01"] = 8] = "TransportWideCcDraft01";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["AbsSendTime"] = 9] = "AbsSendTime";
    RtpHeaderExtensionUri[RtpHeaderExtensionUri["AbsCaptureTime"] = 10] = "AbsCaptureTime";
})(RtpHeaderExtensionUri || (exports.RtpHeaderExtensionUri = RtpHeaderExtensionUri = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-mapping.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-mapping.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpMappingT = exports.RtpMapping = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const codec_mapping_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/codec-mapping */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/codec-mapping.js");
const encoding_mapping_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/encoding-mapping */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/encoding-mapping.js");
class RtpMapping {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpMapping(bb, obj) {
        return (obj || new RtpMapping()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpMapping(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpMapping()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    codecs(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new codec_mapping_1.CodecMapping()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    codecsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    encodings(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new encoding_mapping_1.EncodingMapping()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    encodingsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRtpMapping(builder) {
        builder.startObject(2);
    }
    static addCodecs(builder, codecsOffset) {
        builder.addFieldOffset(0, codecsOffset, 0);
    }
    static createCodecsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCodecsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addEncodings(builder, encodingsOffset) {
        builder.addFieldOffset(1, encodingsOffset, 0);
    }
    static createEncodingsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startEncodingsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRtpMapping(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // codecs
        builder.requiredField(offset, 6); // encodings
        return offset;
    }
    static createRtpMapping(builder, codecsOffset, encodingsOffset) {
        RtpMapping.startRtpMapping(builder);
        RtpMapping.addCodecs(builder, codecsOffset);
        RtpMapping.addEncodings(builder, encodingsOffset);
        return RtpMapping.endRtpMapping(builder);
    }
    unpack() {
        return new RtpMappingT(this.bb.createObjList(this.codecs.bind(this), this.codecsLength()), this.bb.createObjList(this.encodings.bind(this), this.encodingsLength()));
    }
    unpackTo(_o) {
        _o.codecs = this.bb.createObjList(this.codecs.bind(this), this.codecsLength());
        _o.encodings = this.bb.createObjList(this.encodings.bind(this), this.encodingsLength());
    }
}
exports.RtpMapping = RtpMapping;
class RtpMappingT {
    codecs;
    encodings;
    constructor(codecs = [], encodings = []) {
        this.codecs = codecs;
        this.encodings = encodings;
    }
    pack(builder) {
        const codecs = RtpMapping.createCodecsVector(builder, builder.createObjectOffsetList(this.codecs));
        const encodings = RtpMapping.createEncodingsVector(builder, builder.createObjectOffsetList(this.encodings));
        return RtpMapping.createRtpMapping(builder, codecs, encodings);
    }
}
exports.RtpMappingT = RtpMappingT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-parameters.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-parameters.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpParametersT = exports.RtpParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const rtcp_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtcp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtcp-parameters.js");
const rtp_codec_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-codec-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-codec-parameters.js");
const rtp_encoding_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-encoding-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-encoding-parameters.js");
const rtp_header_extension_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-header-extension-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-header-extension-parameters.js");
class RtpParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpParameters(bb, obj) {
        return (obj || new RtpParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    codecs(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new rtp_codec_parameters_1.RtpCodecParameters()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    codecsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    headerExtensions(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new rtp_header_extension_parameters_1.RtpHeaderExtensionParameters()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    headerExtensionsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    encodings(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new rtp_encoding_parameters_1.RtpEncodingParameters()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    encodingsLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    rtcp(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new rtcp_parameters_1.RtcpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRtpParameters(builder) {
        builder.startObject(5);
    }
    static addMid(builder, midOffset) {
        builder.addFieldOffset(0, midOffset, 0);
    }
    static addCodecs(builder, codecsOffset) {
        builder.addFieldOffset(1, codecsOffset, 0);
    }
    static createCodecsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCodecsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addHeaderExtensions(builder, headerExtensionsOffset) {
        builder.addFieldOffset(2, headerExtensionsOffset, 0);
    }
    static createHeaderExtensionsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startHeaderExtensionsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addEncodings(builder, encodingsOffset) {
        builder.addFieldOffset(3, encodingsOffset, 0);
    }
    static createEncodingsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startEncodingsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRtcp(builder, rtcpOffset) {
        builder.addFieldOffset(4, rtcpOffset, 0);
    }
    static endRtpParameters(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // codecs
        builder.requiredField(offset, 8); // header_extensions
        builder.requiredField(offset, 10); // encodings
        builder.requiredField(offset, 12); // rtcp
        return offset;
    }
    unpack() {
        return new RtpParametersT(this.mid(), this.bb.createObjList(this.codecs.bind(this), this.codecsLength()), this.bb.createObjList(this.headerExtensions.bind(this), this.headerExtensionsLength()), this.bb.createObjList(this.encodings.bind(this), this.encodingsLength()), (this.rtcp() !== null ? this.rtcp().unpack() : null));
    }
    unpackTo(_o) {
        _o.mid = this.mid();
        _o.codecs = this.bb.createObjList(this.codecs.bind(this), this.codecsLength());
        _o.headerExtensions = this.bb.createObjList(this.headerExtensions.bind(this), this.headerExtensionsLength());
        _o.encodings = this.bb.createObjList(this.encodings.bind(this), this.encodingsLength());
        _o.rtcp = (this.rtcp() !== null ? this.rtcp().unpack() : null);
    }
}
exports.RtpParameters = RtpParameters;
class RtpParametersT {
    mid;
    codecs;
    headerExtensions;
    encodings;
    rtcp;
    constructor(mid = null, codecs = [], headerExtensions = [], encodings = [], rtcp = null) {
        this.mid = mid;
        this.codecs = codecs;
        this.headerExtensions = headerExtensions;
        this.encodings = encodings;
        this.rtcp = rtcp;
    }
    pack(builder) {
        const mid = (this.mid !== null ? builder.createString(this.mid) : 0);
        const codecs = RtpParameters.createCodecsVector(builder, builder.createObjectOffsetList(this.codecs));
        const headerExtensions = RtpParameters.createHeaderExtensionsVector(builder, builder.createObjectOffsetList(this.headerExtensions));
        const encodings = RtpParameters.createEncodingsVector(builder, builder.createObjectOffsetList(this.encodings));
        const rtcp = (this.rtcp !== null ? this.rtcp.pack(builder) : 0);
        RtpParameters.startRtpParameters(builder);
        RtpParameters.addMid(builder, mid);
        RtpParameters.addCodecs(builder, codecs);
        RtpParameters.addHeaderExtensions(builder, headerExtensions);
        RtpParameters.addEncodings(builder, encodings);
        RtpParameters.addRtcp(builder, rtcp);
        return RtpParameters.endRtpParameters(builder);
    }
}
exports.RtpParametersT = RtpParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtx.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtx.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtxT = exports.Rtx = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Rtx {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtx(bb, obj) {
        return (obj || new Rtx()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtx(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Rtx()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startRtx(builder) {
        builder.startObject(1);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(0, ssrc, 0);
    }
    static endRtx(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRtx(builder, ssrc) {
        Rtx.startRtx(builder);
        Rtx.addSsrc(builder, ssrc);
        return Rtx.endRtx(builder);
    }
    unpack() {
        return new RtxT(this.ssrc());
    }
    unpackTo(_o) {
        _o.ssrc = this.ssrc();
    }
}
exports.Rtx = Rtx;
class RtxT {
    ssrc;
    constructor(ssrc = 0) {
        this.ssrc = ssrc;
    }
    pack(builder) {
        return Rtx.createRtx(builder, this.ssrc);
    }
}
exports.RtxT = RtxT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/string.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/string.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringT = exports.String = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class String {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsString(bb, obj) {
        return (obj || new String()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsString(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new String()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startString(builder) {
        builder.startObject(1);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(0, valueOffset, 0);
    }
    static endString(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // value
        return offset;
    }
    static createString(builder, valueOffset) {
        String.startString(builder);
        String.addValue(builder, valueOffset);
        return String.endString(builder);
    }
    unpack() {
        return new StringT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
exports.String = String;
class StringT {
    value;
    constructor(value = null) {
        this.value = value;
    }
    pack(builder) {
        const value = (this.value !== null ? builder.createString(this.value) : 0);
        return String.createString(builder, value);
    }
}
exports.StringT = StringT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/type.js":
/*!************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/type.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Type = void 0;
var Type;
(function (Type) {
    Type[Type["SIMPLE"] = 0] = "SIMPLE";
    Type[Type["SIMULCAST"] = 1] = "SIMULCAST";
    Type[Type["SVC"] = 2] = "SVC";
    Type[Type["PIPE"] = 3] = "PIPE";
})(Type || (exports.Type = Type = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/value.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/value.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToValue = exports.unionToValue = exports.Value = void 0;
const boolean_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/boolean */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/boolean.js");
const double_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/double */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/double.js");
const integer32_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/integer32 */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/integer32.js");
const integer32_array_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/integer32-array */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/integer32-array.js");
const string_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/string */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/string.js");
var Value;
(function (Value) {
    Value[Value["NONE"] = 0] = "NONE";
    Value[Value["Boolean"] = 1] = "Boolean";
    Value[Value["Integer32"] = 2] = "Integer32";
    Value[Value["Double"] = 3] = "Double";
    Value[Value["String"] = 4] = "String";
    Value[Value["Integer32Array"] = 5] = "Integer32Array";
})(Value || (exports.Value = Value = {}));
function unionToValue(type, accessor) {
    switch (Value[type]) {
        case 'NONE': return null;
        case 'Boolean': return accessor(new boolean_1.Boolean());
        case 'Integer32': return accessor(new integer32_1.Integer32());
        case 'Double': return accessor(new double_1.Double());
        case 'String': return accessor(new string_1.String());
        case 'Integer32Array': return accessor(new integer32_array_1.Integer32Array());
        default: return null;
    }
}
exports.unionToValue = unionToValue;
function unionListToValue(type, accessor, index) {
    switch (Value[type]) {
        case 'NONE': return null;
        case 'Boolean': return accessor(index, new boolean_1.Boolean());
        case 'Integer32': return accessor(index, new integer32_1.Integer32());
        case 'Double': return accessor(index, new double_1.Double());
        case 'String': return accessor(index, new string_1.String());
        case 'Integer32Array': return accessor(index, new integer32_array_1.Integer32Array());
        default: return null;
    }
}
exports.unionListToValue = unionListToValue;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream.js":
/*!***************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatsData = exports.StatsT = exports.Stats = exports.SendStatsT = exports.SendStats = exports.RecvStatsT = exports.RecvStats = exports.ParamsT = exports.Params = exports.DumpT = exports.Dump = exports.BitrateByLayerT = exports.BitrateByLayer = exports.BaseStatsT = exports.BaseStats = void 0;
var base_stats_1 = __webpack_require__(/*! ./rtp-stream/base-stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/base-stats.js");
Object.defineProperty(exports, "BaseStats", ({ enumerable: true, get: function () { return base_stats_1.BaseStats; } }));
Object.defineProperty(exports, "BaseStatsT", ({ enumerable: true, get: function () { return base_stats_1.BaseStatsT; } }));
var bitrate_by_layer_1 = __webpack_require__(/*! ./rtp-stream/bitrate-by-layer */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/bitrate-by-layer.js");
Object.defineProperty(exports, "BitrateByLayer", ({ enumerable: true, get: function () { return bitrate_by_layer_1.BitrateByLayer; } }));
Object.defineProperty(exports, "BitrateByLayerT", ({ enumerable: true, get: function () { return bitrate_by_layer_1.BitrateByLayerT; } }));
var dump_1 = __webpack_require__(/*! ./rtp-stream/dump */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/dump.js");
Object.defineProperty(exports, "Dump", ({ enumerable: true, get: function () { return dump_1.Dump; } }));
Object.defineProperty(exports, "DumpT", ({ enumerable: true, get: function () { return dump_1.DumpT; } }));
var params_1 = __webpack_require__(/*! ./rtp-stream/params */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/params.js");
Object.defineProperty(exports, "Params", ({ enumerable: true, get: function () { return params_1.Params; } }));
Object.defineProperty(exports, "ParamsT", ({ enumerable: true, get: function () { return params_1.ParamsT; } }));
var recv_stats_1 = __webpack_require__(/*! ./rtp-stream/recv-stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/recv-stats.js");
Object.defineProperty(exports, "RecvStats", ({ enumerable: true, get: function () { return recv_stats_1.RecvStats; } }));
Object.defineProperty(exports, "RecvStatsT", ({ enumerable: true, get: function () { return recv_stats_1.RecvStatsT; } }));
var send_stats_1 = __webpack_require__(/*! ./rtp-stream/send-stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/send-stats.js");
Object.defineProperty(exports, "SendStats", ({ enumerable: true, get: function () { return send_stats_1.SendStats; } }));
Object.defineProperty(exports, "SendStatsT", ({ enumerable: true, get: function () { return send_stats_1.SendStatsT; } }));
var stats_1 = __webpack_require__(/*! ./rtp-stream/stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats.js");
Object.defineProperty(exports, "Stats", ({ enumerable: true, get: function () { return stats_1.Stats; } }));
Object.defineProperty(exports, "StatsT", ({ enumerable: true, get: function () { return stats_1.StatsT; } }));
var stats_data_1 = __webpack_require__(/*! ./rtp-stream/stats-data */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats-data.js");
Object.defineProperty(exports, "StatsData", ({ enumerable: true, get: function () { return stats_data_1.StatsData; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/base-stats.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream/base-stats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseStatsT = exports.BaseStats = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const media_kind_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/media-kind */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js");
class BaseStats {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBaseStats(bb, obj) {
        return (obj || new BaseStats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBaseStats(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BaseStats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    timestamp() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    kind() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : media_kind_1.MediaKind.AUDIO;
    }
    mimeType(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    packetsLost() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    fractionLost() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    packetsDiscarded() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    packetsRetransmitted() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    packetsRepaired() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    nackCount() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    nackPacketCount() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    pliCount() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    firCount() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    score() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    rid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    rtxSsrc() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    rtxPacketsDiscarded() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    roundTripTime() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    static startBaseStats(builder) {
        builder.startObject(18);
    }
    static addTimestamp(builder, timestamp) {
        builder.addFieldInt64(0, timestamp, BigInt('0'));
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(1, ssrc, 0);
    }
    static addKind(builder, kind) {
        builder.addFieldInt8(2, kind, media_kind_1.MediaKind.AUDIO);
    }
    static addMimeType(builder, mimeTypeOffset) {
        builder.addFieldOffset(3, mimeTypeOffset, 0);
    }
    static addPacketsLost(builder, packetsLost) {
        builder.addFieldInt64(4, packetsLost, BigInt('0'));
    }
    static addFractionLost(builder, fractionLost) {
        builder.addFieldInt8(5, fractionLost, 0);
    }
    static addPacketsDiscarded(builder, packetsDiscarded) {
        builder.addFieldInt64(6, packetsDiscarded, BigInt('0'));
    }
    static addPacketsRetransmitted(builder, packetsRetransmitted) {
        builder.addFieldInt64(7, packetsRetransmitted, BigInt('0'));
    }
    static addPacketsRepaired(builder, packetsRepaired) {
        builder.addFieldInt64(8, packetsRepaired, BigInt('0'));
    }
    static addNackCount(builder, nackCount) {
        builder.addFieldInt64(9, nackCount, BigInt('0'));
    }
    static addNackPacketCount(builder, nackPacketCount) {
        builder.addFieldInt64(10, nackPacketCount, BigInt('0'));
    }
    static addPliCount(builder, pliCount) {
        builder.addFieldInt64(11, pliCount, BigInt('0'));
    }
    static addFirCount(builder, firCount) {
        builder.addFieldInt64(12, firCount, BigInt('0'));
    }
    static addScore(builder, score) {
        builder.addFieldInt8(13, score, 0);
    }
    static addRid(builder, ridOffset) {
        builder.addFieldOffset(14, ridOffset, 0);
    }
    static addRtxSsrc(builder, rtxSsrc) {
        builder.addFieldInt32(15, rtxSsrc, 0);
    }
    static addRtxPacketsDiscarded(builder, rtxPacketsDiscarded) {
        builder.addFieldInt64(16, rtxPacketsDiscarded, BigInt('0'));
    }
    static addRoundTripTime(builder, roundTripTime) {
        builder.addFieldFloat32(17, roundTripTime, 0.0);
    }
    static endBaseStats(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 10); // mime_type
        return offset;
    }
    static createBaseStats(builder, timestamp, ssrc, kind, mimeTypeOffset, packetsLost, fractionLost, packetsDiscarded, packetsRetransmitted, packetsRepaired, nackCount, nackPacketCount, pliCount, firCount, score, ridOffset, rtxSsrc, rtxPacketsDiscarded, roundTripTime) {
        BaseStats.startBaseStats(builder);
        BaseStats.addTimestamp(builder, timestamp);
        BaseStats.addSsrc(builder, ssrc);
        BaseStats.addKind(builder, kind);
        BaseStats.addMimeType(builder, mimeTypeOffset);
        BaseStats.addPacketsLost(builder, packetsLost);
        BaseStats.addFractionLost(builder, fractionLost);
        BaseStats.addPacketsDiscarded(builder, packetsDiscarded);
        BaseStats.addPacketsRetransmitted(builder, packetsRetransmitted);
        BaseStats.addPacketsRepaired(builder, packetsRepaired);
        BaseStats.addNackCount(builder, nackCount);
        BaseStats.addNackPacketCount(builder, nackPacketCount);
        BaseStats.addPliCount(builder, pliCount);
        BaseStats.addFirCount(builder, firCount);
        BaseStats.addScore(builder, score);
        BaseStats.addRid(builder, ridOffset);
        if (rtxSsrc !== null)
            BaseStats.addRtxSsrc(builder, rtxSsrc);
        BaseStats.addRtxPacketsDiscarded(builder, rtxPacketsDiscarded);
        BaseStats.addRoundTripTime(builder, roundTripTime);
        return BaseStats.endBaseStats(builder);
    }
    unpack() {
        return new BaseStatsT(this.timestamp(), this.ssrc(), this.kind(), this.mimeType(), this.packetsLost(), this.fractionLost(), this.packetsDiscarded(), this.packetsRetransmitted(), this.packetsRepaired(), this.nackCount(), this.nackPacketCount(), this.pliCount(), this.firCount(), this.score(), this.rid(), this.rtxSsrc(), this.rtxPacketsDiscarded(), this.roundTripTime());
    }
    unpackTo(_o) {
        _o.timestamp = this.timestamp();
        _o.ssrc = this.ssrc();
        _o.kind = this.kind();
        _o.mimeType = this.mimeType();
        _o.packetsLost = this.packetsLost();
        _o.fractionLost = this.fractionLost();
        _o.packetsDiscarded = this.packetsDiscarded();
        _o.packetsRetransmitted = this.packetsRetransmitted();
        _o.packetsRepaired = this.packetsRepaired();
        _o.nackCount = this.nackCount();
        _o.nackPacketCount = this.nackPacketCount();
        _o.pliCount = this.pliCount();
        _o.firCount = this.firCount();
        _o.score = this.score();
        _o.rid = this.rid();
        _o.rtxSsrc = this.rtxSsrc();
        _o.rtxPacketsDiscarded = this.rtxPacketsDiscarded();
        _o.roundTripTime = this.roundTripTime();
    }
}
exports.BaseStats = BaseStats;
class BaseStatsT {
    timestamp;
    ssrc;
    kind;
    mimeType;
    packetsLost;
    fractionLost;
    packetsDiscarded;
    packetsRetransmitted;
    packetsRepaired;
    nackCount;
    nackPacketCount;
    pliCount;
    firCount;
    score;
    rid;
    rtxSsrc;
    rtxPacketsDiscarded;
    roundTripTime;
    constructor(timestamp = BigInt('0'), ssrc = 0, kind = media_kind_1.MediaKind.AUDIO, mimeType = null, packetsLost = BigInt('0'), fractionLost = 0, packetsDiscarded = BigInt('0'), packetsRetransmitted = BigInt('0'), packetsRepaired = BigInt('0'), nackCount = BigInt('0'), nackPacketCount = BigInt('0'), pliCount = BigInt('0'), firCount = BigInt('0'), score = 0, rid = null, rtxSsrc = null, rtxPacketsDiscarded = BigInt('0'), roundTripTime = 0.0) {
        this.timestamp = timestamp;
        this.ssrc = ssrc;
        this.kind = kind;
        this.mimeType = mimeType;
        this.packetsLost = packetsLost;
        this.fractionLost = fractionLost;
        this.packetsDiscarded = packetsDiscarded;
        this.packetsRetransmitted = packetsRetransmitted;
        this.packetsRepaired = packetsRepaired;
        this.nackCount = nackCount;
        this.nackPacketCount = nackPacketCount;
        this.pliCount = pliCount;
        this.firCount = firCount;
        this.score = score;
        this.rid = rid;
        this.rtxSsrc = rtxSsrc;
        this.rtxPacketsDiscarded = rtxPacketsDiscarded;
        this.roundTripTime = roundTripTime;
    }
    pack(builder) {
        const mimeType = (this.mimeType !== null ? builder.createString(this.mimeType) : 0);
        const rid = (this.rid !== null ? builder.createString(this.rid) : 0);
        return BaseStats.createBaseStats(builder, this.timestamp, this.ssrc, this.kind, mimeType, this.packetsLost, this.fractionLost, this.packetsDiscarded, this.packetsRetransmitted, this.packetsRepaired, this.nackCount, this.nackPacketCount, this.pliCount, this.firCount, this.score, rid, this.rtxSsrc, this.rtxPacketsDiscarded, this.roundTripTime);
    }
}
exports.BaseStatsT = BaseStatsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/bitrate-by-layer.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream/bitrate-by-layer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BitrateByLayerT = exports.BitrateByLayer = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class BitrateByLayer {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBitrateByLayer(bb, obj) {
        return (obj || new BitrateByLayer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBitrateByLayer(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BitrateByLayer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    layer(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    bitrate() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startBitrateByLayer(builder) {
        builder.startObject(2);
    }
    static addLayer(builder, layerOffset) {
        builder.addFieldOffset(0, layerOffset, 0);
    }
    static addBitrate(builder, bitrate) {
        builder.addFieldInt32(1, bitrate, 0);
    }
    static endBitrateByLayer(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // layer
        return offset;
    }
    static createBitrateByLayer(builder, layerOffset, bitrate) {
        BitrateByLayer.startBitrateByLayer(builder);
        BitrateByLayer.addLayer(builder, layerOffset);
        BitrateByLayer.addBitrate(builder, bitrate);
        return BitrateByLayer.endBitrateByLayer(builder);
    }
    unpack() {
        return new BitrateByLayerT(this.layer(), this.bitrate());
    }
    unpackTo(_o) {
        _o.layer = this.layer();
        _o.bitrate = this.bitrate();
    }
}
exports.BitrateByLayer = BitrateByLayer;
class BitrateByLayerT {
    layer;
    bitrate;
    constructor(layer = null, bitrate = 0) {
        this.layer = layer;
        this.bitrate = bitrate;
    }
    pack(builder) {
        const layer = (this.layer !== null ? builder.createString(this.layer) : 0);
        return BitrateByLayer.createBitrateByLayer(builder, layer, this.bitrate);
    }
}
exports.BitrateByLayerT = BitrateByLayerT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/dump.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream/dump.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpT = exports.Dump = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const params_1 = __webpack_require__(/*! ../../fbs/rtp-stream/params */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/params.js");
const rtx_dump_1 = __webpack_require__(/*! ../../fbs/rtx-stream/rtx-dump */ "../../node_modules/mediasoup/node/lib/fbs/rtx-stream/rtx-dump.js");
class Dump {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDump(bb, obj) {
        return (obj || new Dump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDump(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Dump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    params(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new params_1.Params()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    score() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    rtxStream(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new rtx_dump_1.RtxDump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startDump(builder) {
        builder.startObject(3);
    }
    static addParams(builder, paramsOffset) {
        builder.addFieldOffset(0, paramsOffset, 0);
    }
    static addScore(builder, score) {
        builder.addFieldInt8(1, score, 0);
    }
    static addRtxStream(builder, rtxStreamOffset) {
        builder.addFieldOffset(2, rtxStreamOffset, 0);
    }
    static endDump(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // params
        return offset;
    }
    unpack() {
        return new DumpT((this.params() !== null ? this.params().unpack() : null), this.score(), (this.rtxStream() !== null ? this.rtxStream().unpack() : null));
    }
    unpackTo(_o) {
        _o.params = (this.params() !== null ? this.params().unpack() : null);
        _o.score = this.score();
        _o.rtxStream = (this.rtxStream() !== null ? this.rtxStream().unpack() : null);
    }
}
exports.Dump = Dump;
class DumpT {
    params;
    score;
    rtxStream;
    constructor(params = null, score = 0, rtxStream = null) {
        this.params = params;
        this.score = score;
        this.rtxStream = rtxStream;
    }
    pack(builder) {
        const params = (this.params !== null ? this.params.pack(builder) : 0);
        const rtxStream = (this.rtxStream !== null ? this.rtxStream.pack(builder) : 0);
        Dump.startDump(builder);
        Dump.addParams(builder, params);
        Dump.addScore(builder, this.score);
        Dump.addRtxStream(builder, rtxStream);
        return Dump.endDump(builder);
    }
}
exports.DumpT = DumpT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/params.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream/params.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParamsT = exports.Params = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Params {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsParams(bb, obj) {
        return (obj || new Params()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsParams(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Params()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    encodingIdx() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    payloadType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    mimeType(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    clockRate() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    rid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    cname(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    rtxSsrc() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    rtxPayloadType() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    useNack() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    usePli() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    useFir() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    useInBandFec() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    useDtx() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    spatialLayers() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    temporalLayers() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startParams(builder) {
        builder.startObject(16);
    }
    static addEncodingIdx(builder, encodingIdx) {
        builder.addFieldInt32(0, encodingIdx, 0);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(1, ssrc, 0);
    }
    static addPayloadType(builder, payloadType) {
        builder.addFieldInt8(2, payloadType, 0);
    }
    static addMimeType(builder, mimeTypeOffset) {
        builder.addFieldOffset(3, mimeTypeOffset, 0);
    }
    static addClockRate(builder, clockRate) {
        builder.addFieldInt32(4, clockRate, 0);
    }
    static addRid(builder, ridOffset) {
        builder.addFieldOffset(5, ridOffset, 0);
    }
    static addCname(builder, cnameOffset) {
        builder.addFieldOffset(6, cnameOffset, 0);
    }
    static addRtxSsrc(builder, rtxSsrc) {
        builder.addFieldInt32(7, rtxSsrc, 0);
    }
    static addRtxPayloadType(builder, rtxPayloadType) {
        builder.addFieldInt8(8, rtxPayloadType, 0);
    }
    static addUseNack(builder, useNack) {
        builder.addFieldInt8(9, +useNack, +false);
    }
    static addUsePli(builder, usePli) {
        builder.addFieldInt8(10, +usePli, +false);
    }
    static addUseFir(builder, useFir) {
        builder.addFieldInt8(11, +useFir, +false);
    }
    static addUseInBandFec(builder, useInBandFec) {
        builder.addFieldInt8(12, +useInBandFec, +false);
    }
    static addUseDtx(builder, useDtx) {
        builder.addFieldInt8(13, +useDtx, +false);
    }
    static addSpatialLayers(builder, spatialLayers) {
        builder.addFieldInt8(14, spatialLayers, 0);
    }
    static addTemporalLayers(builder, temporalLayers) {
        builder.addFieldInt8(15, temporalLayers, 0);
    }
    static endParams(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 10); // mime_type
        builder.requiredField(offset, 16); // cname
        return offset;
    }
    static createParams(builder, encodingIdx, ssrc, payloadType, mimeTypeOffset, clockRate, ridOffset, cnameOffset, rtxSsrc, rtxPayloadType, useNack, usePli, useFir, useInBandFec, useDtx, spatialLayers, temporalLayers) {
        Params.startParams(builder);
        Params.addEncodingIdx(builder, encodingIdx);
        Params.addSsrc(builder, ssrc);
        Params.addPayloadType(builder, payloadType);
        Params.addMimeType(builder, mimeTypeOffset);
        Params.addClockRate(builder, clockRate);
        Params.addRid(builder, ridOffset);
        Params.addCname(builder, cnameOffset);
        if (rtxSsrc !== null)
            Params.addRtxSsrc(builder, rtxSsrc);
        if (rtxPayloadType !== null)
            Params.addRtxPayloadType(builder, rtxPayloadType);
        Params.addUseNack(builder, useNack);
        Params.addUsePli(builder, usePli);
        Params.addUseFir(builder, useFir);
        Params.addUseInBandFec(builder, useInBandFec);
        Params.addUseDtx(builder, useDtx);
        Params.addSpatialLayers(builder, spatialLayers);
        Params.addTemporalLayers(builder, temporalLayers);
        return Params.endParams(builder);
    }
    unpack() {
        return new ParamsT(this.encodingIdx(), this.ssrc(), this.payloadType(), this.mimeType(), this.clockRate(), this.rid(), this.cname(), this.rtxSsrc(), this.rtxPayloadType(), this.useNack(), this.usePli(), this.useFir(), this.useInBandFec(), this.useDtx(), this.spatialLayers(), this.temporalLayers());
    }
    unpackTo(_o) {
        _o.encodingIdx = this.encodingIdx();
        _o.ssrc = this.ssrc();
        _o.payloadType = this.payloadType();
        _o.mimeType = this.mimeType();
        _o.clockRate = this.clockRate();
        _o.rid = this.rid();
        _o.cname = this.cname();
        _o.rtxSsrc = this.rtxSsrc();
        _o.rtxPayloadType = this.rtxPayloadType();
        _o.useNack = this.useNack();
        _o.usePli = this.usePli();
        _o.useFir = this.useFir();
        _o.useInBandFec = this.useInBandFec();
        _o.useDtx = this.useDtx();
        _o.spatialLayers = this.spatialLayers();
        _o.temporalLayers = this.temporalLayers();
    }
}
exports.Params = Params;
class ParamsT {
    encodingIdx;
    ssrc;
    payloadType;
    mimeType;
    clockRate;
    rid;
    cname;
    rtxSsrc;
    rtxPayloadType;
    useNack;
    usePli;
    useFir;
    useInBandFec;
    useDtx;
    spatialLayers;
    temporalLayers;
    constructor(encodingIdx = 0, ssrc = 0, payloadType = 0, mimeType = null, clockRate = 0, rid = null, cname = null, rtxSsrc = null, rtxPayloadType = null, useNack = false, usePli = false, useFir = false, useInBandFec = false, useDtx = false, spatialLayers = 0, temporalLayers = 0) {
        this.encodingIdx = encodingIdx;
        this.ssrc = ssrc;
        this.payloadType = payloadType;
        this.mimeType = mimeType;
        this.clockRate = clockRate;
        this.rid = rid;
        this.cname = cname;
        this.rtxSsrc = rtxSsrc;
        this.rtxPayloadType = rtxPayloadType;
        this.useNack = useNack;
        this.usePli = usePli;
        this.useFir = useFir;
        this.useInBandFec = useInBandFec;
        this.useDtx = useDtx;
        this.spatialLayers = spatialLayers;
        this.temporalLayers = temporalLayers;
    }
    pack(builder) {
        const mimeType = (this.mimeType !== null ? builder.createString(this.mimeType) : 0);
        const rid = (this.rid !== null ? builder.createString(this.rid) : 0);
        const cname = (this.cname !== null ? builder.createString(this.cname) : 0);
        return Params.createParams(builder, this.encodingIdx, this.ssrc, this.payloadType, mimeType, this.clockRate, rid, cname, this.rtxSsrc, this.rtxPayloadType, this.useNack, this.usePli, this.useFir, this.useInBandFec, this.useDtx, this.spatialLayers, this.temporalLayers);
    }
}
exports.ParamsT = ParamsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/recv-stats.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream/recv-stats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecvStatsT = exports.RecvStats = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const bitrate_by_layer_1 = __webpack_require__(/*! ../../fbs/rtp-stream/bitrate-by-layer */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/bitrate-by-layer.js");
const stats_1 = __webpack_require__(/*! ../../fbs/rtp-stream/stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats.js");
class RecvStats {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRecvStats(bb, obj) {
        return (obj || new RecvStats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecvStats(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RecvStats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new stats_1.Stats()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    jitter() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    packetCount() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    byteCount() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    bitrate() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    bitrateByLayer(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new bitrate_by_layer_1.BitrateByLayer()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    bitrateByLayerLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRecvStats(builder) {
        builder.startObject(6);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addJitter(builder, jitter) {
        builder.addFieldInt32(1, jitter, 0);
    }
    static addPacketCount(builder, packetCount) {
        builder.addFieldInt64(2, packetCount, BigInt('0'));
    }
    static addByteCount(builder, byteCount) {
        builder.addFieldInt64(3, byteCount, BigInt('0'));
    }
    static addBitrate(builder, bitrate) {
        builder.addFieldInt32(4, bitrate, 0);
    }
    static addBitrateByLayer(builder, bitrateByLayerOffset) {
        builder.addFieldOffset(5, bitrateByLayerOffset, 0);
    }
    static createBitrateByLayerVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startBitrateByLayerVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRecvStats(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 14); // bitrate_by_layer
        return offset;
    }
    static createRecvStats(builder, baseOffset, jitter, packetCount, byteCount, bitrate, bitrateByLayerOffset) {
        RecvStats.startRecvStats(builder);
        RecvStats.addBase(builder, baseOffset);
        RecvStats.addJitter(builder, jitter);
        RecvStats.addPacketCount(builder, packetCount);
        RecvStats.addByteCount(builder, byteCount);
        RecvStats.addBitrate(builder, bitrate);
        RecvStats.addBitrateByLayer(builder, bitrateByLayerOffset);
        return RecvStats.endRecvStats(builder);
    }
    unpack() {
        return new RecvStatsT((this.base() !== null ? this.base().unpack() : null), this.jitter(), this.packetCount(), this.byteCount(), this.bitrate(), this.bb.createObjList(this.bitrateByLayer.bind(this), this.bitrateByLayerLength()));
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.jitter = this.jitter();
        _o.packetCount = this.packetCount();
        _o.byteCount = this.byteCount();
        _o.bitrate = this.bitrate();
        _o.bitrateByLayer = this.bb.createObjList(this.bitrateByLayer.bind(this), this.bitrateByLayerLength());
    }
}
exports.RecvStats = RecvStats;
class RecvStatsT {
    base;
    jitter;
    packetCount;
    byteCount;
    bitrate;
    bitrateByLayer;
    constructor(base = null, jitter = 0, packetCount = BigInt('0'), byteCount = BigInt('0'), bitrate = 0, bitrateByLayer = []) {
        this.base = base;
        this.jitter = jitter;
        this.packetCount = packetCount;
        this.byteCount = byteCount;
        this.bitrate = bitrate;
        this.bitrateByLayer = bitrateByLayer;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const bitrateByLayer = RecvStats.createBitrateByLayerVector(builder, builder.createObjectOffsetList(this.bitrateByLayer));
        return RecvStats.createRecvStats(builder, base, this.jitter, this.packetCount, this.byteCount, this.bitrate, bitrateByLayer);
    }
}
exports.RecvStatsT = RecvStatsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/send-stats.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream/send-stats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendStatsT = exports.SendStats = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const stats_1 = __webpack_require__(/*! ../../fbs/rtp-stream/stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats.js");
class SendStats {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSendStats(bb, obj) {
        return (obj || new SendStats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSendStats(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SendStats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new stats_1.Stats()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    packetCount() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    byteCount() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    bitrate() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startSendStats(builder) {
        builder.startObject(4);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addPacketCount(builder, packetCount) {
        builder.addFieldInt64(1, packetCount, BigInt('0'));
    }
    static addByteCount(builder, byteCount) {
        builder.addFieldInt64(2, byteCount, BigInt('0'));
    }
    static addBitrate(builder, bitrate) {
        builder.addFieldInt32(3, bitrate, 0);
    }
    static endSendStats(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        return offset;
    }
    static createSendStats(builder, baseOffset, packetCount, byteCount, bitrate) {
        SendStats.startSendStats(builder);
        SendStats.addBase(builder, baseOffset);
        SendStats.addPacketCount(builder, packetCount);
        SendStats.addByteCount(builder, byteCount);
        SendStats.addBitrate(builder, bitrate);
        return SendStats.endSendStats(builder);
    }
    unpack() {
        return new SendStatsT((this.base() !== null ? this.base().unpack() : null), this.packetCount(), this.byteCount(), this.bitrate());
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.packetCount = this.packetCount();
        _o.byteCount = this.byteCount();
        _o.bitrate = this.bitrate();
    }
}
exports.SendStats = SendStats;
class SendStatsT {
    base;
    packetCount;
    byteCount;
    bitrate;
    constructor(base = null, packetCount = BigInt('0'), byteCount = BigInt('0'), bitrate = 0) {
        this.base = base;
        this.packetCount = packetCount;
        this.byteCount = byteCount;
        this.bitrate = bitrate;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        return SendStats.createSendStats(builder, base, this.packetCount, this.byteCount, this.bitrate);
    }
}
exports.SendStatsT = SendStatsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats-data.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats-data.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToStatsData = exports.unionToStatsData = exports.StatsData = void 0;
const base_stats_1 = __webpack_require__(/*! ../../fbs/rtp-stream/base-stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/base-stats.js");
const recv_stats_1 = __webpack_require__(/*! ../../fbs/rtp-stream/recv-stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/recv-stats.js");
const send_stats_1 = __webpack_require__(/*! ../../fbs/rtp-stream/send-stats */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/send-stats.js");
var StatsData;
(function (StatsData) {
    StatsData[StatsData["NONE"] = 0] = "NONE";
    StatsData[StatsData["BaseStats"] = 1] = "BaseStats";
    StatsData[StatsData["RecvStats"] = 2] = "RecvStats";
    StatsData[StatsData["SendStats"] = 3] = "SendStats";
})(StatsData || (exports.StatsData = StatsData = {}));
function unionToStatsData(type, accessor) {
    switch (StatsData[type]) {
        case 'NONE': return null;
        case 'BaseStats': return accessor(new base_stats_1.BaseStats());
        case 'RecvStats': return accessor(new recv_stats_1.RecvStats());
        case 'SendStats': return accessor(new send_stats_1.SendStats());
        default: return null;
    }
}
exports.unionToStatsData = unionToStatsData;
function unionListToStatsData(type, accessor, index) {
    switch (StatsData[type]) {
        case 'NONE': return null;
        case 'BaseStats': return accessor(index, new base_stats_1.BaseStats());
        case 'RecvStats': return accessor(index, new recv_stats_1.RecvStats());
        case 'SendStats': return accessor(index, new send_stats_1.SendStats());
        default: return null;
    }
}
exports.unionListToStatsData = unionListToStatsData;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatsT = exports.Stats = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const stats_data_1 = __webpack_require__(/*! ../../fbs/rtp-stream/stats-data */ "../../node_modules/mediasoup/node/lib/fbs/rtp-stream/stats-data.js");
class Stats {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStats(bb, obj) {
        return (obj || new Stats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStats(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Stats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dataType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : stats_data_1.StatsData.NONE;
    }
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startStats(builder) {
        builder.startObject(2);
    }
    static addDataType(builder, dataType) {
        builder.addFieldInt8(0, dataType, stats_data_1.StatsData.NONE);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static endStats(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // data
        return offset;
    }
    static createStats(builder, dataType, dataOffset) {
        Stats.startStats(builder);
        Stats.addDataType(builder, dataType);
        Stats.addData(builder, dataOffset);
        return Stats.endStats(builder);
    }
    unpack() {
        return new StatsT(this.dataType(), (() => {
            const temp = (0, stats_data_1.unionToStatsData)(this.dataType(), this.data.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.dataType = this.dataType();
        _o.data = (() => {
            const temp = (0, stats_data_1.unionToStatsData)(this.dataType(), this.data.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
exports.Stats = Stats;
class StatsT {
    dataType;
    data;
    constructor(dataType = stats_data_1.StatsData.NONE, data = null) {
        this.dataType = dataType;
        this.data = data;
    }
    pack(builder) {
        const data = builder.createObjectOffset(this.data);
        return Stats.createStats(builder, this.dataType, data);
    }
}
exports.StatsT = StatsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtx-stream/params.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtx-stream/params.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParamsT = exports.Params = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Params {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsParams(bb, obj) {
        return (obj || new Params()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsParams(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Params()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrc() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    payloadType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    mimeType(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    clockRate() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    rrid(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    cname(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startParams(builder) {
        builder.startObject(6);
    }
    static addSsrc(builder, ssrc) {
        builder.addFieldInt32(0, ssrc, 0);
    }
    static addPayloadType(builder, payloadType) {
        builder.addFieldInt8(1, payloadType, 0);
    }
    static addMimeType(builder, mimeTypeOffset) {
        builder.addFieldOffset(2, mimeTypeOffset, 0);
    }
    static addClockRate(builder, clockRate) {
        builder.addFieldInt32(3, clockRate, 0);
    }
    static addRrid(builder, rridOffset) {
        builder.addFieldOffset(4, rridOffset, 0);
    }
    static addCname(builder, cnameOffset) {
        builder.addFieldOffset(5, cnameOffset, 0);
    }
    static endParams(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 8); // mime_type
        builder.requiredField(offset, 14); // cname
        return offset;
    }
    static createParams(builder, ssrc, payloadType, mimeTypeOffset, clockRate, rridOffset, cnameOffset) {
        Params.startParams(builder);
        Params.addSsrc(builder, ssrc);
        Params.addPayloadType(builder, payloadType);
        Params.addMimeType(builder, mimeTypeOffset);
        Params.addClockRate(builder, clockRate);
        Params.addRrid(builder, rridOffset);
        Params.addCname(builder, cnameOffset);
        return Params.endParams(builder);
    }
    unpack() {
        return new ParamsT(this.ssrc(), this.payloadType(), this.mimeType(), this.clockRate(), this.rrid(), this.cname());
    }
    unpackTo(_o) {
        _o.ssrc = this.ssrc();
        _o.payloadType = this.payloadType();
        _o.mimeType = this.mimeType();
        _o.clockRate = this.clockRate();
        _o.rrid = this.rrid();
        _o.cname = this.cname();
    }
}
exports.Params = Params;
class ParamsT {
    ssrc;
    payloadType;
    mimeType;
    clockRate;
    rrid;
    cname;
    constructor(ssrc = 0, payloadType = 0, mimeType = null, clockRate = 0, rrid = null, cname = null) {
        this.ssrc = ssrc;
        this.payloadType = payloadType;
        this.mimeType = mimeType;
        this.clockRate = clockRate;
        this.rrid = rrid;
        this.cname = cname;
    }
    pack(builder) {
        const mimeType = (this.mimeType !== null ? builder.createString(this.mimeType) : 0);
        const rrid = (this.rrid !== null ? builder.createString(this.rrid) : 0);
        const cname = (this.cname !== null ? builder.createString(this.cname) : 0);
        return Params.createParams(builder, this.ssrc, this.payloadType, mimeType, this.clockRate, rrid, cname);
    }
}
exports.ParamsT = ParamsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/rtx-stream/rtx-dump.js":
/*!************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/rtx-stream/rtx-dump.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtxDumpT = exports.RtxDump = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const params_1 = __webpack_require__(/*! ../../fbs/rtx-stream/params */ "../../node_modules/mediasoup/node/lib/fbs/rtx-stream/params.js");
class RtxDump {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtxDump(bb, obj) {
        return (obj || new RtxDump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtxDump(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtxDump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    params(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new params_1.Params()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRtxDump(builder) {
        builder.startObject(1);
    }
    static addParams(builder, paramsOffset) {
        builder.addFieldOffset(0, paramsOffset, 0);
    }
    static endRtxDump(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // params
        return offset;
    }
    static createRtxDump(builder, paramsOffset) {
        RtxDump.startRtxDump(builder);
        RtxDump.addParams(builder, paramsOffset);
        return RtxDump.endRtxDump(builder);
    }
    unpack() {
        return new RtxDumpT((this.params() !== null ? this.params().unpack() : null));
    }
    unpackTo(_o) {
        _o.params = (this.params() !== null ? this.params().unpack() : null);
    }
}
exports.RtxDump = RtxDump;
class RtxDumpT {
    params;
    constructor(params = null) {
        this.params = params;
    }
    pack(builder) {
        const params = (this.params !== null ? this.params.pack(builder) : 0);
        return RtxDump.createRtxDump(builder, params);
    }
}
exports.RtxDumpT = RtxDumpT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/sctp-association/sctp-state.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/sctp-association/sctp-state.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SctpState = void 0;
var SctpState;
(function (SctpState) {
    SctpState[SctpState["NEW"] = 0] = "NEW";
    SctpState[SctpState["CONNECTING"] = 1] = "CONNECTING";
    SctpState[SctpState["CONNECTED"] = 2] = "CONNECTED";
    SctpState[SctpState["FAILED"] = 3] = "FAILED";
    SctpState[SctpState["CLOSED"] = 4] = "CLOSED";
})(SctpState || (exports.SctpState = SctpState = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/sctp-parameters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SctpStreamParametersT = exports.SctpStreamParameters = exports.SctpParametersT = exports.SctpParameters = exports.NumSctpStreamsT = exports.NumSctpStreams = void 0;
var num_sctp_streams_1 = __webpack_require__(/*! ./sctp-parameters/num-sctp-streams */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/num-sctp-streams.js");
Object.defineProperty(exports, "NumSctpStreams", ({ enumerable: true, get: function () { return num_sctp_streams_1.NumSctpStreams; } }));
Object.defineProperty(exports, "NumSctpStreamsT", ({ enumerable: true, get: function () { return num_sctp_streams_1.NumSctpStreamsT; } }));
var sctp_parameters_1 = __webpack_require__(/*! ./sctp-parameters/sctp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-parameters.js");
Object.defineProperty(exports, "SctpParameters", ({ enumerable: true, get: function () { return sctp_parameters_1.SctpParameters; } }));
Object.defineProperty(exports, "SctpParametersT", ({ enumerable: true, get: function () { return sctp_parameters_1.SctpParametersT; } }));
var sctp_stream_parameters_1 = __webpack_require__(/*! ./sctp-parameters/sctp-stream-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-stream-parameters.js");
Object.defineProperty(exports, "SctpStreamParameters", ({ enumerable: true, get: function () { return sctp_stream_parameters_1.SctpStreamParameters; } }));
Object.defineProperty(exports, "SctpStreamParametersT", ({ enumerable: true, get: function () { return sctp_stream_parameters_1.SctpStreamParametersT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/num-sctp-streams.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/num-sctp-streams.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumSctpStreamsT = exports.NumSctpStreams = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class NumSctpStreams {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsNumSctpStreams(bb, obj) {
        return (obj || new NumSctpStreams()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNumSctpStreams(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new NumSctpStreams()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    os() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 1024;
    }
    mis() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 1024;
    }
    static startNumSctpStreams(builder) {
        builder.startObject(2);
    }
    static addOs(builder, os) {
        builder.addFieldInt16(0, os, 1024);
    }
    static addMis(builder, mis) {
        builder.addFieldInt16(1, mis, 1024);
    }
    static endNumSctpStreams(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createNumSctpStreams(builder, os, mis) {
        NumSctpStreams.startNumSctpStreams(builder);
        NumSctpStreams.addOs(builder, os);
        NumSctpStreams.addMis(builder, mis);
        return NumSctpStreams.endNumSctpStreams(builder);
    }
    unpack() {
        return new NumSctpStreamsT(this.os(), this.mis());
    }
    unpackTo(_o) {
        _o.os = this.os();
        _o.mis = this.mis();
    }
}
exports.NumSctpStreams = NumSctpStreams;
class NumSctpStreamsT {
    os;
    mis;
    constructor(os = 1024, mis = 1024) {
        this.os = os;
        this.mis = mis;
    }
    pack(builder) {
        return NumSctpStreams.createNumSctpStreams(builder, this.os, this.mis);
    }
}
exports.NumSctpStreamsT = NumSctpStreamsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-parameters.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-parameters.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SctpParametersT = exports.SctpParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SctpParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSctpParameters(bb, obj) {
        return (obj || new SctpParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSctpParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SctpParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    port() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 5000;
    }
    os() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    mis() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    maxMessageSize() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    sendBufferSize() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    sctpBufferedAmount() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    isDataChannel() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startSctpParameters(builder) {
        builder.startObject(7);
    }
    static addPort(builder, port) {
        builder.addFieldInt16(0, port, 5000);
    }
    static addOs(builder, os) {
        builder.addFieldInt16(1, os, 0);
    }
    static addMis(builder, mis) {
        builder.addFieldInt16(2, mis, 0);
    }
    static addMaxMessageSize(builder, maxMessageSize) {
        builder.addFieldInt32(3, maxMessageSize, 0);
    }
    static addSendBufferSize(builder, sendBufferSize) {
        builder.addFieldInt32(4, sendBufferSize, 0);
    }
    static addSctpBufferedAmount(builder, sctpBufferedAmount) {
        builder.addFieldInt32(5, sctpBufferedAmount, 0);
    }
    static addIsDataChannel(builder, isDataChannel) {
        builder.addFieldInt8(6, +isDataChannel, +false);
    }
    static endSctpParameters(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSctpParameters(builder, port, os, mis, maxMessageSize, sendBufferSize, sctpBufferedAmount, isDataChannel) {
        SctpParameters.startSctpParameters(builder);
        SctpParameters.addPort(builder, port);
        SctpParameters.addOs(builder, os);
        SctpParameters.addMis(builder, mis);
        SctpParameters.addMaxMessageSize(builder, maxMessageSize);
        SctpParameters.addSendBufferSize(builder, sendBufferSize);
        SctpParameters.addSctpBufferedAmount(builder, sctpBufferedAmount);
        SctpParameters.addIsDataChannel(builder, isDataChannel);
        return SctpParameters.endSctpParameters(builder);
    }
    unpack() {
        return new SctpParametersT(this.port(), this.os(), this.mis(), this.maxMessageSize(), this.sendBufferSize(), this.sctpBufferedAmount(), this.isDataChannel());
    }
    unpackTo(_o) {
        _o.port = this.port();
        _o.os = this.os();
        _o.mis = this.mis();
        _o.maxMessageSize = this.maxMessageSize();
        _o.sendBufferSize = this.sendBufferSize();
        _o.sctpBufferedAmount = this.sctpBufferedAmount();
        _o.isDataChannel = this.isDataChannel();
    }
}
exports.SctpParameters = SctpParameters;
class SctpParametersT {
    port;
    os;
    mis;
    maxMessageSize;
    sendBufferSize;
    sctpBufferedAmount;
    isDataChannel;
    constructor(port = 5000, os = 0, mis = 0, maxMessageSize = 0, sendBufferSize = 0, sctpBufferedAmount = 0, isDataChannel = false) {
        this.port = port;
        this.os = os;
        this.mis = mis;
        this.maxMessageSize = maxMessageSize;
        this.sendBufferSize = sendBufferSize;
        this.sctpBufferedAmount = sctpBufferedAmount;
        this.isDataChannel = isDataChannel;
    }
    pack(builder) {
        return SctpParameters.createSctpParameters(builder, this.port, this.os, this.mis, this.maxMessageSize, this.sendBufferSize, this.sctpBufferedAmount, this.isDataChannel);
    }
}
exports.SctpParametersT = SctpParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-stream-parameters.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-stream-parameters.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SctpStreamParametersT = exports.SctpStreamParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SctpStreamParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSctpStreamParameters(bb, obj) {
        return (obj || new SctpStreamParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSctpStreamParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SctpStreamParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    streamId() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    ordered() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : null;
    }
    maxPacketLifeTime() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : null;
    }
    maxRetransmits() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : null;
    }
    static startSctpStreamParameters(builder) {
        builder.startObject(4);
    }
    static addStreamId(builder, streamId) {
        builder.addFieldInt16(0, streamId, 0);
    }
    static addOrdered(builder, ordered) {
        builder.addFieldInt8(1, +ordered, 0);
    }
    static addMaxPacketLifeTime(builder, maxPacketLifeTime) {
        builder.addFieldInt16(2, maxPacketLifeTime, 0);
    }
    static addMaxRetransmits(builder, maxRetransmits) {
        builder.addFieldInt16(3, maxRetransmits, 0);
    }
    static endSctpStreamParameters(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSctpStreamParameters(builder, streamId, ordered, maxPacketLifeTime, maxRetransmits) {
        SctpStreamParameters.startSctpStreamParameters(builder);
        SctpStreamParameters.addStreamId(builder, streamId);
        if (ordered !== null)
            SctpStreamParameters.addOrdered(builder, ordered);
        if (maxPacketLifeTime !== null)
            SctpStreamParameters.addMaxPacketLifeTime(builder, maxPacketLifeTime);
        if (maxRetransmits !== null)
            SctpStreamParameters.addMaxRetransmits(builder, maxRetransmits);
        return SctpStreamParameters.endSctpStreamParameters(builder);
    }
    unpack() {
        return new SctpStreamParametersT(this.streamId(), this.ordered(), this.maxPacketLifeTime(), this.maxRetransmits());
    }
    unpackTo(_o) {
        _o.streamId = this.streamId();
        _o.ordered = this.ordered();
        _o.maxPacketLifeTime = this.maxPacketLifeTime();
        _o.maxRetransmits = this.maxRetransmits();
    }
}
exports.SctpStreamParameters = SctpStreamParameters;
class SctpStreamParametersT {
    streamId;
    ordered;
    maxPacketLifeTime;
    maxRetransmits;
    constructor(streamId = 0, ordered = null, maxPacketLifeTime = null, maxRetransmits = null) {
        this.streamId = streamId;
        this.ordered = ordered;
        this.maxPacketLifeTime = maxPacketLifeTime;
        this.maxRetransmits = maxRetransmits;
    }
    pack(builder) {
        return SctpStreamParameters.createSctpStreamParameters(builder, this.streamId, this.ordered, this.maxPacketLifeTime, this.maxRetransmits);
    }
}
exports.SctpStreamParametersT = SctpStreamParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/srtp-parameters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SrtpParametersT = exports.SrtpParameters = exports.SrtpCryptoSuite = void 0;
var srtp_crypto_suite_1 = __webpack_require__(/*! ./srtp-parameters/srtp-crypto-suite */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-crypto-suite.js");
Object.defineProperty(exports, "SrtpCryptoSuite", ({ enumerable: true, get: function () { return srtp_crypto_suite_1.SrtpCryptoSuite; } }));
var srtp_parameters_1 = __webpack_require__(/*! ./srtp-parameters/srtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-parameters.js");
Object.defineProperty(exports, "SrtpParameters", ({ enumerable: true, get: function () { return srtp_parameters_1.SrtpParameters; } }));
Object.defineProperty(exports, "SrtpParametersT", ({ enumerable: true, get: function () { return srtp_parameters_1.SrtpParametersT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-crypto-suite.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-crypto-suite.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SrtpCryptoSuite = void 0;
var SrtpCryptoSuite;
(function (SrtpCryptoSuite) {
    SrtpCryptoSuite[SrtpCryptoSuite["AEAD_AES_256_GCM"] = 0] = "AEAD_AES_256_GCM";
    SrtpCryptoSuite[SrtpCryptoSuite["AEAD_AES_128_GCM"] = 1] = "AEAD_AES_128_GCM";
    SrtpCryptoSuite[SrtpCryptoSuite["AES_CM_128_HMAC_SHA1_80"] = 2] = "AES_CM_128_HMAC_SHA1_80";
    SrtpCryptoSuite[SrtpCryptoSuite["AES_CM_128_HMAC_SHA1_32"] = 3] = "AES_CM_128_HMAC_SHA1_32";
})(SrtpCryptoSuite || (exports.SrtpCryptoSuite = SrtpCryptoSuite = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-parameters.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-parameters.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SrtpParametersT = exports.SrtpParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const srtp_crypto_suite_1 = __webpack_require__(/*! ../../fbs/srtp-parameters/srtp-crypto-suite */ "../../node_modules/mediasoup/node/lib/fbs/srtp-parameters/srtp-crypto-suite.js");
class SrtpParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSrtpParameters(bb, obj) {
        return (obj || new SrtpParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSrtpParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SrtpParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    cryptoSuite() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : srtp_crypto_suite_1.SrtpCryptoSuite.AEAD_AES_256_GCM;
    }
    keyBase64(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startSrtpParameters(builder) {
        builder.startObject(2);
    }
    static addCryptoSuite(builder, cryptoSuite) {
        builder.addFieldInt8(0, cryptoSuite, srtp_crypto_suite_1.SrtpCryptoSuite.AEAD_AES_256_GCM);
    }
    static addKeyBase64(builder, keyBase64Offset) {
        builder.addFieldOffset(1, keyBase64Offset, 0);
    }
    static endSrtpParameters(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // key_base64
        return offset;
    }
    static createSrtpParameters(builder, cryptoSuite, keyBase64Offset) {
        SrtpParameters.startSrtpParameters(builder);
        SrtpParameters.addCryptoSuite(builder, cryptoSuite);
        SrtpParameters.addKeyBase64(builder, keyBase64Offset);
        return SrtpParameters.endSrtpParameters(builder);
    }
    unpack() {
        return new SrtpParametersT(this.cryptoSuite(), this.keyBase64());
    }
    unpackTo(_o) {
        _o.cryptoSuite = this.cryptoSuite();
        _o.keyBase64 = this.keyBase64();
    }
}
exports.SrtpParameters = SrtpParameters;
class SrtpParametersT {
    cryptoSuite;
    keyBase64;
    constructor(cryptoSuite = srtp_crypto_suite_1.SrtpCryptoSuite.AEAD_AES_256_GCM, keyBase64 = null) {
        this.cryptoSuite = cryptoSuite;
        this.keyBase64 = keyBase64;
    }
    pack(builder) {
        const keyBase64 = (this.keyBase64 !== null ? builder.createString(this.keyBase64) : 0);
        return SrtpParameters.createSrtpParameters(builder, this.cryptoSuite, keyBase64);
    }
}
exports.SrtpParametersT = SrtpParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport.js":
/*!**************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetMinOutgoingBitrateRequestT = exports.SetMinOutgoingBitrateRequest = exports.SetMaxOutgoingBitrateRequestT = exports.SetMaxOutgoingBitrateRequest = exports.SetMaxIncomingBitrateRequestT = exports.SetMaxIncomingBitrateRequest = exports.SendRtcpNotificationT = exports.SendRtcpNotification = exports.SctpStateChangeNotificationT = exports.SctpStateChangeNotification = exports.SctpListenerT = exports.SctpListener = exports.RtpListenerT = exports.RtpListener = exports.RestartIceResponseT = exports.RestartIceResponse = exports.RecvRtpHeaderExtensionsT = exports.RecvRtpHeaderExtensions = exports.Protocol = exports.ProduceResponseT = exports.ProduceResponse = exports.ProduceRequestT = exports.ProduceRequest = exports.ProduceDataRequestT = exports.ProduceDataRequest = exports.OptionsT = exports.Options = exports.ListenInfoT = exports.ListenInfo = exports.EnableTraceEventRequestT = exports.EnableTraceEventRequest = exports.DumpT = exports.Dump = exports.ConsumeResponseT = exports.ConsumeResponse = exports.ConsumeRequestT = exports.ConsumeRequest = exports.ConsumeDataRequestT = exports.ConsumeDataRequest = exports.CloseProducerRequestT = exports.CloseProducerRequest = exports.CloseDataProducerRequestT = exports.CloseDataProducerRequest = exports.CloseDataConsumerRequestT = exports.CloseDataConsumerRequest = exports.CloseConsumerRequestT = exports.CloseConsumerRequest = exports.BweType = exports.BweTraceInfoT = exports.BweTraceInfo = void 0;
exports.TupleT = exports.Tuple = exports.TraceNotificationT = exports.TraceNotification = exports.TraceInfo = exports.TraceEventType = exports.StatsT = exports.Stats = exports.SocketFlagsT = exports.SocketFlags = void 0;
var bwe_trace_info_1 = __webpack_require__(/*! ./transport/bwe-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/bwe-trace-info.js");
Object.defineProperty(exports, "BweTraceInfo", ({ enumerable: true, get: function () { return bwe_trace_info_1.BweTraceInfo; } }));
Object.defineProperty(exports, "BweTraceInfoT", ({ enumerable: true, get: function () { return bwe_trace_info_1.BweTraceInfoT; } }));
var bwe_type_1 = __webpack_require__(/*! ./transport/bwe-type */ "../../node_modules/mediasoup/node/lib/fbs/transport/bwe-type.js");
Object.defineProperty(exports, "BweType", ({ enumerable: true, get: function () { return bwe_type_1.BweType; } }));
var close_consumer_request_1 = __webpack_require__(/*! ./transport/close-consumer-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/close-consumer-request.js");
Object.defineProperty(exports, "CloseConsumerRequest", ({ enumerable: true, get: function () { return close_consumer_request_1.CloseConsumerRequest; } }));
Object.defineProperty(exports, "CloseConsumerRequestT", ({ enumerable: true, get: function () { return close_consumer_request_1.CloseConsumerRequestT; } }));
var close_data_consumer_request_1 = __webpack_require__(/*! ./transport/close-data-consumer-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/close-data-consumer-request.js");
Object.defineProperty(exports, "CloseDataConsumerRequest", ({ enumerable: true, get: function () { return close_data_consumer_request_1.CloseDataConsumerRequest; } }));
Object.defineProperty(exports, "CloseDataConsumerRequestT", ({ enumerable: true, get: function () { return close_data_consumer_request_1.CloseDataConsumerRequestT; } }));
var close_data_producer_request_1 = __webpack_require__(/*! ./transport/close-data-producer-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/close-data-producer-request.js");
Object.defineProperty(exports, "CloseDataProducerRequest", ({ enumerable: true, get: function () { return close_data_producer_request_1.CloseDataProducerRequest; } }));
Object.defineProperty(exports, "CloseDataProducerRequestT", ({ enumerable: true, get: function () { return close_data_producer_request_1.CloseDataProducerRequestT; } }));
var close_producer_request_1 = __webpack_require__(/*! ./transport/close-producer-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/close-producer-request.js");
Object.defineProperty(exports, "CloseProducerRequest", ({ enumerable: true, get: function () { return close_producer_request_1.CloseProducerRequest; } }));
Object.defineProperty(exports, "CloseProducerRequestT", ({ enumerable: true, get: function () { return close_producer_request_1.CloseProducerRequestT; } }));
var consume_data_request_1 = __webpack_require__(/*! ./transport/consume-data-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-data-request.js");
Object.defineProperty(exports, "ConsumeDataRequest", ({ enumerable: true, get: function () { return consume_data_request_1.ConsumeDataRequest; } }));
Object.defineProperty(exports, "ConsumeDataRequestT", ({ enumerable: true, get: function () { return consume_data_request_1.ConsumeDataRequestT; } }));
var consume_request_1 = __webpack_require__(/*! ./transport/consume-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-request.js");
Object.defineProperty(exports, "ConsumeRequest", ({ enumerable: true, get: function () { return consume_request_1.ConsumeRequest; } }));
Object.defineProperty(exports, "ConsumeRequestT", ({ enumerable: true, get: function () { return consume_request_1.ConsumeRequestT; } }));
var consume_response_1 = __webpack_require__(/*! ./transport/consume-response */ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-response.js");
Object.defineProperty(exports, "ConsumeResponse", ({ enumerable: true, get: function () { return consume_response_1.ConsumeResponse; } }));
Object.defineProperty(exports, "ConsumeResponseT", ({ enumerable: true, get: function () { return consume_response_1.ConsumeResponseT; } }));
var dump_1 = __webpack_require__(/*! ./transport/dump */ "../../node_modules/mediasoup/node/lib/fbs/transport/dump.js");
Object.defineProperty(exports, "Dump", ({ enumerable: true, get: function () { return dump_1.Dump; } }));
Object.defineProperty(exports, "DumpT", ({ enumerable: true, get: function () { return dump_1.DumpT; } }));
var enable_trace_event_request_1 = __webpack_require__(/*! ./transport/enable-trace-event-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/enable-trace-event-request.js");
Object.defineProperty(exports, "EnableTraceEventRequest", ({ enumerable: true, get: function () { return enable_trace_event_request_1.EnableTraceEventRequest; } }));
Object.defineProperty(exports, "EnableTraceEventRequestT", ({ enumerable: true, get: function () { return enable_trace_event_request_1.EnableTraceEventRequestT; } }));
var listen_info_1 = __webpack_require__(/*! ./transport/listen-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/listen-info.js");
Object.defineProperty(exports, "ListenInfo", ({ enumerable: true, get: function () { return listen_info_1.ListenInfo; } }));
Object.defineProperty(exports, "ListenInfoT", ({ enumerable: true, get: function () { return listen_info_1.ListenInfoT; } }));
var options_1 = __webpack_require__(/*! ./transport/options */ "../../node_modules/mediasoup/node/lib/fbs/transport/options.js");
Object.defineProperty(exports, "Options", ({ enumerable: true, get: function () { return options_1.Options; } }));
Object.defineProperty(exports, "OptionsT", ({ enumerable: true, get: function () { return options_1.OptionsT; } }));
var produce_data_request_1 = __webpack_require__(/*! ./transport/produce-data-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-data-request.js");
Object.defineProperty(exports, "ProduceDataRequest", ({ enumerable: true, get: function () { return produce_data_request_1.ProduceDataRequest; } }));
Object.defineProperty(exports, "ProduceDataRequestT", ({ enumerable: true, get: function () { return produce_data_request_1.ProduceDataRequestT; } }));
var produce_request_1 = __webpack_require__(/*! ./transport/produce-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-request.js");
Object.defineProperty(exports, "ProduceRequest", ({ enumerable: true, get: function () { return produce_request_1.ProduceRequest; } }));
Object.defineProperty(exports, "ProduceRequestT", ({ enumerable: true, get: function () { return produce_request_1.ProduceRequestT; } }));
var produce_response_1 = __webpack_require__(/*! ./transport/produce-response */ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-response.js");
Object.defineProperty(exports, "ProduceResponse", ({ enumerable: true, get: function () { return produce_response_1.ProduceResponse; } }));
Object.defineProperty(exports, "ProduceResponseT", ({ enumerable: true, get: function () { return produce_response_1.ProduceResponseT; } }));
var protocol_1 = __webpack_require__(/*! ./transport/protocol */ "../../node_modules/mediasoup/node/lib/fbs/transport/protocol.js");
Object.defineProperty(exports, "Protocol", ({ enumerable: true, get: function () { return protocol_1.Protocol; } }));
var recv_rtp_header_extensions_1 = __webpack_require__(/*! ./transport/recv-rtp-header-extensions */ "../../node_modules/mediasoup/node/lib/fbs/transport/recv-rtp-header-extensions.js");
Object.defineProperty(exports, "RecvRtpHeaderExtensions", ({ enumerable: true, get: function () { return recv_rtp_header_extensions_1.RecvRtpHeaderExtensions; } }));
Object.defineProperty(exports, "RecvRtpHeaderExtensionsT", ({ enumerable: true, get: function () { return recv_rtp_header_extensions_1.RecvRtpHeaderExtensionsT; } }));
var restart_ice_response_1 = __webpack_require__(/*! ./transport/restart-ice-response */ "../../node_modules/mediasoup/node/lib/fbs/transport/restart-ice-response.js");
Object.defineProperty(exports, "RestartIceResponse", ({ enumerable: true, get: function () { return restart_ice_response_1.RestartIceResponse; } }));
Object.defineProperty(exports, "RestartIceResponseT", ({ enumerable: true, get: function () { return restart_ice_response_1.RestartIceResponseT; } }));
var rtp_listener_1 = __webpack_require__(/*! ./transport/rtp-listener */ "../../node_modules/mediasoup/node/lib/fbs/transport/rtp-listener.js");
Object.defineProperty(exports, "RtpListener", ({ enumerable: true, get: function () { return rtp_listener_1.RtpListener; } }));
Object.defineProperty(exports, "RtpListenerT", ({ enumerable: true, get: function () { return rtp_listener_1.RtpListenerT; } }));
var sctp_listener_1 = __webpack_require__(/*! ./transport/sctp-listener */ "../../node_modules/mediasoup/node/lib/fbs/transport/sctp-listener.js");
Object.defineProperty(exports, "SctpListener", ({ enumerable: true, get: function () { return sctp_listener_1.SctpListener; } }));
Object.defineProperty(exports, "SctpListenerT", ({ enumerable: true, get: function () { return sctp_listener_1.SctpListenerT; } }));
var sctp_state_change_notification_1 = __webpack_require__(/*! ./transport/sctp-state-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/transport/sctp-state-change-notification.js");
Object.defineProperty(exports, "SctpStateChangeNotification", ({ enumerable: true, get: function () { return sctp_state_change_notification_1.SctpStateChangeNotification; } }));
Object.defineProperty(exports, "SctpStateChangeNotificationT", ({ enumerable: true, get: function () { return sctp_state_change_notification_1.SctpStateChangeNotificationT; } }));
var send_rtcp_notification_1 = __webpack_require__(/*! ./transport/send-rtcp-notification */ "../../node_modules/mediasoup/node/lib/fbs/transport/send-rtcp-notification.js");
Object.defineProperty(exports, "SendRtcpNotification", ({ enumerable: true, get: function () { return send_rtcp_notification_1.SendRtcpNotification; } }));
Object.defineProperty(exports, "SendRtcpNotificationT", ({ enumerable: true, get: function () { return send_rtcp_notification_1.SendRtcpNotificationT; } }));
var set_max_incoming_bitrate_request_1 = __webpack_require__(/*! ./transport/set-max-incoming-bitrate-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/set-max-incoming-bitrate-request.js");
Object.defineProperty(exports, "SetMaxIncomingBitrateRequest", ({ enumerable: true, get: function () { return set_max_incoming_bitrate_request_1.SetMaxIncomingBitrateRequest; } }));
Object.defineProperty(exports, "SetMaxIncomingBitrateRequestT", ({ enumerable: true, get: function () { return set_max_incoming_bitrate_request_1.SetMaxIncomingBitrateRequestT; } }));
var set_max_outgoing_bitrate_request_1 = __webpack_require__(/*! ./transport/set-max-outgoing-bitrate-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/set-max-outgoing-bitrate-request.js");
Object.defineProperty(exports, "SetMaxOutgoingBitrateRequest", ({ enumerable: true, get: function () { return set_max_outgoing_bitrate_request_1.SetMaxOutgoingBitrateRequest; } }));
Object.defineProperty(exports, "SetMaxOutgoingBitrateRequestT", ({ enumerable: true, get: function () { return set_max_outgoing_bitrate_request_1.SetMaxOutgoingBitrateRequestT; } }));
var set_min_outgoing_bitrate_request_1 = __webpack_require__(/*! ./transport/set-min-outgoing-bitrate-request */ "../../node_modules/mediasoup/node/lib/fbs/transport/set-min-outgoing-bitrate-request.js");
Object.defineProperty(exports, "SetMinOutgoingBitrateRequest", ({ enumerable: true, get: function () { return set_min_outgoing_bitrate_request_1.SetMinOutgoingBitrateRequest; } }));
Object.defineProperty(exports, "SetMinOutgoingBitrateRequestT", ({ enumerable: true, get: function () { return set_min_outgoing_bitrate_request_1.SetMinOutgoingBitrateRequestT; } }));
var socket_flags_1 = __webpack_require__(/*! ./transport/socket-flags */ "../../node_modules/mediasoup/node/lib/fbs/transport/socket-flags.js");
Object.defineProperty(exports, "SocketFlags", ({ enumerable: true, get: function () { return socket_flags_1.SocketFlags; } }));
Object.defineProperty(exports, "SocketFlagsT", ({ enumerable: true, get: function () { return socket_flags_1.SocketFlagsT; } }));
var stats_1 = __webpack_require__(/*! ./transport/stats */ "../../node_modules/mediasoup/node/lib/fbs/transport/stats.js");
Object.defineProperty(exports, "Stats", ({ enumerable: true, get: function () { return stats_1.Stats; } }));
Object.defineProperty(exports, "StatsT", ({ enumerable: true, get: function () { return stats_1.StatsT; } }));
var trace_event_type_1 = __webpack_require__(/*! ./transport/trace-event-type */ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-event-type.js");
Object.defineProperty(exports, "TraceEventType", ({ enumerable: true, get: function () { return trace_event_type_1.TraceEventType; } }));
var trace_info_1 = __webpack_require__(/*! ./transport/trace-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-info.js");
Object.defineProperty(exports, "TraceInfo", ({ enumerable: true, get: function () { return trace_info_1.TraceInfo; } }));
var trace_notification_1 = __webpack_require__(/*! ./transport/trace-notification */ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-notification.js");
Object.defineProperty(exports, "TraceNotification", ({ enumerable: true, get: function () { return trace_notification_1.TraceNotification; } }));
Object.defineProperty(exports, "TraceNotificationT", ({ enumerable: true, get: function () { return trace_notification_1.TraceNotificationT; } }));
var tuple_1 = __webpack_require__(/*! ./transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
Object.defineProperty(exports, "Tuple", ({ enumerable: true, get: function () { return tuple_1.Tuple; } }));
Object.defineProperty(exports, "TupleT", ({ enumerable: true, get: function () { return tuple_1.TupleT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/bwe-trace-info.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/bwe-trace-info.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BweTraceInfoT = exports.BweTraceInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const bwe_type_1 = __webpack_require__(/*! ../../fbs/transport/bwe-type */ "../../node_modules/mediasoup/node/lib/fbs/transport/bwe-type.js");
class BweTraceInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBweTraceInfo(bb, obj) {
        return (obj || new BweTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBweTraceInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BweTraceInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bweType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : bwe_type_1.BweType.TRANSPORT_CC;
    }
    desiredBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    effectiveDesiredBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    minBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    maxBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    startBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    maxPaddingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    availableBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startBweTraceInfo(builder) {
        builder.startObject(8);
    }
    static addBweType(builder, bweType) {
        builder.addFieldInt8(0, bweType, bwe_type_1.BweType.TRANSPORT_CC);
    }
    static addDesiredBitrate(builder, desiredBitrate) {
        builder.addFieldInt32(1, desiredBitrate, 0);
    }
    static addEffectiveDesiredBitrate(builder, effectiveDesiredBitrate) {
        builder.addFieldInt32(2, effectiveDesiredBitrate, 0);
    }
    static addMinBitrate(builder, minBitrate) {
        builder.addFieldInt32(3, minBitrate, 0);
    }
    static addMaxBitrate(builder, maxBitrate) {
        builder.addFieldInt32(4, maxBitrate, 0);
    }
    static addStartBitrate(builder, startBitrate) {
        builder.addFieldInt32(5, startBitrate, 0);
    }
    static addMaxPaddingBitrate(builder, maxPaddingBitrate) {
        builder.addFieldInt32(6, maxPaddingBitrate, 0);
    }
    static addAvailableBitrate(builder, availableBitrate) {
        builder.addFieldInt32(7, availableBitrate, 0);
    }
    static endBweTraceInfo(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBweTraceInfo(builder, bweType, desiredBitrate, effectiveDesiredBitrate, minBitrate, maxBitrate, startBitrate, maxPaddingBitrate, availableBitrate) {
        BweTraceInfo.startBweTraceInfo(builder);
        BweTraceInfo.addBweType(builder, bweType);
        BweTraceInfo.addDesiredBitrate(builder, desiredBitrate);
        BweTraceInfo.addEffectiveDesiredBitrate(builder, effectiveDesiredBitrate);
        BweTraceInfo.addMinBitrate(builder, minBitrate);
        BweTraceInfo.addMaxBitrate(builder, maxBitrate);
        BweTraceInfo.addStartBitrate(builder, startBitrate);
        BweTraceInfo.addMaxPaddingBitrate(builder, maxPaddingBitrate);
        BweTraceInfo.addAvailableBitrate(builder, availableBitrate);
        return BweTraceInfo.endBweTraceInfo(builder);
    }
    unpack() {
        return new BweTraceInfoT(this.bweType(), this.desiredBitrate(), this.effectiveDesiredBitrate(), this.minBitrate(), this.maxBitrate(), this.startBitrate(), this.maxPaddingBitrate(), this.availableBitrate());
    }
    unpackTo(_o) {
        _o.bweType = this.bweType();
        _o.desiredBitrate = this.desiredBitrate();
        _o.effectiveDesiredBitrate = this.effectiveDesiredBitrate();
        _o.minBitrate = this.minBitrate();
        _o.maxBitrate = this.maxBitrate();
        _o.startBitrate = this.startBitrate();
        _o.maxPaddingBitrate = this.maxPaddingBitrate();
        _o.availableBitrate = this.availableBitrate();
    }
}
exports.BweTraceInfo = BweTraceInfo;
class BweTraceInfoT {
    bweType;
    desiredBitrate;
    effectiveDesiredBitrate;
    minBitrate;
    maxBitrate;
    startBitrate;
    maxPaddingBitrate;
    availableBitrate;
    constructor(bweType = bwe_type_1.BweType.TRANSPORT_CC, desiredBitrate = 0, effectiveDesiredBitrate = 0, minBitrate = 0, maxBitrate = 0, startBitrate = 0, maxPaddingBitrate = 0, availableBitrate = 0) {
        this.bweType = bweType;
        this.desiredBitrate = desiredBitrate;
        this.effectiveDesiredBitrate = effectiveDesiredBitrate;
        this.minBitrate = minBitrate;
        this.maxBitrate = maxBitrate;
        this.startBitrate = startBitrate;
        this.maxPaddingBitrate = maxPaddingBitrate;
        this.availableBitrate = availableBitrate;
    }
    pack(builder) {
        return BweTraceInfo.createBweTraceInfo(builder, this.bweType, this.desiredBitrate, this.effectiveDesiredBitrate, this.minBitrate, this.maxBitrate, this.startBitrate, this.maxPaddingBitrate, this.availableBitrate);
    }
}
exports.BweTraceInfoT = BweTraceInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/bwe-type.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/bwe-type.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BweType = void 0;
var BweType;
(function (BweType) {
    BweType[BweType["TRANSPORT_CC"] = 0] = "TRANSPORT_CC";
    BweType[BweType["REMB"] = 1] = "REMB";
})(BweType || (exports.BweType = BweType = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/close-consumer-request.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/close-consumer-request.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseConsumerRequestT = exports.CloseConsumerRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CloseConsumerRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCloseConsumerRequest(bb, obj) {
        return (obj || new CloseConsumerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCloseConsumerRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CloseConsumerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    consumerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCloseConsumerRequest(builder) {
        builder.startObject(1);
    }
    static addConsumerId(builder, consumerIdOffset) {
        builder.addFieldOffset(0, consumerIdOffset, 0);
    }
    static endCloseConsumerRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // consumer_id
        return offset;
    }
    static createCloseConsumerRequest(builder, consumerIdOffset) {
        CloseConsumerRequest.startCloseConsumerRequest(builder);
        CloseConsumerRequest.addConsumerId(builder, consumerIdOffset);
        return CloseConsumerRequest.endCloseConsumerRequest(builder);
    }
    unpack() {
        return new CloseConsumerRequestT(this.consumerId());
    }
    unpackTo(_o) {
        _o.consumerId = this.consumerId();
    }
}
exports.CloseConsumerRequest = CloseConsumerRequest;
class CloseConsumerRequestT {
    consumerId;
    constructor(consumerId = null) {
        this.consumerId = consumerId;
    }
    pack(builder) {
        const consumerId = (this.consumerId !== null ? builder.createString(this.consumerId) : 0);
        return CloseConsumerRequest.createCloseConsumerRequest(builder, consumerId);
    }
}
exports.CloseConsumerRequestT = CloseConsumerRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/close-data-consumer-request.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/close-data-consumer-request.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseDataConsumerRequestT = exports.CloseDataConsumerRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CloseDataConsumerRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCloseDataConsumerRequest(bb, obj) {
        return (obj || new CloseDataConsumerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCloseDataConsumerRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CloseDataConsumerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dataConsumerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCloseDataConsumerRequest(builder) {
        builder.startObject(1);
    }
    static addDataConsumerId(builder, dataConsumerIdOffset) {
        builder.addFieldOffset(0, dataConsumerIdOffset, 0);
    }
    static endCloseDataConsumerRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data_consumer_id
        return offset;
    }
    static createCloseDataConsumerRequest(builder, dataConsumerIdOffset) {
        CloseDataConsumerRequest.startCloseDataConsumerRequest(builder);
        CloseDataConsumerRequest.addDataConsumerId(builder, dataConsumerIdOffset);
        return CloseDataConsumerRequest.endCloseDataConsumerRequest(builder);
    }
    unpack() {
        return new CloseDataConsumerRequestT(this.dataConsumerId());
    }
    unpackTo(_o) {
        _o.dataConsumerId = this.dataConsumerId();
    }
}
exports.CloseDataConsumerRequest = CloseDataConsumerRequest;
class CloseDataConsumerRequestT {
    dataConsumerId;
    constructor(dataConsumerId = null) {
        this.dataConsumerId = dataConsumerId;
    }
    pack(builder) {
        const dataConsumerId = (this.dataConsumerId !== null ? builder.createString(this.dataConsumerId) : 0);
        return CloseDataConsumerRequest.createCloseDataConsumerRequest(builder, dataConsumerId);
    }
}
exports.CloseDataConsumerRequestT = CloseDataConsumerRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/close-data-producer-request.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/close-data-producer-request.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseDataProducerRequestT = exports.CloseDataProducerRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CloseDataProducerRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCloseDataProducerRequest(bb, obj) {
        return (obj || new CloseDataProducerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCloseDataProducerRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CloseDataProducerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dataProducerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCloseDataProducerRequest(builder) {
        builder.startObject(1);
    }
    static addDataProducerId(builder, dataProducerIdOffset) {
        builder.addFieldOffset(0, dataProducerIdOffset, 0);
    }
    static endCloseDataProducerRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data_producer_id
        return offset;
    }
    static createCloseDataProducerRequest(builder, dataProducerIdOffset) {
        CloseDataProducerRequest.startCloseDataProducerRequest(builder);
        CloseDataProducerRequest.addDataProducerId(builder, dataProducerIdOffset);
        return CloseDataProducerRequest.endCloseDataProducerRequest(builder);
    }
    unpack() {
        return new CloseDataProducerRequestT(this.dataProducerId());
    }
    unpackTo(_o) {
        _o.dataProducerId = this.dataProducerId();
    }
}
exports.CloseDataProducerRequest = CloseDataProducerRequest;
class CloseDataProducerRequestT {
    dataProducerId;
    constructor(dataProducerId = null) {
        this.dataProducerId = dataProducerId;
    }
    pack(builder) {
        const dataProducerId = (this.dataProducerId !== null ? builder.createString(this.dataProducerId) : 0);
        return CloseDataProducerRequest.createCloseDataProducerRequest(builder, dataProducerId);
    }
}
exports.CloseDataProducerRequestT = CloseDataProducerRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/close-producer-request.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/close-producer-request.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseProducerRequestT = exports.CloseProducerRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CloseProducerRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCloseProducerRequest(bb, obj) {
        return (obj || new CloseProducerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCloseProducerRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CloseProducerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    producerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCloseProducerRequest(builder) {
        builder.startObject(1);
    }
    static addProducerId(builder, producerIdOffset) {
        builder.addFieldOffset(0, producerIdOffset, 0);
    }
    static endCloseProducerRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // producer_id
        return offset;
    }
    static createCloseProducerRequest(builder, producerIdOffset) {
        CloseProducerRequest.startCloseProducerRequest(builder);
        CloseProducerRequest.addProducerId(builder, producerIdOffset);
        return CloseProducerRequest.endCloseProducerRequest(builder);
    }
    unpack() {
        return new CloseProducerRequestT(this.producerId());
    }
    unpackTo(_o) {
        _o.producerId = this.producerId();
    }
}
exports.CloseProducerRequest = CloseProducerRequest;
class CloseProducerRequestT {
    producerId;
    constructor(producerId = null) {
        this.producerId = producerId;
    }
    pack(builder) {
        const producerId = (this.producerId !== null ? builder.createString(this.producerId) : 0);
        return CloseProducerRequest.createCloseProducerRequest(builder, producerId);
    }
}
exports.CloseProducerRequestT = CloseProducerRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-data-request.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/consume-data-request.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsumeDataRequestT = exports.ConsumeDataRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const type_1 = __webpack_require__(/*! ../../fbs/data-producer/type */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/type.js");
const sctp_stream_parameters_1 = __webpack_require__(/*! ../../fbs/sctp-parameters/sctp-stream-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-stream-parameters.js");
class ConsumeDataRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConsumeDataRequest(bb, obj) {
        return (obj || new ConsumeDataRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConsumeDataRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConsumeDataRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dataConsumerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    dataProducerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_1.Type.SCTP;
    }
    sctpStreamParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new sctp_stream_parameters_1.SctpStreamParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    label(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    protocol(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    subchannels(index) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
    }
    subchannelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    subchannelsArray() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startConsumeDataRequest(builder) {
        builder.startObject(8);
    }
    static addDataConsumerId(builder, dataConsumerIdOffset) {
        builder.addFieldOffset(0, dataConsumerIdOffset, 0);
    }
    static addDataProducerId(builder, dataProducerIdOffset) {
        builder.addFieldOffset(1, dataProducerIdOffset, 0);
    }
    static addType(builder, type) {
        builder.addFieldInt8(2, type, type_1.Type.SCTP);
    }
    static addSctpStreamParameters(builder, sctpStreamParametersOffset) {
        builder.addFieldOffset(3, sctpStreamParametersOffset, 0);
    }
    static addLabel(builder, labelOffset) {
        builder.addFieldOffset(4, labelOffset, 0);
    }
    static addProtocol(builder, protocolOffset) {
        builder.addFieldOffset(5, protocolOffset, 0);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(6, +paused, +false);
    }
    static addSubchannels(builder, subchannelsOffset) {
        builder.addFieldOffset(7, subchannelsOffset, 0);
    }
    static createSubchannelsVector(builder, data) {
        builder.startVector(2, data.length, 2);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt16(data[i]);
        }
        return builder.endVector();
    }
    static startSubchannelsVector(builder, numElems) {
        builder.startVector(2, numElems, 2);
    }
    static endConsumeDataRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data_consumer_id
        builder.requiredField(offset, 6); // data_producer_id
        return offset;
    }
    unpack() {
        return new ConsumeDataRequestT(this.dataConsumerId(), this.dataProducerId(), this.type(), (this.sctpStreamParameters() !== null ? this.sctpStreamParameters().unpack() : null), this.label(), this.protocol(), this.paused(), this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength()));
    }
    unpackTo(_o) {
        _o.dataConsumerId = this.dataConsumerId();
        _o.dataProducerId = this.dataProducerId();
        _o.type = this.type();
        _o.sctpStreamParameters = (this.sctpStreamParameters() !== null ? this.sctpStreamParameters().unpack() : null);
        _o.label = this.label();
        _o.protocol = this.protocol();
        _o.paused = this.paused();
        _o.subchannels = this.bb.createScalarList(this.subchannels.bind(this), this.subchannelsLength());
    }
}
exports.ConsumeDataRequest = ConsumeDataRequest;
class ConsumeDataRequestT {
    dataConsumerId;
    dataProducerId;
    type;
    sctpStreamParameters;
    label;
    protocol;
    paused;
    subchannels;
    constructor(dataConsumerId = null, dataProducerId = null, type = type_1.Type.SCTP, sctpStreamParameters = null, label = null, protocol = null, paused = false, subchannels = []) {
        this.dataConsumerId = dataConsumerId;
        this.dataProducerId = dataProducerId;
        this.type = type;
        this.sctpStreamParameters = sctpStreamParameters;
        this.label = label;
        this.protocol = protocol;
        this.paused = paused;
        this.subchannels = subchannels;
    }
    pack(builder) {
        const dataConsumerId = (this.dataConsumerId !== null ? builder.createString(this.dataConsumerId) : 0);
        const dataProducerId = (this.dataProducerId !== null ? builder.createString(this.dataProducerId) : 0);
        const sctpStreamParameters = (this.sctpStreamParameters !== null ? this.sctpStreamParameters.pack(builder) : 0);
        const label = (this.label !== null ? builder.createString(this.label) : 0);
        const protocol = (this.protocol !== null ? builder.createString(this.protocol) : 0);
        const subchannels = ConsumeDataRequest.createSubchannelsVector(builder, this.subchannels);
        ConsumeDataRequest.startConsumeDataRequest(builder);
        ConsumeDataRequest.addDataConsumerId(builder, dataConsumerId);
        ConsumeDataRequest.addDataProducerId(builder, dataProducerId);
        ConsumeDataRequest.addType(builder, this.type);
        ConsumeDataRequest.addSctpStreamParameters(builder, sctpStreamParameters);
        ConsumeDataRequest.addLabel(builder, label);
        ConsumeDataRequest.addProtocol(builder, protocol);
        ConsumeDataRequest.addPaused(builder, this.paused);
        ConsumeDataRequest.addSubchannels(builder, subchannels);
        return ConsumeDataRequest.endConsumeDataRequest(builder);
    }
}
exports.ConsumeDataRequestT = ConsumeDataRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-request.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/consume-request.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsumeRequestT = exports.ConsumeRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const consumer_layers_1 = __webpack_require__(/*! ../../fbs/consumer/consumer-layers */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-layers.js");
const media_kind_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/media-kind */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js");
const rtp_encoding_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-encoding-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-encoding-parameters.js");
const rtp_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-parameters.js");
const type_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/type */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/type.js");
class ConsumeRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConsumeRequest(bb, obj) {
        return (obj || new ConsumeRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConsumeRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConsumeRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    consumerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    producerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    kind() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : media_kind_1.MediaKind.AUDIO;
    }
    rtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new rtp_parameters_1.RtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_1.Type.SIMPLE;
    }
    consumableRtpEncodings(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new rtp_encoding_parameters_1.RtpEncodingParameters()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    consumableRtpEncodingsLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    preferredLayers(obj) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? (obj || new consumer_layers_1.ConsumerLayers()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    ignoreDtx() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startConsumeRequest(builder) {
        builder.startObject(9);
    }
    static addConsumerId(builder, consumerIdOffset) {
        builder.addFieldOffset(0, consumerIdOffset, 0);
    }
    static addProducerId(builder, producerIdOffset) {
        builder.addFieldOffset(1, producerIdOffset, 0);
    }
    static addKind(builder, kind) {
        builder.addFieldInt8(2, kind, media_kind_1.MediaKind.AUDIO);
    }
    static addRtpParameters(builder, rtpParametersOffset) {
        builder.addFieldOffset(3, rtpParametersOffset, 0);
    }
    static addType(builder, type) {
        builder.addFieldInt8(4, type, type_1.Type.SIMPLE);
    }
    static addConsumableRtpEncodings(builder, consumableRtpEncodingsOffset) {
        builder.addFieldOffset(5, consumableRtpEncodingsOffset, 0);
    }
    static createConsumableRtpEncodingsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startConsumableRtpEncodingsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(6, +paused, +false);
    }
    static addPreferredLayers(builder, preferredLayersOffset) {
        builder.addFieldOffset(7, preferredLayersOffset, 0);
    }
    static addIgnoreDtx(builder, ignoreDtx) {
        builder.addFieldInt8(8, +ignoreDtx, +false);
    }
    static endConsumeRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // consumer_id
        builder.requiredField(offset, 6); // producer_id
        builder.requiredField(offset, 10); // rtp_parameters
        builder.requiredField(offset, 14); // consumable_rtp_encodings
        return offset;
    }
    unpack() {
        return new ConsumeRequestT(this.consumerId(), this.producerId(), this.kind(), (this.rtpParameters() !== null ? this.rtpParameters().unpack() : null), this.type(), this.bb.createObjList(this.consumableRtpEncodings.bind(this), this.consumableRtpEncodingsLength()), this.paused(), (this.preferredLayers() !== null ? this.preferredLayers().unpack() : null), this.ignoreDtx());
    }
    unpackTo(_o) {
        _o.consumerId = this.consumerId();
        _o.producerId = this.producerId();
        _o.kind = this.kind();
        _o.rtpParameters = (this.rtpParameters() !== null ? this.rtpParameters().unpack() : null);
        _o.type = this.type();
        _o.consumableRtpEncodings = this.bb.createObjList(this.consumableRtpEncodings.bind(this), this.consumableRtpEncodingsLength());
        _o.paused = this.paused();
        _o.preferredLayers = (this.preferredLayers() !== null ? this.preferredLayers().unpack() : null);
        _o.ignoreDtx = this.ignoreDtx();
    }
}
exports.ConsumeRequest = ConsumeRequest;
class ConsumeRequestT {
    consumerId;
    producerId;
    kind;
    rtpParameters;
    type;
    consumableRtpEncodings;
    paused;
    preferredLayers;
    ignoreDtx;
    constructor(consumerId = null, producerId = null, kind = media_kind_1.MediaKind.AUDIO, rtpParameters = null, type = type_1.Type.SIMPLE, consumableRtpEncodings = [], paused = false, preferredLayers = null, ignoreDtx = false) {
        this.consumerId = consumerId;
        this.producerId = producerId;
        this.kind = kind;
        this.rtpParameters = rtpParameters;
        this.type = type;
        this.consumableRtpEncodings = consumableRtpEncodings;
        this.paused = paused;
        this.preferredLayers = preferredLayers;
        this.ignoreDtx = ignoreDtx;
    }
    pack(builder) {
        const consumerId = (this.consumerId !== null ? builder.createString(this.consumerId) : 0);
        const producerId = (this.producerId !== null ? builder.createString(this.producerId) : 0);
        const rtpParameters = (this.rtpParameters !== null ? this.rtpParameters.pack(builder) : 0);
        const consumableRtpEncodings = ConsumeRequest.createConsumableRtpEncodingsVector(builder, builder.createObjectOffsetList(this.consumableRtpEncodings));
        const preferredLayers = (this.preferredLayers !== null ? this.preferredLayers.pack(builder) : 0);
        ConsumeRequest.startConsumeRequest(builder);
        ConsumeRequest.addConsumerId(builder, consumerId);
        ConsumeRequest.addProducerId(builder, producerId);
        ConsumeRequest.addKind(builder, this.kind);
        ConsumeRequest.addRtpParameters(builder, rtpParameters);
        ConsumeRequest.addType(builder, this.type);
        ConsumeRequest.addConsumableRtpEncodings(builder, consumableRtpEncodings);
        ConsumeRequest.addPaused(builder, this.paused);
        ConsumeRequest.addPreferredLayers(builder, preferredLayers);
        ConsumeRequest.addIgnoreDtx(builder, this.ignoreDtx);
        return ConsumeRequest.endConsumeRequest(builder);
    }
}
exports.ConsumeRequestT = ConsumeRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/consume-response.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/consume-response.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsumeResponseT = exports.ConsumeResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const consumer_layers_1 = __webpack_require__(/*! ../../fbs/consumer/consumer-layers */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-layers.js");
const consumer_score_1 = __webpack_require__(/*! ../../fbs/consumer/consumer-score */ "../../node_modules/mediasoup/node/lib/fbs/consumer/consumer-score.js");
class ConsumeResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConsumeResponse(bb, obj) {
        return (obj || new ConsumeResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConsumeResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConsumeResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    producerPaused() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    score(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new consumer_score_1.ConsumerScore()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    preferredLayers(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new consumer_layers_1.ConsumerLayers()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startConsumeResponse(builder) {
        builder.startObject(4);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(0, +paused, +false);
    }
    static addProducerPaused(builder, producerPaused) {
        builder.addFieldInt8(1, +producerPaused, +false);
    }
    static addScore(builder, scoreOffset) {
        builder.addFieldOffset(2, scoreOffset, 0);
    }
    static addPreferredLayers(builder, preferredLayersOffset) {
        builder.addFieldOffset(3, preferredLayersOffset, 0);
    }
    static endConsumeResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 8); // score
        return offset;
    }
    unpack() {
        return new ConsumeResponseT(this.paused(), this.producerPaused(), (this.score() !== null ? this.score().unpack() : null), (this.preferredLayers() !== null ? this.preferredLayers().unpack() : null));
    }
    unpackTo(_o) {
        _o.paused = this.paused();
        _o.producerPaused = this.producerPaused();
        _o.score = (this.score() !== null ? this.score().unpack() : null);
        _o.preferredLayers = (this.preferredLayers() !== null ? this.preferredLayers().unpack() : null);
    }
}
exports.ConsumeResponse = ConsumeResponse;
class ConsumeResponseT {
    paused;
    producerPaused;
    score;
    preferredLayers;
    constructor(paused = false, producerPaused = false, score = null, preferredLayers = null) {
        this.paused = paused;
        this.producerPaused = producerPaused;
        this.score = score;
        this.preferredLayers = preferredLayers;
    }
    pack(builder) {
        const score = (this.score !== null ? this.score.pack(builder) : 0);
        const preferredLayers = (this.preferredLayers !== null ? this.preferredLayers.pack(builder) : 0);
        ConsumeResponse.startConsumeResponse(builder);
        ConsumeResponse.addPaused(builder, this.paused);
        ConsumeResponse.addProducerPaused(builder, this.producerPaused);
        ConsumeResponse.addScore(builder, score);
        ConsumeResponse.addPreferredLayers(builder, preferredLayers);
        return ConsumeResponse.endConsumeResponse(builder);
    }
}
exports.ConsumeResponseT = ConsumeResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/dump.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/dump.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpT = exports.Dump = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const uint32_string_1 = __webpack_require__(/*! ../../fbs/common/uint32-string */ "../../node_modules/mediasoup/node/lib/fbs/common/uint32-string.js");
const sctp_parameters_1 = __webpack_require__(/*! ../../fbs/sctp-parameters/sctp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-parameters.js");
const recv_rtp_header_extensions_1 = __webpack_require__(/*! ../../fbs/transport/recv-rtp-header-extensions */ "../../node_modules/mediasoup/node/lib/fbs/transport/recv-rtp-header-extensions.js");
const rtp_listener_1 = __webpack_require__(/*! ../../fbs/transport/rtp-listener */ "../../node_modules/mediasoup/node/lib/fbs/transport/rtp-listener.js");
const sctp_listener_1 = __webpack_require__(/*! ../../fbs/transport/sctp-listener */ "../../node_modules/mediasoup/node/lib/fbs/transport/sctp-listener.js");
class Dump {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDump(bb, obj) {
        return (obj || new Dump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDump(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Dump()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    direct() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    producerIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    producerIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    consumerIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    consumerIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    mapSsrcConsumerId(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new uint32_string_1.Uint32String()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    mapSsrcConsumerIdLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    mapRtxSsrcConsumerId(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new uint32_string_1.Uint32String()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    mapRtxSsrcConsumerIdLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataProducerIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    dataProducerIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataConsumerIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    dataConsumerIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recvRtpHeaderExtensions(obj) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? (obj || new recv_rtp_header_extensions_1.RecvRtpHeaderExtensions()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtpListener(obj) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? (obj || new rtp_listener_1.RtpListener()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    maxMessageSize() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    sctpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? (obj || new sctp_parameters_1.SctpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    sctpState() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    sctpListener(obj) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? (obj || new sctp_listener_1.SctpListener()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    traceEventTypes(index) {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    traceEventTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    traceEventTypesArray() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startDump(builder) {
        builder.startObject(15);
    }
    static addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    }
    static addDirect(builder, direct) {
        builder.addFieldInt8(1, +direct, +false);
    }
    static addProducerIds(builder, producerIdsOffset) {
        builder.addFieldOffset(2, producerIdsOffset, 0);
    }
    static createProducerIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startProducerIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addConsumerIds(builder, consumerIdsOffset) {
        builder.addFieldOffset(3, consumerIdsOffset, 0);
    }
    static createConsumerIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startConsumerIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addMapSsrcConsumerId(builder, mapSsrcConsumerIdOffset) {
        builder.addFieldOffset(4, mapSsrcConsumerIdOffset, 0);
    }
    static createMapSsrcConsumerIdVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startMapSsrcConsumerIdVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addMapRtxSsrcConsumerId(builder, mapRtxSsrcConsumerIdOffset) {
        builder.addFieldOffset(5, mapRtxSsrcConsumerIdOffset, 0);
    }
    static createMapRtxSsrcConsumerIdVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startMapRtxSsrcConsumerIdVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addDataProducerIds(builder, dataProducerIdsOffset) {
        builder.addFieldOffset(6, dataProducerIdsOffset, 0);
    }
    static createDataProducerIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startDataProducerIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addDataConsumerIds(builder, dataConsumerIdsOffset) {
        builder.addFieldOffset(7, dataConsumerIdsOffset, 0);
    }
    static createDataConsumerIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startDataConsumerIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRecvRtpHeaderExtensions(builder, recvRtpHeaderExtensionsOffset) {
        builder.addFieldOffset(8, recvRtpHeaderExtensionsOffset, 0);
    }
    static addRtpListener(builder, rtpListenerOffset) {
        builder.addFieldOffset(9, rtpListenerOffset, 0);
    }
    static addMaxMessageSize(builder, maxMessageSize) {
        builder.addFieldInt32(10, maxMessageSize, 0);
    }
    static addSctpParameters(builder, sctpParametersOffset) {
        builder.addFieldOffset(11, sctpParametersOffset, 0);
    }
    static addSctpState(builder, sctpState) {
        builder.addFieldInt8(12, sctpState, 0);
    }
    static addSctpListener(builder, sctpListenerOffset) {
        builder.addFieldOffset(13, sctpListenerOffset, 0);
    }
    static addTraceEventTypes(builder, traceEventTypesOffset) {
        builder.addFieldOffset(14, traceEventTypesOffset, 0);
    }
    static createTraceEventTypesVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startTraceEventTypesVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endDump(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // id
        builder.requiredField(offset, 8); // producer_ids
        builder.requiredField(offset, 10); // consumer_ids
        builder.requiredField(offset, 12); // map_ssrc_consumer_id
        builder.requiredField(offset, 14); // map_rtx_ssrc_consumer_id
        builder.requiredField(offset, 16); // data_producer_ids
        builder.requiredField(offset, 18); // data_consumer_ids
        builder.requiredField(offset, 20); // recv_rtp_header_extensions
        builder.requiredField(offset, 22); // rtp_listener
        builder.requiredField(offset, 32); // trace_event_types
        return offset;
    }
    unpack() {
        return new DumpT(this.id(), this.direct(), this.bb.createScalarList(this.producerIds.bind(this), this.producerIdsLength()), this.bb.createScalarList(this.consumerIds.bind(this), this.consumerIdsLength()), this.bb.createObjList(this.mapSsrcConsumerId.bind(this), this.mapSsrcConsumerIdLength()), this.bb.createObjList(this.mapRtxSsrcConsumerId.bind(this), this.mapRtxSsrcConsumerIdLength()), this.bb.createScalarList(this.dataProducerIds.bind(this), this.dataProducerIdsLength()), this.bb.createScalarList(this.dataConsumerIds.bind(this), this.dataConsumerIdsLength()), (this.recvRtpHeaderExtensions() !== null ? this.recvRtpHeaderExtensions().unpack() : null), (this.rtpListener() !== null ? this.rtpListener().unpack() : null), this.maxMessageSize(), (this.sctpParameters() !== null ? this.sctpParameters().unpack() : null), this.sctpState(), (this.sctpListener() !== null ? this.sctpListener().unpack() : null), this.bb.createScalarList(this.traceEventTypes.bind(this), this.traceEventTypesLength()));
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.direct = this.direct();
        _o.producerIds = this.bb.createScalarList(this.producerIds.bind(this), this.producerIdsLength());
        _o.consumerIds = this.bb.createScalarList(this.consumerIds.bind(this), this.consumerIdsLength());
        _o.mapSsrcConsumerId = this.bb.createObjList(this.mapSsrcConsumerId.bind(this), this.mapSsrcConsumerIdLength());
        _o.mapRtxSsrcConsumerId = this.bb.createObjList(this.mapRtxSsrcConsumerId.bind(this), this.mapRtxSsrcConsumerIdLength());
        _o.dataProducerIds = this.bb.createScalarList(this.dataProducerIds.bind(this), this.dataProducerIdsLength());
        _o.dataConsumerIds = this.bb.createScalarList(this.dataConsumerIds.bind(this), this.dataConsumerIdsLength());
        _o.recvRtpHeaderExtensions = (this.recvRtpHeaderExtensions() !== null ? this.recvRtpHeaderExtensions().unpack() : null);
        _o.rtpListener = (this.rtpListener() !== null ? this.rtpListener().unpack() : null);
        _o.maxMessageSize = this.maxMessageSize();
        _o.sctpParameters = (this.sctpParameters() !== null ? this.sctpParameters().unpack() : null);
        _o.sctpState = this.sctpState();
        _o.sctpListener = (this.sctpListener() !== null ? this.sctpListener().unpack() : null);
        _o.traceEventTypes = this.bb.createScalarList(this.traceEventTypes.bind(this), this.traceEventTypesLength());
    }
}
exports.Dump = Dump;
class DumpT {
    id;
    direct;
    producerIds;
    consumerIds;
    mapSsrcConsumerId;
    mapRtxSsrcConsumerId;
    dataProducerIds;
    dataConsumerIds;
    recvRtpHeaderExtensions;
    rtpListener;
    maxMessageSize;
    sctpParameters;
    sctpState;
    sctpListener;
    traceEventTypes;
    constructor(id = null, direct = false, producerIds = [], consumerIds = [], mapSsrcConsumerId = [], mapRtxSsrcConsumerId = [], dataProducerIds = [], dataConsumerIds = [], recvRtpHeaderExtensions = null, rtpListener = null, maxMessageSize = 0, sctpParameters = null, sctpState = null, sctpListener = null, traceEventTypes = []) {
        this.id = id;
        this.direct = direct;
        this.producerIds = producerIds;
        this.consumerIds = consumerIds;
        this.mapSsrcConsumerId = mapSsrcConsumerId;
        this.mapRtxSsrcConsumerId = mapRtxSsrcConsumerId;
        this.dataProducerIds = dataProducerIds;
        this.dataConsumerIds = dataConsumerIds;
        this.recvRtpHeaderExtensions = recvRtpHeaderExtensions;
        this.rtpListener = rtpListener;
        this.maxMessageSize = maxMessageSize;
        this.sctpParameters = sctpParameters;
        this.sctpState = sctpState;
        this.sctpListener = sctpListener;
        this.traceEventTypes = traceEventTypes;
    }
    pack(builder) {
        const id = (this.id !== null ? builder.createString(this.id) : 0);
        const producerIds = Dump.createProducerIdsVector(builder, builder.createObjectOffsetList(this.producerIds));
        const consumerIds = Dump.createConsumerIdsVector(builder, builder.createObjectOffsetList(this.consumerIds));
        const mapSsrcConsumerId = Dump.createMapSsrcConsumerIdVector(builder, builder.createObjectOffsetList(this.mapSsrcConsumerId));
        const mapRtxSsrcConsumerId = Dump.createMapRtxSsrcConsumerIdVector(builder, builder.createObjectOffsetList(this.mapRtxSsrcConsumerId));
        const dataProducerIds = Dump.createDataProducerIdsVector(builder, builder.createObjectOffsetList(this.dataProducerIds));
        const dataConsumerIds = Dump.createDataConsumerIdsVector(builder, builder.createObjectOffsetList(this.dataConsumerIds));
        const recvRtpHeaderExtensions = (this.recvRtpHeaderExtensions !== null ? this.recvRtpHeaderExtensions.pack(builder) : 0);
        const rtpListener = (this.rtpListener !== null ? this.rtpListener.pack(builder) : 0);
        const sctpParameters = (this.sctpParameters !== null ? this.sctpParameters.pack(builder) : 0);
        const sctpListener = (this.sctpListener !== null ? this.sctpListener.pack(builder) : 0);
        const traceEventTypes = Dump.createTraceEventTypesVector(builder, this.traceEventTypes);
        Dump.startDump(builder);
        Dump.addId(builder, id);
        Dump.addDirect(builder, this.direct);
        Dump.addProducerIds(builder, producerIds);
        Dump.addConsumerIds(builder, consumerIds);
        Dump.addMapSsrcConsumerId(builder, mapSsrcConsumerId);
        Dump.addMapRtxSsrcConsumerId(builder, mapRtxSsrcConsumerId);
        Dump.addDataProducerIds(builder, dataProducerIds);
        Dump.addDataConsumerIds(builder, dataConsumerIds);
        Dump.addRecvRtpHeaderExtensions(builder, recvRtpHeaderExtensions);
        Dump.addRtpListener(builder, rtpListener);
        Dump.addMaxMessageSize(builder, this.maxMessageSize);
        Dump.addSctpParameters(builder, sctpParameters);
        if (this.sctpState !== null)
            Dump.addSctpState(builder, this.sctpState);
        Dump.addSctpListener(builder, sctpListener);
        Dump.addTraceEventTypes(builder, traceEventTypes);
        return Dump.endDump(builder);
    }
}
exports.DumpT = DumpT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/enable-trace-event-request.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/enable-trace-event-request.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnableTraceEventRequestT = exports.EnableTraceEventRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class EnableTraceEventRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEnableTraceEventRequest(bb, obj) {
        return (obj || new EnableTraceEventRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEnableTraceEventRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EnableTraceEventRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    events(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    eventsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    eventsArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startEnableTraceEventRequest(builder) {
        builder.startObject(1);
    }
    static addEvents(builder, eventsOffset) {
        builder.addFieldOffset(0, eventsOffset, 0);
    }
    static createEventsVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startEventsVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endEnableTraceEventRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // events
        return offset;
    }
    static createEnableTraceEventRequest(builder, eventsOffset) {
        EnableTraceEventRequest.startEnableTraceEventRequest(builder);
        EnableTraceEventRequest.addEvents(builder, eventsOffset);
        return EnableTraceEventRequest.endEnableTraceEventRequest(builder);
    }
    unpack() {
        return new EnableTraceEventRequestT(this.bb.createScalarList(this.events.bind(this), this.eventsLength()));
    }
    unpackTo(_o) {
        _o.events = this.bb.createScalarList(this.events.bind(this), this.eventsLength());
    }
}
exports.EnableTraceEventRequest = EnableTraceEventRequest;
class EnableTraceEventRequestT {
    events;
    constructor(events = []) {
        this.events = events;
    }
    pack(builder) {
        const events = EnableTraceEventRequest.createEventsVector(builder, this.events);
        return EnableTraceEventRequest.createEnableTraceEventRequest(builder, events);
    }
}
exports.EnableTraceEventRequestT = EnableTraceEventRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/listen-info.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/listen-info.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListenInfoT = exports.ListenInfo = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const protocol_1 = __webpack_require__(/*! ../../fbs/transport/protocol */ "../../node_modules/mediasoup/node/lib/fbs/transport/protocol.js");
const socket_flags_1 = __webpack_require__(/*! ../../fbs/transport/socket-flags */ "../../node_modules/mediasoup/node/lib/fbs/transport/socket-flags.js");
class ListenInfo {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsListenInfo(bb, obj) {
        return (obj || new ListenInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsListenInfo(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ListenInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    protocol() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : protocol_1.Protocol.UDP;
    }
    ip(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    announcedAddress(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    port() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    flags(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new socket_flags_1.SocketFlags()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    sendBufferSize() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    recvBufferSize() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startListenInfo(builder) {
        builder.startObject(7);
    }
    static addProtocol(builder, protocol) {
        builder.addFieldInt8(0, protocol, protocol_1.Protocol.UDP);
    }
    static addIp(builder, ipOffset) {
        builder.addFieldOffset(1, ipOffset, 0);
    }
    static addAnnouncedAddress(builder, announcedAddressOffset) {
        builder.addFieldOffset(2, announcedAddressOffset, 0);
    }
    static addPort(builder, port) {
        builder.addFieldInt16(3, port, 0);
    }
    static addFlags(builder, flagsOffset) {
        builder.addFieldOffset(4, flagsOffset, 0);
    }
    static addSendBufferSize(builder, sendBufferSize) {
        builder.addFieldInt32(5, sendBufferSize, 0);
    }
    static addRecvBufferSize(builder, recvBufferSize) {
        builder.addFieldInt32(6, recvBufferSize, 0);
    }
    static endListenInfo(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // ip
        builder.requiredField(offset, 12); // flags
        return offset;
    }
    unpack() {
        return new ListenInfoT(this.protocol(), this.ip(), this.announcedAddress(), this.port(), (this.flags() !== null ? this.flags().unpack() : null), this.sendBufferSize(), this.recvBufferSize());
    }
    unpackTo(_o) {
        _o.protocol = this.protocol();
        _o.ip = this.ip();
        _o.announcedAddress = this.announcedAddress();
        _o.port = this.port();
        _o.flags = (this.flags() !== null ? this.flags().unpack() : null);
        _o.sendBufferSize = this.sendBufferSize();
        _o.recvBufferSize = this.recvBufferSize();
    }
}
exports.ListenInfo = ListenInfo;
class ListenInfoT {
    protocol;
    ip;
    announcedAddress;
    port;
    flags;
    sendBufferSize;
    recvBufferSize;
    constructor(protocol = protocol_1.Protocol.UDP, ip = null, announcedAddress = null, port = 0, flags = null, sendBufferSize = 0, recvBufferSize = 0) {
        this.protocol = protocol;
        this.ip = ip;
        this.announcedAddress = announcedAddress;
        this.port = port;
        this.flags = flags;
        this.sendBufferSize = sendBufferSize;
        this.recvBufferSize = recvBufferSize;
    }
    pack(builder) {
        const ip = (this.ip !== null ? builder.createString(this.ip) : 0);
        const announcedAddress = (this.announcedAddress !== null ? builder.createString(this.announcedAddress) : 0);
        const flags = (this.flags !== null ? this.flags.pack(builder) : 0);
        ListenInfo.startListenInfo(builder);
        ListenInfo.addProtocol(builder, this.protocol);
        ListenInfo.addIp(builder, ip);
        ListenInfo.addAnnouncedAddress(builder, announcedAddress);
        ListenInfo.addPort(builder, this.port);
        ListenInfo.addFlags(builder, flags);
        ListenInfo.addSendBufferSize(builder, this.sendBufferSize);
        ListenInfo.addRecvBufferSize(builder, this.recvBufferSize);
        return ListenInfo.endListenInfo(builder);
    }
}
exports.ListenInfoT = ListenInfoT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/options.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/options.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OptionsT = exports.Options = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const num_sctp_streams_1 = __webpack_require__(/*! ../../fbs/sctp-parameters/num-sctp-streams */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/num-sctp-streams.js");
class Options {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsOptions(bb, obj) {
        return (obj || new Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsOptions(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    direct() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Only needed for DirectTransport. This value is handled by base Transport.
     */
    maxMessageSize() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    initialAvailableOutgoingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    enableSctp() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    numSctpStreams(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new num_sctp_streams_1.NumSctpStreams()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    maxSctpMessageSize() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    sctpSendBufferSize() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    isDataChannel() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startOptions(builder) {
        builder.startObject(8);
    }
    static addDirect(builder, direct) {
        builder.addFieldInt8(0, +direct, +false);
    }
    static addMaxMessageSize(builder, maxMessageSize) {
        builder.addFieldInt32(1, maxMessageSize, 0);
    }
    static addInitialAvailableOutgoingBitrate(builder, initialAvailableOutgoingBitrate) {
        builder.addFieldInt32(2, initialAvailableOutgoingBitrate, 0);
    }
    static addEnableSctp(builder, enableSctp) {
        builder.addFieldInt8(3, +enableSctp, +false);
    }
    static addNumSctpStreams(builder, numSctpStreamsOffset) {
        builder.addFieldOffset(4, numSctpStreamsOffset, 0);
    }
    static addMaxSctpMessageSize(builder, maxSctpMessageSize) {
        builder.addFieldInt32(5, maxSctpMessageSize, 0);
    }
    static addSctpSendBufferSize(builder, sctpSendBufferSize) {
        builder.addFieldInt32(6, sctpSendBufferSize, 0);
    }
    static addIsDataChannel(builder, isDataChannel) {
        builder.addFieldInt8(7, +isDataChannel, +false);
    }
    static endOptions(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new OptionsT(this.direct(), this.maxMessageSize(), this.initialAvailableOutgoingBitrate(), this.enableSctp(), (this.numSctpStreams() !== null ? this.numSctpStreams().unpack() : null), this.maxSctpMessageSize(), this.sctpSendBufferSize(), this.isDataChannel());
    }
    unpackTo(_o) {
        _o.direct = this.direct();
        _o.maxMessageSize = this.maxMessageSize();
        _o.initialAvailableOutgoingBitrate = this.initialAvailableOutgoingBitrate();
        _o.enableSctp = this.enableSctp();
        _o.numSctpStreams = (this.numSctpStreams() !== null ? this.numSctpStreams().unpack() : null);
        _o.maxSctpMessageSize = this.maxSctpMessageSize();
        _o.sctpSendBufferSize = this.sctpSendBufferSize();
        _o.isDataChannel = this.isDataChannel();
    }
}
exports.Options = Options;
class OptionsT {
    direct;
    maxMessageSize;
    initialAvailableOutgoingBitrate;
    enableSctp;
    numSctpStreams;
    maxSctpMessageSize;
    sctpSendBufferSize;
    isDataChannel;
    constructor(direct = false, maxMessageSize = null, initialAvailableOutgoingBitrate = null, enableSctp = false, numSctpStreams = null, maxSctpMessageSize = 0, sctpSendBufferSize = 0, isDataChannel = false) {
        this.direct = direct;
        this.maxMessageSize = maxMessageSize;
        this.initialAvailableOutgoingBitrate = initialAvailableOutgoingBitrate;
        this.enableSctp = enableSctp;
        this.numSctpStreams = numSctpStreams;
        this.maxSctpMessageSize = maxSctpMessageSize;
        this.sctpSendBufferSize = sctpSendBufferSize;
        this.isDataChannel = isDataChannel;
    }
    pack(builder) {
        const numSctpStreams = (this.numSctpStreams !== null ? this.numSctpStreams.pack(builder) : 0);
        Options.startOptions(builder);
        Options.addDirect(builder, this.direct);
        if (this.maxMessageSize !== null)
            Options.addMaxMessageSize(builder, this.maxMessageSize);
        if (this.initialAvailableOutgoingBitrate !== null)
            Options.addInitialAvailableOutgoingBitrate(builder, this.initialAvailableOutgoingBitrate);
        Options.addEnableSctp(builder, this.enableSctp);
        Options.addNumSctpStreams(builder, numSctpStreams);
        Options.addMaxSctpMessageSize(builder, this.maxSctpMessageSize);
        Options.addSctpSendBufferSize(builder, this.sctpSendBufferSize);
        Options.addIsDataChannel(builder, this.isDataChannel);
        return Options.endOptions(builder);
    }
}
exports.OptionsT = OptionsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-data-request.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/produce-data-request.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProduceDataRequestT = exports.ProduceDataRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const type_1 = __webpack_require__(/*! ../../fbs/data-producer/type */ "../../node_modules/mediasoup/node/lib/fbs/data-producer/type.js");
const sctp_stream_parameters_1 = __webpack_require__(/*! ../../fbs/sctp-parameters/sctp-stream-parameters */ "../../node_modules/mediasoup/node/lib/fbs/sctp-parameters/sctp-stream-parameters.js");
class ProduceDataRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsProduceDataRequest(bb, obj) {
        return (obj || new ProduceDataRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsProduceDataRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ProduceDataRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dataProducerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_1.Type.SCTP;
    }
    sctpStreamParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new sctp_stream_parameters_1.SctpStreamParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    label(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    protocol(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startProduceDataRequest(builder) {
        builder.startObject(6);
    }
    static addDataProducerId(builder, dataProducerIdOffset) {
        builder.addFieldOffset(0, dataProducerIdOffset, 0);
    }
    static addType(builder, type) {
        builder.addFieldInt8(1, type, type_1.Type.SCTP);
    }
    static addSctpStreamParameters(builder, sctpStreamParametersOffset) {
        builder.addFieldOffset(2, sctpStreamParametersOffset, 0);
    }
    static addLabel(builder, labelOffset) {
        builder.addFieldOffset(3, labelOffset, 0);
    }
    static addProtocol(builder, protocolOffset) {
        builder.addFieldOffset(4, protocolOffset, 0);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(5, +paused, +false);
    }
    static endProduceDataRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data_producer_id
        return offset;
    }
    unpack() {
        return new ProduceDataRequestT(this.dataProducerId(), this.type(), (this.sctpStreamParameters() !== null ? this.sctpStreamParameters().unpack() : null), this.label(), this.protocol(), this.paused());
    }
    unpackTo(_o) {
        _o.dataProducerId = this.dataProducerId();
        _o.type = this.type();
        _o.sctpStreamParameters = (this.sctpStreamParameters() !== null ? this.sctpStreamParameters().unpack() : null);
        _o.label = this.label();
        _o.protocol = this.protocol();
        _o.paused = this.paused();
    }
}
exports.ProduceDataRequest = ProduceDataRequest;
class ProduceDataRequestT {
    dataProducerId;
    type;
    sctpStreamParameters;
    label;
    protocol;
    paused;
    constructor(dataProducerId = null, type = type_1.Type.SCTP, sctpStreamParameters = null, label = null, protocol = null, paused = false) {
        this.dataProducerId = dataProducerId;
        this.type = type;
        this.sctpStreamParameters = sctpStreamParameters;
        this.label = label;
        this.protocol = protocol;
        this.paused = paused;
    }
    pack(builder) {
        const dataProducerId = (this.dataProducerId !== null ? builder.createString(this.dataProducerId) : 0);
        const sctpStreamParameters = (this.sctpStreamParameters !== null ? this.sctpStreamParameters.pack(builder) : 0);
        const label = (this.label !== null ? builder.createString(this.label) : 0);
        const protocol = (this.protocol !== null ? builder.createString(this.protocol) : 0);
        ProduceDataRequest.startProduceDataRequest(builder);
        ProduceDataRequest.addDataProducerId(builder, dataProducerId);
        ProduceDataRequest.addType(builder, this.type);
        ProduceDataRequest.addSctpStreamParameters(builder, sctpStreamParameters);
        ProduceDataRequest.addLabel(builder, label);
        ProduceDataRequest.addProtocol(builder, protocol);
        ProduceDataRequest.addPaused(builder, this.paused);
        return ProduceDataRequest.endProduceDataRequest(builder);
    }
}
exports.ProduceDataRequestT = ProduceDataRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-request.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/produce-request.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProduceRequestT = exports.ProduceRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const media_kind_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/media-kind */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/media-kind.js");
const rtp_mapping_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-mapping */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-mapping.js");
const rtp_parameters_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/rtp-parameters.js");
class ProduceRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsProduceRequest(bb, obj) {
        return (obj || new ProduceRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsProduceRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ProduceRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    producerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    kind() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : media_kind_1.MediaKind.AUDIO;
    }
    rtpParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new rtp_parameters_1.RtpParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    rtpMapping(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new rtp_mapping_1.RtpMapping()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    keyFrameRequestDelay() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    paused() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startProduceRequest(builder) {
        builder.startObject(6);
    }
    static addProducerId(builder, producerIdOffset) {
        builder.addFieldOffset(0, producerIdOffset, 0);
    }
    static addKind(builder, kind) {
        builder.addFieldInt8(1, kind, media_kind_1.MediaKind.AUDIO);
    }
    static addRtpParameters(builder, rtpParametersOffset) {
        builder.addFieldOffset(2, rtpParametersOffset, 0);
    }
    static addRtpMapping(builder, rtpMappingOffset) {
        builder.addFieldOffset(3, rtpMappingOffset, 0);
    }
    static addKeyFrameRequestDelay(builder, keyFrameRequestDelay) {
        builder.addFieldInt32(4, keyFrameRequestDelay, 0);
    }
    static addPaused(builder, paused) {
        builder.addFieldInt8(5, +paused, +false);
    }
    static endProduceRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // producer_id
        builder.requiredField(offset, 8); // rtp_parameters
        builder.requiredField(offset, 10); // rtp_mapping
        return offset;
    }
    unpack() {
        return new ProduceRequestT(this.producerId(), this.kind(), (this.rtpParameters() !== null ? this.rtpParameters().unpack() : null), (this.rtpMapping() !== null ? this.rtpMapping().unpack() : null), this.keyFrameRequestDelay(), this.paused());
    }
    unpackTo(_o) {
        _o.producerId = this.producerId();
        _o.kind = this.kind();
        _o.rtpParameters = (this.rtpParameters() !== null ? this.rtpParameters().unpack() : null);
        _o.rtpMapping = (this.rtpMapping() !== null ? this.rtpMapping().unpack() : null);
        _o.keyFrameRequestDelay = this.keyFrameRequestDelay();
        _o.paused = this.paused();
    }
}
exports.ProduceRequest = ProduceRequest;
class ProduceRequestT {
    producerId;
    kind;
    rtpParameters;
    rtpMapping;
    keyFrameRequestDelay;
    paused;
    constructor(producerId = null, kind = media_kind_1.MediaKind.AUDIO, rtpParameters = null, rtpMapping = null, keyFrameRequestDelay = 0, paused = false) {
        this.producerId = producerId;
        this.kind = kind;
        this.rtpParameters = rtpParameters;
        this.rtpMapping = rtpMapping;
        this.keyFrameRequestDelay = keyFrameRequestDelay;
        this.paused = paused;
    }
    pack(builder) {
        const producerId = (this.producerId !== null ? builder.createString(this.producerId) : 0);
        const rtpParameters = (this.rtpParameters !== null ? this.rtpParameters.pack(builder) : 0);
        const rtpMapping = (this.rtpMapping !== null ? this.rtpMapping.pack(builder) : 0);
        ProduceRequest.startProduceRequest(builder);
        ProduceRequest.addProducerId(builder, producerId);
        ProduceRequest.addKind(builder, this.kind);
        ProduceRequest.addRtpParameters(builder, rtpParameters);
        ProduceRequest.addRtpMapping(builder, rtpMapping);
        ProduceRequest.addKeyFrameRequestDelay(builder, this.keyFrameRequestDelay);
        ProduceRequest.addPaused(builder, this.paused);
        return ProduceRequest.endProduceRequest(builder);
    }
}
exports.ProduceRequestT = ProduceRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/produce-response.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/produce-response.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProduceResponseT = exports.ProduceResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const type_1 = __webpack_require__(/*! ../../fbs/rtp-parameters/type */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters/type.js");
class ProduceResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsProduceResponse(bb, obj) {
        return (obj || new ProduceResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsProduceResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ProduceResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_1.Type.SIMPLE;
    }
    static startProduceResponse(builder) {
        builder.startObject(1);
    }
    static addType(builder, type) {
        builder.addFieldInt8(0, type, type_1.Type.SIMPLE);
    }
    static endProduceResponse(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createProduceResponse(builder, type) {
        ProduceResponse.startProduceResponse(builder);
        ProduceResponse.addType(builder, type);
        return ProduceResponse.endProduceResponse(builder);
    }
    unpack() {
        return new ProduceResponseT(this.type());
    }
    unpackTo(_o) {
        _o.type = this.type();
    }
}
exports.ProduceResponse = ProduceResponse;
class ProduceResponseT {
    type;
    constructor(type = type_1.Type.SIMPLE) {
        this.type = type;
    }
    pack(builder) {
        return ProduceResponse.createProduceResponse(builder, this.type);
    }
}
exports.ProduceResponseT = ProduceResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/protocol.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/protocol.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Protocol = void 0;
var Protocol;
(function (Protocol) {
    Protocol[Protocol["UDP"] = 1] = "UDP";
    Protocol[Protocol["TCP"] = 2] = "TCP";
})(Protocol || (exports.Protocol = Protocol = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/recv-rtp-header-extensions.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/recv-rtp-header-extensions.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecvRtpHeaderExtensionsT = exports.RecvRtpHeaderExtensions = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RecvRtpHeaderExtensions {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRecvRtpHeaderExtensions(bb, obj) {
        return (obj || new RecvRtpHeaderExtensions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecvRtpHeaderExtensions(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RecvRtpHeaderExtensions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mid() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    rid() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    rrid() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    absSendTime() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    transportWideCc01() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    static startRecvRtpHeaderExtensions(builder) {
        builder.startObject(5);
    }
    static addMid(builder, mid) {
        builder.addFieldInt8(0, mid, 0);
    }
    static addRid(builder, rid) {
        builder.addFieldInt8(1, rid, 0);
    }
    static addRrid(builder, rrid) {
        builder.addFieldInt8(2, rrid, 0);
    }
    static addAbsSendTime(builder, absSendTime) {
        builder.addFieldInt8(3, absSendTime, 0);
    }
    static addTransportWideCc01(builder, transportWideCc01) {
        builder.addFieldInt8(4, transportWideCc01, 0);
    }
    static endRecvRtpHeaderExtensions(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRecvRtpHeaderExtensions(builder, mid, rid, rrid, absSendTime, transportWideCc01) {
        RecvRtpHeaderExtensions.startRecvRtpHeaderExtensions(builder);
        if (mid !== null)
            RecvRtpHeaderExtensions.addMid(builder, mid);
        if (rid !== null)
            RecvRtpHeaderExtensions.addRid(builder, rid);
        if (rrid !== null)
            RecvRtpHeaderExtensions.addRrid(builder, rrid);
        if (absSendTime !== null)
            RecvRtpHeaderExtensions.addAbsSendTime(builder, absSendTime);
        if (transportWideCc01 !== null)
            RecvRtpHeaderExtensions.addTransportWideCc01(builder, transportWideCc01);
        return RecvRtpHeaderExtensions.endRecvRtpHeaderExtensions(builder);
    }
    unpack() {
        return new RecvRtpHeaderExtensionsT(this.mid(), this.rid(), this.rrid(), this.absSendTime(), this.transportWideCc01());
    }
    unpackTo(_o) {
        _o.mid = this.mid();
        _o.rid = this.rid();
        _o.rrid = this.rrid();
        _o.absSendTime = this.absSendTime();
        _o.transportWideCc01 = this.transportWideCc01();
    }
}
exports.RecvRtpHeaderExtensions = RecvRtpHeaderExtensions;
class RecvRtpHeaderExtensionsT {
    mid;
    rid;
    rrid;
    absSendTime;
    transportWideCc01;
    constructor(mid = null, rid = null, rrid = null, absSendTime = null, transportWideCc01 = null) {
        this.mid = mid;
        this.rid = rid;
        this.rrid = rrid;
        this.absSendTime = absSendTime;
        this.transportWideCc01 = transportWideCc01;
    }
    pack(builder) {
        return RecvRtpHeaderExtensions.createRecvRtpHeaderExtensions(builder, this.mid, this.rid, this.rrid, this.absSendTime, this.transportWideCc01);
    }
}
exports.RecvRtpHeaderExtensionsT = RecvRtpHeaderExtensionsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/restart-ice-response.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/restart-ice-response.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RestartIceResponseT = exports.RestartIceResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class RestartIceResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRestartIceResponse(bb, obj) {
        return (obj || new RestartIceResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRestartIceResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RestartIceResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    usernameFragment(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    password(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    iceLite() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startRestartIceResponse(builder) {
        builder.startObject(3);
    }
    static addUsernameFragment(builder, usernameFragmentOffset) {
        builder.addFieldOffset(0, usernameFragmentOffset, 0);
    }
    static addPassword(builder, passwordOffset) {
        builder.addFieldOffset(1, passwordOffset, 0);
    }
    static addIceLite(builder, iceLite) {
        builder.addFieldInt8(2, +iceLite, +false);
    }
    static endRestartIceResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // username_fragment
        builder.requiredField(offset, 6); // password
        return offset;
    }
    static createRestartIceResponse(builder, usernameFragmentOffset, passwordOffset, iceLite) {
        RestartIceResponse.startRestartIceResponse(builder);
        RestartIceResponse.addUsernameFragment(builder, usernameFragmentOffset);
        RestartIceResponse.addPassword(builder, passwordOffset);
        RestartIceResponse.addIceLite(builder, iceLite);
        return RestartIceResponse.endRestartIceResponse(builder);
    }
    unpack() {
        return new RestartIceResponseT(this.usernameFragment(), this.password(), this.iceLite());
    }
    unpackTo(_o) {
        _o.usernameFragment = this.usernameFragment();
        _o.password = this.password();
        _o.iceLite = this.iceLite();
    }
}
exports.RestartIceResponse = RestartIceResponse;
class RestartIceResponseT {
    usernameFragment;
    password;
    iceLite;
    constructor(usernameFragment = null, password = null, iceLite = false) {
        this.usernameFragment = usernameFragment;
        this.password = password;
        this.iceLite = iceLite;
    }
    pack(builder) {
        const usernameFragment = (this.usernameFragment !== null ? builder.createString(this.usernameFragment) : 0);
        const password = (this.password !== null ? builder.createString(this.password) : 0);
        return RestartIceResponse.createRestartIceResponse(builder, usernameFragment, password, this.iceLite);
    }
}
exports.RestartIceResponseT = RestartIceResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/rtp-listener.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/rtp-listener.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RtpListenerT = exports.RtpListener = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const string_string_1 = __webpack_require__(/*! ../../fbs/common/string-string */ "../../node_modules/mediasoup/node/lib/fbs/common/string-string.js");
const uint32_string_1 = __webpack_require__(/*! ../../fbs/common/uint32-string */ "../../node_modules/mediasoup/node/lib/fbs/common/uint32-string.js");
class RtpListener {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRtpListener(bb, obj) {
        return (obj || new RtpListener()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRtpListener(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RtpListener()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ssrcTable(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new uint32_string_1.Uint32String()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    ssrcTableLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    midTable(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new string_string_1.StringString()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    midTableLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    ridTable(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new string_string_1.StringString()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    ridTableLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRtpListener(builder) {
        builder.startObject(3);
    }
    static addSsrcTable(builder, ssrcTableOffset) {
        builder.addFieldOffset(0, ssrcTableOffset, 0);
    }
    static createSsrcTableVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startSsrcTableVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addMidTable(builder, midTableOffset) {
        builder.addFieldOffset(1, midTableOffset, 0);
    }
    static createMidTableVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startMidTableVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRidTable(builder, ridTableOffset) {
        builder.addFieldOffset(2, ridTableOffset, 0);
    }
    static createRidTableVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRidTableVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRtpListener(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // ssrc_table
        builder.requiredField(offset, 6); // mid_table
        builder.requiredField(offset, 8); // rid_table
        return offset;
    }
    static createRtpListener(builder, ssrcTableOffset, midTableOffset, ridTableOffset) {
        RtpListener.startRtpListener(builder);
        RtpListener.addSsrcTable(builder, ssrcTableOffset);
        RtpListener.addMidTable(builder, midTableOffset);
        RtpListener.addRidTable(builder, ridTableOffset);
        return RtpListener.endRtpListener(builder);
    }
    unpack() {
        return new RtpListenerT(this.bb.createObjList(this.ssrcTable.bind(this), this.ssrcTableLength()), this.bb.createObjList(this.midTable.bind(this), this.midTableLength()), this.bb.createObjList(this.ridTable.bind(this), this.ridTableLength()));
    }
    unpackTo(_o) {
        _o.ssrcTable = this.bb.createObjList(this.ssrcTable.bind(this), this.ssrcTableLength());
        _o.midTable = this.bb.createObjList(this.midTable.bind(this), this.midTableLength());
        _o.ridTable = this.bb.createObjList(this.ridTable.bind(this), this.ridTableLength());
    }
}
exports.RtpListener = RtpListener;
class RtpListenerT {
    ssrcTable;
    midTable;
    ridTable;
    constructor(ssrcTable = [], midTable = [], ridTable = []) {
        this.ssrcTable = ssrcTable;
        this.midTable = midTable;
        this.ridTable = ridTable;
    }
    pack(builder) {
        const ssrcTable = RtpListener.createSsrcTableVector(builder, builder.createObjectOffsetList(this.ssrcTable));
        const midTable = RtpListener.createMidTableVector(builder, builder.createObjectOffsetList(this.midTable));
        const ridTable = RtpListener.createRidTableVector(builder, builder.createObjectOffsetList(this.ridTable));
        return RtpListener.createRtpListener(builder, ssrcTable, midTable, ridTable);
    }
}
exports.RtpListenerT = RtpListenerT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/sctp-listener.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/sctp-listener.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SctpListenerT = exports.SctpListener = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const uint16_string_1 = __webpack_require__(/*! ../../fbs/common/uint16-string */ "../../node_modules/mediasoup/node/lib/fbs/common/uint16-string.js");
class SctpListener {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSctpListener(bb, obj) {
        return (obj || new SctpListener()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSctpListener(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SctpListener()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    streamIdTable(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new uint16_string_1.Uint16String()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    streamIdTableLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSctpListener(builder) {
        builder.startObject(1);
    }
    static addStreamIdTable(builder, streamIdTableOffset) {
        builder.addFieldOffset(0, streamIdTableOffset, 0);
    }
    static createStreamIdTableVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startStreamIdTableVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endSctpListener(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // stream_id_table
        return offset;
    }
    static createSctpListener(builder, streamIdTableOffset) {
        SctpListener.startSctpListener(builder);
        SctpListener.addStreamIdTable(builder, streamIdTableOffset);
        return SctpListener.endSctpListener(builder);
    }
    unpack() {
        return new SctpListenerT(this.bb.createObjList(this.streamIdTable.bind(this), this.streamIdTableLength()));
    }
    unpackTo(_o) {
        _o.streamIdTable = this.bb.createObjList(this.streamIdTable.bind(this), this.streamIdTableLength());
    }
}
exports.SctpListener = SctpListener;
class SctpListenerT {
    streamIdTable;
    constructor(streamIdTable = []) {
        this.streamIdTable = streamIdTable;
    }
    pack(builder) {
        const streamIdTable = SctpListener.createStreamIdTableVector(builder, builder.createObjectOffsetList(this.streamIdTable));
        return SctpListener.createSctpListener(builder, streamIdTable);
    }
}
exports.SctpListenerT = SctpListenerT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/sctp-state-change-notification.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/sctp-state-change-notification.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SctpStateChangeNotificationT = exports.SctpStateChangeNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const sctp_state_1 = __webpack_require__(/*! ../../fbs/sctp-association/sctp-state */ "../../node_modules/mediasoup/node/lib/fbs/sctp-association/sctp-state.js");
class SctpStateChangeNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSctpStateChangeNotification(bb, obj) {
        return (obj || new SctpStateChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSctpStateChangeNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SctpStateChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    sctpState() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : sctp_state_1.SctpState.NEW;
    }
    static startSctpStateChangeNotification(builder) {
        builder.startObject(1);
    }
    static addSctpState(builder, sctpState) {
        builder.addFieldInt8(0, sctpState, sctp_state_1.SctpState.NEW);
    }
    static endSctpStateChangeNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSctpStateChangeNotification(builder, sctpState) {
        SctpStateChangeNotification.startSctpStateChangeNotification(builder);
        SctpStateChangeNotification.addSctpState(builder, sctpState);
        return SctpStateChangeNotification.endSctpStateChangeNotification(builder);
    }
    unpack() {
        return new SctpStateChangeNotificationT(this.sctpState());
    }
    unpackTo(_o) {
        _o.sctpState = this.sctpState();
    }
}
exports.SctpStateChangeNotification = SctpStateChangeNotification;
class SctpStateChangeNotificationT {
    sctpState;
    constructor(sctpState = sctp_state_1.SctpState.NEW) {
        this.sctpState = sctpState;
    }
    pack(builder) {
        return SctpStateChangeNotification.createSctpStateChangeNotification(builder, this.sctpState);
    }
}
exports.SctpStateChangeNotificationT = SctpStateChangeNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/send-rtcp-notification.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/send-rtcp-notification.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendRtcpNotificationT = exports.SendRtcpNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SendRtcpNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSendRtcpNotification(bb, obj) {
        return (obj || new SendRtcpNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSendRtcpNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SendRtcpNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    data(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSendRtcpNotification(builder) {
        builder.startObject(1);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(0, dataOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endSendRtcpNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // data
        return offset;
    }
    static createSendRtcpNotification(builder, dataOffset) {
        SendRtcpNotification.startSendRtcpNotification(builder);
        SendRtcpNotification.addData(builder, dataOffset);
        return SendRtcpNotification.endSendRtcpNotification(builder);
    }
    unpack() {
        return new SendRtcpNotificationT(this.bb.createScalarList(this.data.bind(this), this.dataLength()));
    }
    unpackTo(_o) {
        _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());
    }
}
exports.SendRtcpNotification = SendRtcpNotification;
class SendRtcpNotificationT {
    data;
    constructor(data = []) {
        this.data = data;
    }
    pack(builder) {
        const data = SendRtcpNotification.createDataVector(builder, this.data);
        return SendRtcpNotification.createSendRtcpNotification(builder, data);
    }
}
exports.SendRtcpNotificationT = SendRtcpNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/set-max-incoming-bitrate-request.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/set-max-incoming-bitrate-request.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetMaxIncomingBitrateRequestT = exports.SetMaxIncomingBitrateRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SetMaxIncomingBitrateRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetMaxIncomingBitrateRequest(bb, obj) {
        return (obj || new SetMaxIncomingBitrateRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetMaxIncomingBitrateRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetMaxIncomingBitrateRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    maxIncomingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startSetMaxIncomingBitrateRequest(builder) {
        builder.startObject(1);
    }
    static addMaxIncomingBitrate(builder, maxIncomingBitrate) {
        builder.addFieldInt32(0, maxIncomingBitrate, 0);
    }
    static endSetMaxIncomingBitrateRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSetMaxIncomingBitrateRequest(builder, maxIncomingBitrate) {
        SetMaxIncomingBitrateRequest.startSetMaxIncomingBitrateRequest(builder);
        SetMaxIncomingBitrateRequest.addMaxIncomingBitrate(builder, maxIncomingBitrate);
        return SetMaxIncomingBitrateRequest.endSetMaxIncomingBitrateRequest(builder);
    }
    unpack() {
        return new SetMaxIncomingBitrateRequestT(this.maxIncomingBitrate());
    }
    unpackTo(_o) {
        _o.maxIncomingBitrate = this.maxIncomingBitrate();
    }
}
exports.SetMaxIncomingBitrateRequest = SetMaxIncomingBitrateRequest;
class SetMaxIncomingBitrateRequestT {
    maxIncomingBitrate;
    constructor(maxIncomingBitrate = 0) {
        this.maxIncomingBitrate = maxIncomingBitrate;
    }
    pack(builder) {
        return SetMaxIncomingBitrateRequest.createSetMaxIncomingBitrateRequest(builder, this.maxIncomingBitrate);
    }
}
exports.SetMaxIncomingBitrateRequestT = SetMaxIncomingBitrateRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/set-max-outgoing-bitrate-request.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/set-max-outgoing-bitrate-request.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetMaxOutgoingBitrateRequestT = exports.SetMaxOutgoingBitrateRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SetMaxOutgoingBitrateRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetMaxOutgoingBitrateRequest(bb, obj) {
        return (obj || new SetMaxOutgoingBitrateRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetMaxOutgoingBitrateRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetMaxOutgoingBitrateRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    maxOutgoingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startSetMaxOutgoingBitrateRequest(builder) {
        builder.startObject(1);
    }
    static addMaxOutgoingBitrate(builder, maxOutgoingBitrate) {
        builder.addFieldInt32(0, maxOutgoingBitrate, 0);
    }
    static endSetMaxOutgoingBitrateRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSetMaxOutgoingBitrateRequest(builder, maxOutgoingBitrate) {
        SetMaxOutgoingBitrateRequest.startSetMaxOutgoingBitrateRequest(builder);
        SetMaxOutgoingBitrateRequest.addMaxOutgoingBitrate(builder, maxOutgoingBitrate);
        return SetMaxOutgoingBitrateRequest.endSetMaxOutgoingBitrateRequest(builder);
    }
    unpack() {
        return new SetMaxOutgoingBitrateRequestT(this.maxOutgoingBitrate());
    }
    unpackTo(_o) {
        _o.maxOutgoingBitrate = this.maxOutgoingBitrate();
    }
}
exports.SetMaxOutgoingBitrateRequest = SetMaxOutgoingBitrateRequest;
class SetMaxOutgoingBitrateRequestT {
    maxOutgoingBitrate;
    constructor(maxOutgoingBitrate = 0) {
        this.maxOutgoingBitrate = maxOutgoingBitrate;
    }
    pack(builder) {
        return SetMaxOutgoingBitrateRequest.createSetMaxOutgoingBitrateRequest(builder, this.maxOutgoingBitrate);
    }
}
exports.SetMaxOutgoingBitrateRequestT = SetMaxOutgoingBitrateRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/set-min-outgoing-bitrate-request.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/set-min-outgoing-bitrate-request.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetMinOutgoingBitrateRequestT = exports.SetMinOutgoingBitrateRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SetMinOutgoingBitrateRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSetMinOutgoingBitrateRequest(bb, obj) {
        return (obj || new SetMinOutgoingBitrateRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSetMinOutgoingBitrateRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SetMinOutgoingBitrateRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    minOutgoingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startSetMinOutgoingBitrateRequest(builder) {
        builder.startObject(1);
    }
    static addMinOutgoingBitrate(builder, minOutgoingBitrate) {
        builder.addFieldInt32(0, minOutgoingBitrate, 0);
    }
    static endSetMinOutgoingBitrateRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSetMinOutgoingBitrateRequest(builder, minOutgoingBitrate) {
        SetMinOutgoingBitrateRequest.startSetMinOutgoingBitrateRequest(builder);
        SetMinOutgoingBitrateRequest.addMinOutgoingBitrate(builder, minOutgoingBitrate);
        return SetMinOutgoingBitrateRequest.endSetMinOutgoingBitrateRequest(builder);
    }
    unpack() {
        return new SetMinOutgoingBitrateRequestT(this.minOutgoingBitrate());
    }
    unpackTo(_o) {
        _o.minOutgoingBitrate = this.minOutgoingBitrate();
    }
}
exports.SetMinOutgoingBitrateRequest = SetMinOutgoingBitrateRequest;
class SetMinOutgoingBitrateRequestT {
    minOutgoingBitrate;
    constructor(minOutgoingBitrate = 0) {
        this.minOutgoingBitrate = minOutgoingBitrate;
    }
    pack(builder) {
        return SetMinOutgoingBitrateRequest.createSetMinOutgoingBitrateRequest(builder, this.minOutgoingBitrate);
    }
}
exports.SetMinOutgoingBitrateRequestT = SetMinOutgoingBitrateRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/socket-flags.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/socket-flags.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SocketFlagsT = exports.SocketFlags = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class SocketFlags {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSocketFlags(bb, obj) {
        return (obj || new SocketFlags()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSocketFlags(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SocketFlags()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ipv6Only() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    udpReusePort() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startSocketFlags(builder) {
        builder.startObject(2);
    }
    static addIpv6Only(builder, ipv6Only) {
        builder.addFieldInt8(0, +ipv6Only, +false);
    }
    static addUdpReusePort(builder, udpReusePort) {
        builder.addFieldInt8(1, +udpReusePort, +false);
    }
    static endSocketFlags(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSocketFlags(builder, ipv6Only, udpReusePort) {
        SocketFlags.startSocketFlags(builder);
        SocketFlags.addIpv6Only(builder, ipv6Only);
        SocketFlags.addUdpReusePort(builder, udpReusePort);
        return SocketFlags.endSocketFlags(builder);
    }
    unpack() {
        return new SocketFlagsT(this.ipv6Only(), this.udpReusePort());
    }
    unpackTo(_o) {
        _o.ipv6Only = this.ipv6Only();
        _o.udpReusePort = this.udpReusePort();
    }
}
exports.SocketFlags = SocketFlags;
class SocketFlagsT {
    ipv6Only;
    udpReusePort;
    constructor(ipv6Only = false, udpReusePort = false) {
        this.ipv6Only = ipv6Only;
        this.udpReusePort = udpReusePort;
    }
    pack(builder) {
        return SocketFlags.createSocketFlags(builder, this.ipv6Only, this.udpReusePort);
    }
}
exports.SocketFlagsT = SocketFlagsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/stats.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/stats.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatsT = exports.Stats = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class Stats {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStats(bb, obj) {
        return (obj || new Stats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStats(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Stats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    transportId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    timestamp() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    sctpState() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    bytesReceived() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    recvBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    bytesSent() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    sendBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    rtpBytesReceived() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    rtpRecvBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    rtpBytesSent() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    rtpSendBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    rtxBytesReceived() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    rtxRecvBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    rtxBytesSent() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    rtxSendBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    probationBytesSent() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    probationSendBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    availableOutgoingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    availableIncomingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    maxIncomingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    maxOutgoingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    minOutgoingBitrate() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : null;
    }
    rtpPacketLossReceived() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : null;
    }
    rtpPacketLossSent() {
        const offset = this.bb.__offset(this.bb_pos, 50);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : null;
    }
    static startStats(builder) {
        builder.startObject(24);
    }
    static addTransportId(builder, transportIdOffset) {
        builder.addFieldOffset(0, transportIdOffset, 0);
    }
    static addTimestamp(builder, timestamp) {
        builder.addFieldInt64(1, timestamp, BigInt('0'));
    }
    static addSctpState(builder, sctpState) {
        builder.addFieldInt8(2, sctpState, 0);
    }
    static addBytesReceived(builder, bytesReceived) {
        builder.addFieldInt64(3, bytesReceived, BigInt('0'));
    }
    static addRecvBitrate(builder, recvBitrate) {
        builder.addFieldInt32(4, recvBitrate, 0);
    }
    static addBytesSent(builder, bytesSent) {
        builder.addFieldInt64(5, bytesSent, BigInt('0'));
    }
    static addSendBitrate(builder, sendBitrate) {
        builder.addFieldInt32(6, sendBitrate, 0);
    }
    static addRtpBytesReceived(builder, rtpBytesReceived) {
        builder.addFieldInt64(7, rtpBytesReceived, BigInt('0'));
    }
    static addRtpRecvBitrate(builder, rtpRecvBitrate) {
        builder.addFieldInt32(8, rtpRecvBitrate, 0);
    }
    static addRtpBytesSent(builder, rtpBytesSent) {
        builder.addFieldInt64(9, rtpBytesSent, BigInt('0'));
    }
    static addRtpSendBitrate(builder, rtpSendBitrate) {
        builder.addFieldInt32(10, rtpSendBitrate, 0);
    }
    static addRtxBytesReceived(builder, rtxBytesReceived) {
        builder.addFieldInt64(11, rtxBytesReceived, BigInt('0'));
    }
    static addRtxRecvBitrate(builder, rtxRecvBitrate) {
        builder.addFieldInt32(12, rtxRecvBitrate, 0);
    }
    static addRtxBytesSent(builder, rtxBytesSent) {
        builder.addFieldInt64(13, rtxBytesSent, BigInt('0'));
    }
    static addRtxSendBitrate(builder, rtxSendBitrate) {
        builder.addFieldInt32(14, rtxSendBitrate, 0);
    }
    static addProbationBytesSent(builder, probationBytesSent) {
        builder.addFieldInt64(15, probationBytesSent, BigInt('0'));
    }
    static addProbationSendBitrate(builder, probationSendBitrate) {
        builder.addFieldInt32(16, probationSendBitrate, 0);
    }
    static addAvailableOutgoingBitrate(builder, availableOutgoingBitrate) {
        builder.addFieldInt32(17, availableOutgoingBitrate, 0);
    }
    static addAvailableIncomingBitrate(builder, availableIncomingBitrate) {
        builder.addFieldInt32(18, availableIncomingBitrate, 0);
    }
    static addMaxIncomingBitrate(builder, maxIncomingBitrate) {
        builder.addFieldInt32(19, maxIncomingBitrate, 0);
    }
    static addMaxOutgoingBitrate(builder, maxOutgoingBitrate) {
        builder.addFieldInt32(20, maxOutgoingBitrate, 0);
    }
    static addMinOutgoingBitrate(builder, minOutgoingBitrate) {
        builder.addFieldInt32(21, minOutgoingBitrate, 0);
    }
    static addRtpPacketLossReceived(builder, rtpPacketLossReceived) {
        builder.addFieldFloat64(22, rtpPacketLossReceived, 0);
    }
    static addRtpPacketLossSent(builder, rtpPacketLossSent) {
        builder.addFieldFloat64(23, rtpPacketLossSent, 0);
    }
    static endStats(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // transport_id
        return offset;
    }
    static createStats(builder, transportIdOffset, timestamp, sctpState, bytesReceived, recvBitrate, bytesSent, sendBitrate, rtpBytesReceived, rtpRecvBitrate, rtpBytesSent, rtpSendBitrate, rtxBytesReceived, rtxRecvBitrate, rtxBytesSent, rtxSendBitrate, probationBytesSent, probationSendBitrate, availableOutgoingBitrate, availableIncomingBitrate, maxIncomingBitrate, maxOutgoingBitrate, minOutgoingBitrate, rtpPacketLossReceived, rtpPacketLossSent) {
        Stats.startStats(builder);
        Stats.addTransportId(builder, transportIdOffset);
        Stats.addTimestamp(builder, timestamp);
        if (sctpState !== null)
            Stats.addSctpState(builder, sctpState);
        Stats.addBytesReceived(builder, bytesReceived);
        Stats.addRecvBitrate(builder, recvBitrate);
        Stats.addBytesSent(builder, bytesSent);
        Stats.addSendBitrate(builder, sendBitrate);
        Stats.addRtpBytesReceived(builder, rtpBytesReceived);
        Stats.addRtpRecvBitrate(builder, rtpRecvBitrate);
        Stats.addRtpBytesSent(builder, rtpBytesSent);
        Stats.addRtpSendBitrate(builder, rtpSendBitrate);
        Stats.addRtxBytesReceived(builder, rtxBytesReceived);
        Stats.addRtxRecvBitrate(builder, rtxRecvBitrate);
        Stats.addRtxBytesSent(builder, rtxBytesSent);
        Stats.addRtxSendBitrate(builder, rtxSendBitrate);
        Stats.addProbationBytesSent(builder, probationBytesSent);
        Stats.addProbationSendBitrate(builder, probationSendBitrate);
        if (availableOutgoingBitrate !== null)
            Stats.addAvailableOutgoingBitrate(builder, availableOutgoingBitrate);
        if (availableIncomingBitrate !== null)
            Stats.addAvailableIncomingBitrate(builder, availableIncomingBitrate);
        if (maxIncomingBitrate !== null)
            Stats.addMaxIncomingBitrate(builder, maxIncomingBitrate);
        if (maxOutgoingBitrate !== null)
            Stats.addMaxOutgoingBitrate(builder, maxOutgoingBitrate);
        if (minOutgoingBitrate !== null)
            Stats.addMinOutgoingBitrate(builder, minOutgoingBitrate);
        if (rtpPacketLossReceived !== null)
            Stats.addRtpPacketLossReceived(builder, rtpPacketLossReceived);
        if (rtpPacketLossSent !== null)
            Stats.addRtpPacketLossSent(builder, rtpPacketLossSent);
        return Stats.endStats(builder);
    }
    unpack() {
        return new StatsT(this.transportId(), this.timestamp(), this.sctpState(), this.bytesReceived(), this.recvBitrate(), this.bytesSent(), this.sendBitrate(), this.rtpBytesReceived(), this.rtpRecvBitrate(), this.rtpBytesSent(), this.rtpSendBitrate(), this.rtxBytesReceived(), this.rtxRecvBitrate(), this.rtxBytesSent(), this.rtxSendBitrate(), this.probationBytesSent(), this.probationSendBitrate(), this.availableOutgoingBitrate(), this.availableIncomingBitrate(), this.maxIncomingBitrate(), this.maxOutgoingBitrate(), this.minOutgoingBitrate(), this.rtpPacketLossReceived(), this.rtpPacketLossSent());
    }
    unpackTo(_o) {
        _o.transportId = this.transportId();
        _o.timestamp = this.timestamp();
        _o.sctpState = this.sctpState();
        _o.bytesReceived = this.bytesReceived();
        _o.recvBitrate = this.recvBitrate();
        _o.bytesSent = this.bytesSent();
        _o.sendBitrate = this.sendBitrate();
        _o.rtpBytesReceived = this.rtpBytesReceived();
        _o.rtpRecvBitrate = this.rtpRecvBitrate();
        _o.rtpBytesSent = this.rtpBytesSent();
        _o.rtpSendBitrate = this.rtpSendBitrate();
        _o.rtxBytesReceived = this.rtxBytesReceived();
        _o.rtxRecvBitrate = this.rtxRecvBitrate();
        _o.rtxBytesSent = this.rtxBytesSent();
        _o.rtxSendBitrate = this.rtxSendBitrate();
        _o.probationBytesSent = this.probationBytesSent();
        _o.probationSendBitrate = this.probationSendBitrate();
        _o.availableOutgoingBitrate = this.availableOutgoingBitrate();
        _o.availableIncomingBitrate = this.availableIncomingBitrate();
        _o.maxIncomingBitrate = this.maxIncomingBitrate();
        _o.maxOutgoingBitrate = this.maxOutgoingBitrate();
        _o.minOutgoingBitrate = this.minOutgoingBitrate();
        _o.rtpPacketLossReceived = this.rtpPacketLossReceived();
        _o.rtpPacketLossSent = this.rtpPacketLossSent();
    }
}
exports.Stats = Stats;
class StatsT {
    transportId;
    timestamp;
    sctpState;
    bytesReceived;
    recvBitrate;
    bytesSent;
    sendBitrate;
    rtpBytesReceived;
    rtpRecvBitrate;
    rtpBytesSent;
    rtpSendBitrate;
    rtxBytesReceived;
    rtxRecvBitrate;
    rtxBytesSent;
    rtxSendBitrate;
    probationBytesSent;
    probationSendBitrate;
    availableOutgoingBitrate;
    availableIncomingBitrate;
    maxIncomingBitrate;
    maxOutgoingBitrate;
    minOutgoingBitrate;
    rtpPacketLossReceived;
    rtpPacketLossSent;
    constructor(transportId = null, timestamp = BigInt('0'), sctpState = null, bytesReceived = BigInt('0'), recvBitrate = 0, bytesSent = BigInt('0'), sendBitrate = 0, rtpBytesReceived = BigInt('0'), rtpRecvBitrate = 0, rtpBytesSent = BigInt('0'), rtpSendBitrate = 0, rtxBytesReceived = BigInt('0'), rtxRecvBitrate = 0, rtxBytesSent = BigInt('0'), rtxSendBitrate = 0, probationBytesSent = BigInt('0'), probationSendBitrate = 0, availableOutgoingBitrate = null, availableIncomingBitrate = null, maxIncomingBitrate = null, maxOutgoingBitrate = null, minOutgoingBitrate = null, rtpPacketLossReceived = null, rtpPacketLossSent = null) {
        this.transportId = transportId;
        this.timestamp = timestamp;
        this.sctpState = sctpState;
        this.bytesReceived = bytesReceived;
        this.recvBitrate = recvBitrate;
        this.bytesSent = bytesSent;
        this.sendBitrate = sendBitrate;
        this.rtpBytesReceived = rtpBytesReceived;
        this.rtpRecvBitrate = rtpRecvBitrate;
        this.rtpBytesSent = rtpBytesSent;
        this.rtpSendBitrate = rtpSendBitrate;
        this.rtxBytesReceived = rtxBytesReceived;
        this.rtxRecvBitrate = rtxRecvBitrate;
        this.rtxBytesSent = rtxBytesSent;
        this.rtxSendBitrate = rtxSendBitrate;
        this.probationBytesSent = probationBytesSent;
        this.probationSendBitrate = probationSendBitrate;
        this.availableOutgoingBitrate = availableOutgoingBitrate;
        this.availableIncomingBitrate = availableIncomingBitrate;
        this.maxIncomingBitrate = maxIncomingBitrate;
        this.maxOutgoingBitrate = maxOutgoingBitrate;
        this.minOutgoingBitrate = minOutgoingBitrate;
        this.rtpPacketLossReceived = rtpPacketLossReceived;
        this.rtpPacketLossSent = rtpPacketLossSent;
    }
    pack(builder) {
        const transportId = (this.transportId !== null ? builder.createString(this.transportId) : 0);
        return Stats.createStats(builder, transportId, this.timestamp, this.sctpState, this.bytesReceived, this.recvBitrate, this.bytesSent, this.sendBitrate, this.rtpBytesReceived, this.rtpRecvBitrate, this.rtpBytesSent, this.rtpSendBitrate, this.rtxBytesReceived, this.rtxRecvBitrate, this.rtxBytesSent, this.rtxSendBitrate, this.probationBytesSent, this.probationSendBitrate, this.availableOutgoingBitrate, this.availableIncomingBitrate, this.maxIncomingBitrate, this.maxOutgoingBitrate, this.minOutgoingBitrate, this.rtpPacketLossReceived, this.rtpPacketLossSent);
    }
}
exports.StatsT = StatsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-event-type.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/trace-event-type.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceEventType = void 0;
var TraceEventType;
(function (TraceEventType) {
    TraceEventType[TraceEventType["PROBATION"] = 0] = "PROBATION";
    TraceEventType[TraceEventType["BWE"] = 1] = "BWE";
})(TraceEventType || (exports.TraceEventType = TraceEventType = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-info.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/trace-info.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToTraceInfo = exports.unionToTraceInfo = exports.TraceInfo = void 0;
const bwe_trace_info_1 = __webpack_require__(/*! ../../fbs/transport/bwe-trace-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/bwe-trace-info.js");
var TraceInfo;
(function (TraceInfo) {
    TraceInfo[TraceInfo["NONE"] = 0] = "NONE";
    TraceInfo[TraceInfo["BweTraceInfo"] = 1] = "BweTraceInfo";
})(TraceInfo || (exports.TraceInfo = TraceInfo = {}));
function unionToTraceInfo(type, accessor) {
    switch (TraceInfo[type]) {
        case 'NONE': return null;
        case 'BweTraceInfo': return accessor(new bwe_trace_info_1.BweTraceInfo());
        default: return null;
    }
}
exports.unionToTraceInfo = unionToTraceInfo;
function unionListToTraceInfo(type, accessor, index) {
    switch (TraceInfo[type]) {
        case 'NONE': return null;
        case 'BweTraceInfo': return accessor(index, new bwe_trace_info_1.BweTraceInfo());
        default: return null;
    }
}
exports.unionListToTraceInfo = unionListToTraceInfo;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-notification.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/trace-notification.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceNotificationT = exports.TraceNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const trace_direction_1 = __webpack_require__(/*! ../../fbs/common/trace-direction */ "../../node_modules/mediasoup/node/lib/fbs/common/trace-direction.js");
const trace_event_type_1 = __webpack_require__(/*! ../../fbs/transport/trace-event-type */ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-event-type.js");
const trace_info_1 = __webpack_require__(/*! ../../fbs/transport/trace-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/trace-info.js");
class TraceNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTraceNotification(bb, obj) {
        return (obj || new TraceNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTraceNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TraceNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_event_type_1.TraceEventType.PROBATION;
    }
    timestamp() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    direction() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_direction_1.TraceDirection.DIRECTION_IN;
    }
    infoType() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : trace_info_1.TraceInfo.NONE;
    }
    info(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startTraceNotification(builder) {
        builder.startObject(5);
    }
    static addType(builder, type) {
        builder.addFieldInt8(0, type, trace_event_type_1.TraceEventType.PROBATION);
    }
    static addTimestamp(builder, timestamp) {
        builder.addFieldInt64(1, timestamp, BigInt('0'));
    }
    static addDirection(builder, direction) {
        builder.addFieldInt8(2, direction, trace_direction_1.TraceDirection.DIRECTION_IN);
    }
    static addInfoType(builder, infoType) {
        builder.addFieldInt8(3, infoType, trace_info_1.TraceInfo.NONE);
    }
    static addInfo(builder, infoOffset) {
        builder.addFieldOffset(4, infoOffset, 0);
    }
    static endTraceNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTraceNotification(builder, type, timestamp, direction, infoType, infoOffset) {
        TraceNotification.startTraceNotification(builder);
        TraceNotification.addType(builder, type);
        TraceNotification.addTimestamp(builder, timestamp);
        TraceNotification.addDirection(builder, direction);
        TraceNotification.addInfoType(builder, infoType);
        TraceNotification.addInfo(builder, infoOffset);
        return TraceNotification.endTraceNotification(builder);
    }
    unpack() {
        return new TraceNotificationT(this.type(), this.timestamp(), this.direction(), this.infoType(), (() => {
            const temp = (0, trace_info_1.unionToTraceInfo)(this.infoType(), this.info.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.type = this.type();
        _o.timestamp = this.timestamp();
        _o.direction = this.direction();
        _o.infoType = this.infoType();
        _o.info = (() => {
            const temp = (0, trace_info_1.unionToTraceInfo)(this.infoType(), this.info.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
exports.TraceNotification = TraceNotification;
class TraceNotificationT {
    type;
    timestamp;
    direction;
    infoType;
    info;
    constructor(type = trace_event_type_1.TraceEventType.PROBATION, timestamp = BigInt('0'), direction = trace_direction_1.TraceDirection.DIRECTION_IN, infoType = trace_info_1.TraceInfo.NONE, info = null) {
        this.type = type;
        this.timestamp = timestamp;
        this.direction = direction;
        this.infoType = infoType;
        this.info = info;
    }
    pack(builder) {
        const info = builder.createObjectOffset(this.info);
        return TraceNotification.createTraceNotification(builder, this.type, this.timestamp, this.direction, this.infoType, info);
    }
}
exports.TraceNotificationT = TraceNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleT = exports.Tuple = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const protocol_1 = __webpack_require__(/*! ../../fbs/transport/protocol */ "../../node_modules/mediasoup/node/lib/fbs/transport/protocol.js");
class Tuple {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTuple(bb, obj) {
        return (obj || new Tuple()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTuple(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Tuple()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    localAddress(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    localPort() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    remoteIp(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    remotePort() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    protocol() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : protocol_1.Protocol.UDP;
    }
    static startTuple(builder) {
        builder.startObject(5);
    }
    static addLocalAddress(builder, localAddressOffset) {
        builder.addFieldOffset(0, localAddressOffset, 0);
    }
    static addLocalPort(builder, localPort) {
        builder.addFieldInt16(1, localPort, 0);
    }
    static addRemoteIp(builder, remoteIpOffset) {
        builder.addFieldOffset(2, remoteIpOffset, 0);
    }
    static addRemotePort(builder, remotePort) {
        builder.addFieldInt16(3, remotePort, 0);
    }
    static addProtocol(builder, protocol) {
        builder.addFieldInt8(4, protocol, protocol_1.Protocol.UDP);
    }
    static endTuple(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // local_address
        return offset;
    }
    static createTuple(builder, localAddressOffset, localPort, remoteIpOffset, remotePort, protocol) {
        Tuple.startTuple(builder);
        Tuple.addLocalAddress(builder, localAddressOffset);
        Tuple.addLocalPort(builder, localPort);
        Tuple.addRemoteIp(builder, remoteIpOffset);
        Tuple.addRemotePort(builder, remotePort);
        Tuple.addProtocol(builder, protocol);
        return Tuple.endTuple(builder);
    }
    unpack() {
        return new TupleT(this.localAddress(), this.localPort(), this.remoteIp(), this.remotePort(), this.protocol());
    }
    unpackTo(_o) {
        _o.localAddress = this.localAddress();
        _o.localPort = this.localPort();
        _o.remoteIp = this.remoteIp();
        _o.remotePort = this.remotePort();
        _o.protocol = this.protocol();
    }
}
exports.Tuple = Tuple;
class TupleT {
    localAddress;
    localPort;
    remoteIp;
    remotePort;
    protocol;
    constructor(localAddress = null, localPort = 0, remoteIp = null, remotePort = 0, protocol = protocol_1.Protocol.UDP) {
        this.localAddress = localAddress;
        this.localPort = localPort;
        this.remoteIp = remoteIp;
        this.remotePort = remotePort;
        this.protocol = protocol;
    }
    pack(builder) {
        const localAddress = (this.localAddress !== null ? builder.createString(this.localAddress) : 0);
        const remoteIp = (this.remoteIp !== null ? builder.createString(this.remoteIp) : 0);
        return Tuple.createTuple(builder, localAddress, this.localPort, remoteIp, this.remotePort, this.protocol);
    }
}
exports.TupleT = TupleT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-server.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleHashT = exports.TupleHash = exports.IpPortT = exports.IpPort = exports.IceUserNameFragmentT = exports.IceUserNameFragment = exports.DumpResponseT = exports.DumpResponse = void 0;
var dump_response_1 = __webpack_require__(/*! ./web-rtc-server/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var ice_user_name_fragment_1 = __webpack_require__(/*! ./web-rtc-server/ice-user-name-fragment */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/ice-user-name-fragment.js");
Object.defineProperty(exports, "IceUserNameFragment", ({ enumerable: true, get: function () { return ice_user_name_fragment_1.IceUserNameFragment; } }));
Object.defineProperty(exports, "IceUserNameFragmentT", ({ enumerable: true, get: function () { return ice_user_name_fragment_1.IceUserNameFragmentT; } }));
var ip_port_1 = __webpack_require__(/*! ./web-rtc-server/ip-port */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/ip-port.js");
Object.defineProperty(exports, "IpPort", ({ enumerable: true, get: function () { return ip_port_1.IpPort; } }));
Object.defineProperty(exports, "IpPortT", ({ enumerable: true, get: function () { return ip_port_1.IpPortT; } }));
var tuple_hash_1 = __webpack_require__(/*! ./web-rtc-server/tuple-hash */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/tuple-hash.js");
Object.defineProperty(exports, "TupleHash", ({ enumerable: true, get: function () { return tuple_hash_1.TupleHash; } }));
Object.defineProperty(exports, "TupleHashT", ({ enumerable: true, get: function () { return tuple_hash_1.TupleHashT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/dump-response.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/dump-response.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const ice_user_name_fragment_1 = __webpack_require__(/*! ../../fbs/web-rtc-server/ice-user-name-fragment */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/ice-user-name-fragment.js");
const ip_port_1 = __webpack_require__(/*! ../../fbs/web-rtc-server/ip-port */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/ip-port.js");
const tuple_hash_1 = __webpack_require__(/*! ../../fbs/web-rtc-server/tuple-hash */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/tuple-hash.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    udpSockets(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new ip_port_1.IpPort()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    udpSocketsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    tcpServers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new ip_port_1.IpPort()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    tcpServersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    webRtcTransportIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    webRtcTransportIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    localIceUsernameFragments(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new ice_user_name_fragment_1.IceUserNameFragment()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    localIceUsernameFragmentsLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    tupleHashes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new tuple_hash_1.TupleHash()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    tupleHashesLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startDumpResponse(builder) {
        builder.startObject(6);
    }
    static addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    }
    static addUdpSockets(builder, udpSocketsOffset) {
        builder.addFieldOffset(1, udpSocketsOffset, 0);
    }
    static createUdpSocketsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startUdpSocketsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTcpServers(builder, tcpServersOffset) {
        builder.addFieldOffset(2, tcpServersOffset, 0);
    }
    static createTcpServersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTcpServersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addWebRtcTransportIds(builder, webRtcTransportIdsOffset) {
        builder.addFieldOffset(3, webRtcTransportIdsOffset, 0);
    }
    static createWebRtcTransportIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startWebRtcTransportIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addLocalIceUsernameFragments(builder, localIceUsernameFragmentsOffset) {
        builder.addFieldOffset(4, localIceUsernameFragmentsOffset, 0);
    }
    static createLocalIceUsernameFragmentsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startLocalIceUsernameFragmentsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTupleHashes(builder, tupleHashesOffset) {
        builder.addFieldOffset(5, tupleHashesOffset, 0);
    }
    static createTupleHashesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTupleHashesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // id
        builder.requiredField(offset, 6); // udp_sockets
        builder.requiredField(offset, 8); // tcp_servers
        builder.requiredField(offset, 10); // web_rtc_transport_ids
        builder.requiredField(offset, 12); // local_ice_username_fragments
        builder.requiredField(offset, 14); // tuple_hashes
        return offset;
    }
    static createDumpResponse(builder, idOffset, udpSocketsOffset, tcpServersOffset, webRtcTransportIdsOffset, localIceUsernameFragmentsOffset, tupleHashesOffset) {
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addId(builder, idOffset);
        DumpResponse.addUdpSockets(builder, udpSocketsOffset);
        DumpResponse.addTcpServers(builder, tcpServersOffset);
        DumpResponse.addWebRtcTransportIds(builder, webRtcTransportIdsOffset);
        DumpResponse.addLocalIceUsernameFragments(builder, localIceUsernameFragmentsOffset);
        DumpResponse.addTupleHashes(builder, tupleHashesOffset);
        return DumpResponse.endDumpResponse(builder);
    }
    unpack() {
        return new DumpResponseT(this.id(), this.bb.createObjList(this.udpSockets.bind(this), this.udpSocketsLength()), this.bb.createObjList(this.tcpServers.bind(this), this.tcpServersLength()), this.bb.createScalarList(this.webRtcTransportIds.bind(this), this.webRtcTransportIdsLength()), this.bb.createObjList(this.localIceUsernameFragments.bind(this), this.localIceUsernameFragmentsLength()), this.bb.createObjList(this.tupleHashes.bind(this), this.tupleHashesLength()));
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.udpSockets = this.bb.createObjList(this.udpSockets.bind(this), this.udpSocketsLength());
        _o.tcpServers = this.bb.createObjList(this.tcpServers.bind(this), this.tcpServersLength());
        _o.webRtcTransportIds = this.bb.createScalarList(this.webRtcTransportIds.bind(this), this.webRtcTransportIdsLength());
        _o.localIceUsernameFragments = this.bb.createObjList(this.localIceUsernameFragments.bind(this), this.localIceUsernameFragmentsLength());
        _o.tupleHashes = this.bb.createObjList(this.tupleHashes.bind(this), this.tupleHashesLength());
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    id;
    udpSockets;
    tcpServers;
    webRtcTransportIds;
    localIceUsernameFragments;
    tupleHashes;
    constructor(id = null, udpSockets = [], tcpServers = [], webRtcTransportIds = [], localIceUsernameFragments = [], tupleHashes = []) {
        this.id = id;
        this.udpSockets = udpSockets;
        this.tcpServers = tcpServers;
        this.webRtcTransportIds = webRtcTransportIds;
        this.localIceUsernameFragments = localIceUsernameFragments;
        this.tupleHashes = tupleHashes;
    }
    pack(builder) {
        const id = (this.id !== null ? builder.createString(this.id) : 0);
        const udpSockets = DumpResponse.createUdpSocketsVector(builder, builder.createObjectOffsetList(this.udpSockets));
        const tcpServers = DumpResponse.createTcpServersVector(builder, builder.createObjectOffsetList(this.tcpServers));
        const webRtcTransportIds = DumpResponse.createWebRtcTransportIdsVector(builder, builder.createObjectOffsetList(this.webRtcTransportIds));
        const localIceUsernameFragments = DumpResponse.createLocalIceUsernameFragmentsVector(builder, builder.createObjectOffsetList(this.localIceUsernameFragments));
        const tupleHashes = DumpResponse.createTupleHashesVector(builder, builder.createObjectOffsetList(this.tupleHashes));
        return DumpResponse.createDumpResponse(builder, id, udpSockets, tcpServers, webRtcTransportIds, localIceUsernameFragments, tupleHashes);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/ice-user-name-fragment.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/ice-user-name-fragment.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceUserNameFragmentT = exports.IceUserNameFragment = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class IceUserNameFragment {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsIceUserNameFragment(bb, obj) {
        return (obj || new IceUserNameFragment()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsIceUserNameFragment(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new IceUserNameFragment()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    localIceUsernameFragment(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    webRtcTransportId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startIceUserNameFragment(builder) {
        builder.startObject(2);
    }
    static addLocalIceUsernameFragment(builder, localIceUsernameFragmentOffset) {
        builder.addFieldOffset(0, localIceUsernameFragmentOffset, 0);
    }
    static addWebRtcTransportId(builder, webRtcTransportIdOffset) {
        builder.addFieldOffset(1, webRtcTransportIdOffset, 0);
    }
    static endIceUserNameFragment(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // local_ice_username_fragment
        builder.requiredField(offset, 6); // web_rtc_transport_id
        return offset;
    }
    static createIceUserNameFragment(builder, localIceUsernameFragmentOffset, webRtcTransportIdOffset) {
        IceUserNameFragment.startIceUserNameFragment(builder);
        IceUserNameFragment.addLocalIceUsernameFragment(builder, localIceUsernameFragmentOffset);
        IceUserNameFragment.addWebRtcTransportId(builder, webRtcTransportIdOffset);
        return IceUserNameFragment.endIceUserNameFragment(builder);
    }
    unpack() {
        return new IceUserNameFragmentT(this.localIceUsernameFragment(), this.webRtcTransportId());
    }
    unpackTo(_o) {
        _o.localIceUsernameFragment = this.localIceUsernameFragment();
        _o.webRtcTransportId = this.webRtcTransportId();
    }
}
exports.IceUserNameFragment = IceUserNameFragment;
class IceUserNameFragmentT {
    localIceUsernameFragment;
    webRtcTransportId;
    constructor(localIceUsernameFragment = null, webRtcTransportId = null) {
        this.localIceUsernameFragment = localIceUsernameFragment;
        this.webRtcTransportId = webRtcTransportId;
    }
    pack(builder) {
        const localIceUsernameFragment = (this.localIceUsernameFragment !== null ? builder.createString(this.localIceUsernameFragment) : 0);
        const webRtcTransportId = (this.webRtcTransportId !== null ? builder.createString(this.webRtcTransportId) : 0);
        return IceUserNameFragment.createIceUserNameFragment(builder, localIceUsernameFragment, webRtcTransportId);
    }
}
exports.IceUserNameFragmentT = IceUserNameFragmentT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/ip-port.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/ip-port.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpPortT = exports.IpPort = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class IpPort {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsIpPort(bb, obj) {
        return (obj || new IpPort()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsIpPort(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new IpPort()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ip(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    port() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    static startIpPort(builder) {
        builder.startObject(2);
    }
    static addIp(builder, ipOffset) {
        builder.addFieldOffset(0, ipOffset, 0);
    }
    static addPort(builder, port) {
        builder.addFieldInt16(1, port, 0);
    }
    static endIpPort(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // ip
        return offset;
    }
    static createIpPort(builder, ipOffset, port) {
        IpPort.startIpPort(builder);
        IpPort.addIp(builder, ipOffset);
        IpPort.addPort(builder, port);
        return IpPort.endIpPort(builder);
    }
    unpack() {
        return new IpPortT(this.ip(), this.port());
    }
    unpackTo(_o) {
        _o.ip = this.ip();
        _o.port = this.port();
    }
}
exports.IpPort = IpPort;
class IpPortT {
    ip;
    port;
    constructor(ip = null, port = 0) {
        this.ip = ip;
        this.port = port;
    }
    pack(builder) {
        const ip = (this.ip !== null ? builder.createString(this.ip) : 0);
        return IpPort.createIpPort(builder, ip, this.port);
    }
}
exports.IpPortT = IpPortT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/tuple-hash.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-server/tuple-hash.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleHashT = exports.TupleHash = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class TupleHash {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTupleHash(bb, obj) {
        return (obj || new TupleHash()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTupleHash(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TupleHash()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    tupleHash() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    webRtcTransportId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTupleHash(builder) {
        builder.startObject(2);
    }
    static addTupleHash(builder, tupleHash) {
        builder.addFieldInt64(0, tupleHash, BigInt('0'));
    }
    static addWebRtcTransportId(builder, webRtcTransportIdOffset) {
        builder.addFieldOffset(1, webRtcTransportIdOffset, 0);
    }
    static endTupleHash(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // web_rtc_transport_id
        return offset;
    }
    static createTupleHash(builder, tupleHash, webRtcTransportIdOffset) {
        TupleHash.startTupleHash(builder);
        TupleHash.addTupleHash(builder, tupleHash);
        TupleHash.addWebRtcTransportId(builder, webRtcTransportIdOffset);
        return TupleHash.endTupleHash(builder);
    }
    unpack() {
        return new TupleHashT(this.tupleHash(), this.webRtcTransportId());
    }
    unpackTo(_o) {
        _o.tupleHash = this.tupleHash();
        _o.webRtcTransportId = this.webRtcTransportId();
    }
}
exports.TupleHash = TupleHash;
class TupleHashT {
    tupleHash;
    webRtcTransportId;
    constructor(tupleHash = BigInt('0'), webRtcTransportId = null) {
        this.tupleHash = tupleHash;
        this.webRtcTransportId = webRtcTransportId;
    }
    pack(builder) {
        const webRtcTransportId = (this.webRtcTransportId !== null ? builder.createString(this.webRtcTransportId) : 0);
        return TupleHash.createTupleHash(builder, this.tupleHash, webRtcTransportId);
    }
}
exports.TupleHashT = TupleHashT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebRtcTransportOptionsT = exports.WebRtcTransportOptions = exports.ListenServerT = exports.ListenServer = exports.ListenIndividualT = exports.ListenIndividual = exports.Listen = exports.IceStateChangeNotificationT = exports.IceStateChangeNotification = exports.IceState = exports.IceSelectedTupleChangeNotificationT = exports.IceSelectedTupleChangeNotification = exports.IceRole = exports.IceParametersT = exports.IceParameters = exports.IceCandidateType = exports.IceCandidateTcpType = exports.IceCandidateT = exports.IceCandidate = exports.GetStatsResponseT = exports.GetStatsResponse = exports.FingerprintAlgorithm = exports.FingerprintT = exports.Fingerprint = exports.DumpResponseT = exports.DumpResponse = exports.DtlsStateChangeNotificationT = exports.DtlsStateChangeNotification = exports.DtlsState = exports.DtlsRole = exports.DtlsParametersT = exports.DtlsParameters = exports.ConnectResponseT = exports.ConnectResponse = exports.ConnectRequestT = exports.ConnectRequest = void 0;
var connect_request_1 = __webpack_require__(/*! ./web-rtc-transport/connect-request */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/connect-request.js");
Object.defineProperty(exports, "ConnectRequest", ({ enumerable: true, get: function () { return connect_request_1.ConnectRequest; } }));
Object.defineProperty(exports, "ConnectRequestT", ({ enumerable: true, get: function () { return connect_request_1.ConnectRequestT; } }));
var connect_response_1 = __webpack_require__(/*! ./web-rtc-transport/connect-response */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/connect-response.js");
Object.defineProperty(exports, "ConnectResponse", ({ enumerable: true, get: function () { return connect_response_1.ConnectResponse; } }));
Object.defineProperty(exports, "ConnectResponseT", ({ enumerable: true, get: function () { return connect_response_1.ConnectResponseT; } }));
var dtls_parameters_1 = __webpack_require__(/*! ./web-rtc-transport/dtls-parameters */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-parameters.js");
Object.defineProperty(exports, "DtlsParameters", ({ enumerable: true, get: function () { return dtls_parameters_1.DtlsParameters; } }));
Object.defineProperty(exports, "DtlsParametersT", ({ enumerable: true, get: function () { return dtls_parameters_1.DtlsParametersT; } }));
var dtls_role_1 = __webpack_require__(/*! ./web-rtc-transport/dtls-role */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-role.js");
Object.defineProperty(exports, "DtlsRole", ({ enumerable: true, get: function () { return dtls_role_1.DtlsRole; } }));
var dtls_state_1 = __webpack_require__(/*! ./web-rtc-transport/dtls-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state.js");
Object.defineProperty(exports, "DtlsState", ({ enumerable: true, get: function () { return dtls_state_1.DtlsState; } }));
var dtls_state_change_notification_1 = __webpack_require__(/*! ./web-rtc-transport/dtls-state-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state-change-notification.js");
Object.defineProperty(exports, "DtlsStateChangeNotification", ({ enumerable: true, get: function () { return dtls_state_change_notification_1.DtlsStateChangeNotification; } }));
Object.defineProperty(exports, "DtlsStateChangeNotificationT", ({ enumerable: true, get: function () { return dtls_state_change_notification_1.DtlsStateChangeNotificationT; } }));
var dump_response_1 = __webpack_require__(/*! ./web-rtc-transport/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var fingerprint_1 = __webpack_require__(/*! ./web-rtc-transport/fingerprint */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint.js");
Object.defineProperty(exports, "Fingerprint", ({ enumerable: true, get: function () { return fingerprint_1.Fingerprint; } }));
Object.defineProperty(exports, "FingerprintT", ({ enumerable: true, get: function () { return fingerprint_1.FingerprintT; } }));
var fingerprint_algorithm_1 = __webpack_require__(/*! ./web-rtc-transport/fingerprint-algorithm */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint-algorithm.js");
Object.defineProperty(exports, "FingerprintAlgorithm", ({ enumerable: true, get: function () { return fingerprint_algorithm_1.FingerprintAlgorithm; } }));
var get_stats_response_1 = __webpack_require__(/*! ./web-rtc-transport/get-stats-response */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/get-stats-response.js");
Object.defineProperty(exports, "GetStatsResponse", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponse; } }));
Object.defineProperty(exports, "GetStatsResponseT", ({ enumerable: true, get: function () { return get_stats_response_1.GetStatsResponseT; } }));
var ice_candidate_1 = __webpack_require__(/*! ./web-rtc-transport/ice-candidate */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate.js");
Object.defineProperty(exports, "IceCandidate", ({ enumerable: true, get: function () { return ice_candidate_1.IceCandidate; } }));
Object.defineProperty(exports, "IceCandidateT", ({ enumerable: true, get: function () { return ice_candidate_1.IceCandidateT; } }));
var ice_candidate_tcp_type_1 = __webpack_require__(/*! ./web-rtc-transport/ice-candidate-tcp-type */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-tcp-type.js");
Object.defineProperty(exports, "IceCandidateTcpType", ({ enumerable: true, get: function () { return ice_candidate_tcp_type_1.IceCandidateTcpType; } }));
var ice_candidate_type_1 = __webpack_require__(/*! ./web-rtc-transport/ice-candidate-type */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-type.js");
Object.defineProperty(exports, "IceCandidateType", ({ enumerable: true, get: function () { return ice_candidate_type_1.IceCandidateType; } }));
var ice_parameters_1 = __webpack_require__(/*! ./web-rtc-transport/ice-parameters */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-parameters.js");
Object.defineProperty(exports, "IceParameters", ({ enumerable: true, get: function () { return ice_parameters_1.IceParameters; } }));
Object.defineProperty(exports, "IceParametersT", ({ enumerable: true, get: function () { return ice_parameters_1.IceParametersT; } }));
var ice_role_1 = __webpack_require__(/*! ./web-rtc-transport/ice-role */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-role.js");
Object.defineProperty(exports, "IceRole", ({ enumerable: true, get: function () { return ice_role_1.IceRole; } }));
var ice_selected_tuple_change_notification_1 = __webpack_require__(/*! ./web-rtc-transport/ice-selected-tuple-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-selected-tuple-change-notification.js");
Object.defineProperty(exports, "IceSelectedTupleChangeNotification", ({ enumerable: true, get: function () { return ice_selected_tuple_change_notification_1.IceSelectedTupleChangeNotification; } }));
Object.defineProperty(exports, "IceSelectedTupleChangeNotificationT", ({ enumerable: true, get: function () { return ice_selected_tuple_change_notification_1.IceSelectedTupleChangeNotificationT; } }));
var ice_state_1 = __webpack_require__(/*! ./web-rtc-transport/ice-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state.js");
Object.defineProperty(exports, "IceState", ({ enumerable: true, get: function () { return ice_state_1.IceState; } }));
var ice_state_change_notification_1 = __webpack_require__(/*! ./web-rtc-transport/ice-state-change-notification */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state-change-notification.js");
Object.defineProperty(exports, "IceStateChangeNotification", ({ enumerable: true, get: function () { return ice_state_change_notification_1.IceStateChangeNotification; } }));
Object.defineProperty(exports, "IceStateChangeNotificationT", ({ enumerable: true, get: function () { return ice_state_change_notification_1.IceStateChangeNotificationT; } }));
var listen_1 = __webpack_require__(/*! ./web-rtc-transport/listen */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen.js");
Object.defineProperty(exports, "Listen", ({ enumerable: true, get: function () { return listen_1.Listen; } }));
var listen_individual_1 = __webpack_require__(/*! ./web-rtc-transport/listen-individual */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen-individual.js");
Object.defineProperty(exports, "ListenIndividual", ({ enumerable: true, get: function () { return listen_individual_1.ListenIndividual; } }));
Object.defineProperty(exports, "ListenIndividualT", ({ enumerable: true, get: function () { return listen_individual_1.ListenIndividualT; } }));
var listen_server_1 = __webpack_require__(/*! ./web-rtc-transport/listen-server */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen-server.js");
Object.defineProperty(exports, "ListenServer", ({ enumerable: true, get: function () { return listen_server_1.ListenServer; } }));
Object.defineProperty(exports, "ListenServerT", ({ enumerable: true, get: function () { return listen_server_1.ListenServerT; } }));
var web_rtc_transport_options_1 = __webpack_require__(/*! ./web-rtc-transport/web-rtc-transport-options */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/web-rtc-transport-options.js");
Object.defineProperty(exports, "WebRtcTransportOptions", ({ enumerable: true, get: function () { return web_rtc_transport_options_1.WebRtcTransportOptions; } }));
Object.defineProperty(exports, "WebRtcTransportOptionsT", ({ enumerable: true, get: function () { return web_rtc_transport_options_1.WebRtcTransportOptionsT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/connect-request.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/connect-request.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectRequestT = exports.ConnectRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dtls_parameters_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dtls-parameters */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-parameters.js");
class ConnectRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConnectRequest(bb, obj) {
        return (obj || new ConnectRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConnectRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConnectRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dtlsParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dtls_parameters_1.DtlsParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startConnectRequest(builder) {
        builder.startObject(1);
    }
    static addDtlsParameters(builder, dtlsParametersOffset) {
        builder.addFieldOffset(0, dtlsParametersOffset, 0);
    }
    static endConnectRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // dtls_parameters
        return offset;
    }
    static createConnectRequest(builder, dtlsParametersOffset) {
        ConnectRequest.startConnectRequest(builder);
        ConnectRequest.addDtlsParameters(builder, dtlsParametersOffset);
        return ConnectRequest.endConnectRequest(builder);
    }
    unpack() {
        return new ConnectRequestT((this.dtlsParameters() !== null ? this.dtlsParameters().unpack() : null));
    }
    unpackTo(_o) {
        _o.dtlsParameters = (this.dtlsParameters() !== null ? this.dtlsParameters().unpack() : null);
    }
}
exports.ConnectRequest = ConnectRequest;
class ConnectRequestT {
    dtlsParameters;
    constructor(dtlsParameters = null) {
        this.dtlsParameters = dtlsParameters;
    }
    pack(builder) {
        const dtlsParameters = (this.dtlsParameters !== null ? this.dtlsParameters.pack(builder) : 0);
        return ConnectRequest.createConnectRequest(builder, dtlsParameters);
    }
}
exports.ConnectRequestT = ConnectRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/connect-response.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/connect-response.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectResponseT = exports.ConnectResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dtls_role_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dtls-role */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-role.js");
class ConnectResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsConnectResponse(bb, obj) {
        return (obj || new ConnectResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsConnectResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ConnectResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dtlsLocalRole() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : dtls_role_1.DtlsRole.AUTO;
    }
    static startConnectResponse(builder) {
        builder.startObject(1);
    }
    static addDtlsLocalRole(builder, dtlsLocalRole) {
        builder.addFieldInt8(0, dtlsLocalRole, dtls_role_1.DtlsRole.AUTO);
    }
    static endConnectResponse(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createConnectResponse(builder, dtlsLocalRole) {
        ConnectResponse.startConnectResponse(builder);
        ConnectResponse.addDtlsLocalRole(builder, dtlsLocalRole);
        return ConnectResponse.endConnectResponse(builder);
    }
    unpack() {
        return new ConnectResponseT(this.dtlsLocalRole());
    }
    unpackTo(_o) {
        _o.dtlsLocalRole = this.dtlsLocalRole();
    }
}
exports.ConnectResponse = ConnectResponse;
class ConnectResponseT {
    dtlsLocalRole;
    constructor(dtlsLocalRole = dtls_role_1.DtlsRole.AUTO) {
        this.dtlsLocalRole = dtlsLocalRole;
    }
    pack(builder) {
        return ConnectResponse.createConnectResponse(builder, this.dtlsLocalRole);
    }
}
exports.ConnectResponseT = ConnectResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-parameters.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-parameters.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DtlsParametersT = exports.DtlsParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dtls_role_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dtls-role */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-role.js");
const fingerprint_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/fingerprint */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint.js");
class DtlsParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDtlsParameters(bb, obj) {
        return (obj || new DtlsParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDtlsParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DtlsParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    fingerprints(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new fingerprint_1.Fingerprint()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fingerprintsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    role() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : dtls_role_1.DtlsRole.AUTO;
    }
    static startDtlsParameters(builder) {
        builder.startObject(2);
    }
    static addFingerprints(builder, fingerprintsOffset) {
        builder.addFieldOffset(0, fingerprintsOffset, 0);
    }
    static createFingerprintsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startFingerprintsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRole(builder, role) {
        builder.addFieldInt8(1, role, dtls_role_1.DtlsRole.AUTO);
    }
    static endDtlsParameters(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // fingerprints
        return offset;
    }
    static createDtlsParameters(builder, fingerprintsOffset, role) {
        DtlsParameters.startDtlsParameters(builder);
        DtlsParameters.addFingerprints(builder, fingerprintsOffset);
        DtlsParameters.addRole(builder, role);
        return DtlsParameters.endDtlsParameters(builder);
    }
    unpack() {
        return new DtlsParametersT(this.bb.createObjList(this.fingerprints.bind(this), this.fingerprintsLength()), this.role());
    }
    unpackTo(_o) {
        _o.fingerprints = this.bb.createObjList(this.fingerprints.bind(this), this.fingerprintsLength());
        _o.role = this.role();
    }
}
exports.DtlsParameters = DtlsParameters;
class DtlsParametersT {
    fingerprints;
    role;
    constructor(fingerprints = [], role = dtls_role_1.DtlsRole.AUTO) {
        this.fingerprints = fingerprints;
        this.role = role;
    }
    pack(builder) {
        const fingerprints = DtlsParameters.createFingerprintsVector(builder, builder.createObjectOffsetList(this.fingerprints));
        return DtlsParameters.createDtlsParameters(builder, fingerprints, this.role);
    }
}
exports.DtlsParametersT = DtlsParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-role.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-role.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DtlsRole = void 0;
var DtlsRole;
(function (DtlsRole) {
    DtlsRole[DtlsRole["AUTO"] = 0] = "AUTO";
    DtlsRole[DtlsRole["CLIENT"] = 1] = "CLIENT";
    DtlsRole[DtlsRole["SERVER"] = 2] = "SERVER";
})(DtlsRole || (exports.DtlsRole = DtlsRole = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state-change-notification.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state-change-notification.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DtlsStateChangeNotificationT = exports.DtlsStateChangeNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dtls_state_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dtls-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state.js");
class DtlsStateChangeNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDtlsStateChangeNotification(bb, obj) {
        return (obj || new DtlsStateChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDtlsStateChangeNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DtlsStateChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    dtlsState() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : dtls_state_1.DtlsState.NEW;
    }
    remoteCert(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startDtlsStateChangeNotification(builder) {
        builder.startObject(2);
    }
    static addDtlsState(builder, dtlsState) {
        builder.addFieldInt8(0, dtlsState, dtls_state_1.DtlsState.NEW);
    }
    static addRemoteCert(builder, remoteCertOffset) {
        builder.addFieldOffset(1, remoteCertOffset, 0);
    }
    static endDtlsStateChangeNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDtlsStateChangeNotification(builder, dtlsState, remoteCertOffset) {
        DtlsStateChangeNotification.startDtlsStateChangeNotification(builder);
        DtlsStateChangeNotification.addDtlsState(builder, dtlsState);
        DtlsStateChangeNotification.addRemoteCert(builder, remoteCertOffset);
        return DtlsStateChangeNotification.endDtlsStateChangeNotification(builder);
    }
    unpack() {
        return new DtlsStateChangeNotificationT(this.dtlsState(), this.remoteCert());
    }
    unpackTo(_o) {
        _o.dtlsState = this.dtlsState();
        _o.remoteCert = this.remoteCert();
    }
}
exports.DtlsStateChangeNotification = DtlsStateChangeNotification;
class DtlsStateChangeNotificationT {
    dtlsState;
    remoteCert;
    constructor(dtlsState = dtls_state_1.DtlsState.NEW, remoteCert = null) {
        this.dtlsState = dtlsState;
        this.remoteCert = remoteCert;
    }
    pack(builder) {
        const remoteCert = (this.remoteCert !== null ? builder.createString(this.remoteCert) : 0);
        return DtlsStateChangeNotification.createDtlsStateChangeNotification(builder, this.dtlsState, remoteCert);
    }
}
exports.DtlsStateChangeNotificationT = DtlsStateChangeNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DtlsState = void 0;
var DtlsState;
(function (DtlsState) {
    DtlsState[DtlsState["NEW"] = 0] = "NEW";
    DtlsState[DtlsState["CONNECTING"] = 1] = "CONNECTING";
    DtlsState[DtlsState["CONNECTED"] = 2] = "CONNECTED";
    DtlsState[DtlsState["FAILED"] = 3] = "FAILED";
    DtlsState[DtlsState["CLOSED"] = 4] = "CLOSED";
})(DtlsState || (exports.DtlsState = DtlsState = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dump-response.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dump-response.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dump_1 = __webpack_require__(/*! ../../fbs/transport/dump */ "../../node_modules/mediasoup/node/lib/fbs/transport/dump.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
const dtls_parameters_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dtls-parameters */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-parameters.js");
const dtls_state_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dtls-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state.js");
const ice_candidate_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-candidate */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate.js");
const ice_parameters_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-parameters */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-parameters.js");
const ice_role_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-role */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-role.js");
const ice_state_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    iceRole() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : ice_role_1.IceRole.CONTROLLED;
    }
    iceParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new ice_parameters_1.IceParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    iceCandidates(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new ice_candidate_1.IceCandidate()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    iceCandidatesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    iceState() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : ice_state_1.IceState.NEW;
    }
    iceSelectedTuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dtlsParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new dtls_parameters_1.DtlsParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dtlsState() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : dtls_state_1.DtlsState.NEW;
    }
    static startDumpResponse(builder) {
        builder.startObject(8);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addIceRole(builder, iceRole) {
        builder.addFieldInt8(1, iceRole, ice_role_1.IceRole.CONTROLLED);
    }
    static addIceParameters(builder, iceParametersOffset) {
        builder.addFieldOffset(2, iceParametersOffset, 0);
    }
    static addIceCandidates(builder, iceCandidatesOffset) {
        builder.addFieldOffset(3, iceCandidatesOffset, 0);
    }
    static createIceCandidatesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startIceCandidatesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addIceState(builder, iceState) {
        builder.addFieldInt8(4, iceState, ice_state_1.IceState.NEW);
    }
    static addIceSelectedTuple(builder, iceSelectedTupleOffset) {
        builder.addFieldOffset(5, iceSelectedTupleOffset, 0);
    }
    static addDtlsParameters(builder, dtlsParametersOffset) {
        builder.addFieldOffset(6, dtlsParametersOffset, 0);
    }
    static addDtlsState(builder, dtlsState) {
        builder.addFieldInt8(7, dtlsState, dtls_state_1.DtlsState.NEW);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 8); // ice_parameters
        builder.requiredField(offset, 10); // ice_candidates
        builder.requiredField(offset, 16); // dtls_parameters
        return offset;
    }
    unpack() {
        return new DumpResponseT((this.base() !== null ? this.base().unpack() : null), this.iceRole(), (this.iceParameters() !== null ? this.iceParameters().unpack() : null), this.bb.createObjList(this.iceCandidates.bind(this), this.iceCandidatesLength()), this.iceState(), (this.iceSelectedTuple() !== null ? this.iceSelectedTuple().unpack() : null), (this.dtlsParameters() !== null ? this.dtlsParameters().unpack() : null), this.dtlsState());
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.iceRole = this.iceRole();
        _o.iceParameters = (this.iceParameters() !== null ? this.iceParameters().unpack() : null);
        _o.iceCandidates = this.bb.createObjList(this.iceCandidates.bind(this), this.iceCandidatesLength());
        _o.iceState = this.iceState();
        _o.iceSelectedTuple = (this.iceSelectedTuple() !== null ? this.iceSelectedTuple().unpack() : null);
        _o.dtlsParameters = (this.dtlsParameters() !== null ? this.dtlsParameters().unpack() : null);
        _o.dtlsState = this.dtlsState();
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    base;
    iceRole;
    iceParameters;
    iceCandidates;
    iceState;
    iceSelectedTuple;
    dtlsParameters;
    dtlsState;
    constructor(base = null, iceRole = ice_role_1.IceRole.CONTROLLED, iceParameters = null, iceCandidates = [], iceState = ice_state_1.IceState.NEW, iceSelectedTuple = null, dtlsParameters = null, dtlsState = dtls_state_1.DtlsState.NEW) {
        this.base = base;
        this.iceRole = iceRole;
        this.iceParameters = iceParameters;
        this.iceCandidates = iceCandidates;
        this.iceState = iceState;
        this.iceSelectedTuple = iceSelectedTuple;
        this.dtlsParameters = dtlsParameters;
        this.dtlsState = dtlsState;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const iceParameters = (this.iceParameters !== null ? this.iceParameters.pack(builder) : 0);
        const iceCandidates = DumpResponse.createIceCandidatesVector(builder, builder.createObjectOffsetList(this.iceCandidates));
        const iceSelectedTuple = (this.iceSelectedTuple !== null ? this.iceSelectedTuple.pack(builder) : 0);
        const dtlsParameters = (this.dtlsParameters !== null ? this.dtlsParameters.pack(builder) : 0);
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addBase(builder, base);
        DumpResponse.addIceRole(builder, this.iceRole);
        DumpResponse.addIceParameters(builder, iceParameters);
        DumpResponse.addIceCandidates(builder, iceCandidates);
        DumpResponse.addIceState(builder, this.iceState);
        DumpResponse.addIceSelectedTuple(builder, iceSelectedTuple);
        DumpResponse.addDtlsParameters(builder, dtlsParameters);
        DumpResponse.addDtlsState(builder, this.dtlsState);
        return DumpResponse.endDumpResponse(builder);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint-algorithm.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint-algorithm.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FingerprintAlgorithm = void 0;
var FingerprintAlgorithm;
(function (FingerprintAlgorithm) {
    FingerprintAlgorithm[FingerprintAlgorithm["SHA1"] = 0] = "SHA1";
    FingerprintAlgorithm[FingerprintAlgorithm["SHA224"] = 1] = "SHA224";
    FingerprintAlgorithm[FingerprintAlgorithm["SHA256"] = 2] = "SHA256";
    FingerprintAlgorithm[FingerprintAlgorithm["SHA384"] = 3] = "SHA384";
    FingerprintAlgorithm[FingerprintAlgorithm["SHA512"] = 4] = "SHA512";
})(FingerprintAlgorithm || (exports.FingerprintAlgorithm = FingerprintAlgorithm = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FingerprintT = exports.Fingerprint = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const fingerprint_algorithm_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/fingerprint-algorithm */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/fingerprint-algorithm.js");
class Fingerprint {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFingerprint(bb, obj) {
        return (obj || new Fingerprint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFingerprint(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Fingerprint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    algorithm() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : fingerprint_algorithm_1.FingerprintAlgorithm.SHA1;
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startFingerprint(builder) {
        builder.startObject(2);
    }
    static addAlgorithm(builder, algorithm) {
        builder.addFieldInt8(0, algorithm, fingerprint_algorithm_1.FingerprintAlgorithm.SHA1);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
    }
    static endFingerprint(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // value
        return offset;
    }
    static createFingerprint(builder, algorithm, valueOffset) {
        Fingerprint.startFingerprint(builder);
        Fingerprint.addAlgorithm(builder, algorithm);
        Fingerprint.addValue(builder, valueOffset);
        return Fingerprint.endFingerprint(builder);
    }
    unpack() {
        return new FingerprintT(this.algorithm(), this.value());
    }
    unpackTo(_o) {
        _o.algorithm = this.algorithm();
        _o.value = this.value();
    }
}
exports.Fingerprint = Fingerprint;
class FingerprintT {
    algorithm;
    value;
    constructor(algorithm = fingerprint_algorithm_1.FingerprintAlgorithm.SHA1, value = null) {
        this.algorithm = algorithm;
        this.value = value;
    }
    pack(builder) {
        const value = (this.value !== null ? builder.createString(this.value) : 0);
        return Fingerprint.createFingerprint(builder, this.algorithm, value);
    }
}
exports.FingerprintT = FingerprintT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/get-stats-response.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/get-stats-response.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStatsResponseT = exports.GetStatsResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const stats_1 = __webpack_require__(/*! ../../fbs/transport/stats */ "../../node_modules/mediasoup/node/lib/fbs/transport/stats.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
const dtls_state_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/dtls-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/dtls-state.js");
const ice_role_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-role */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-role.js");
const ice_state_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state.js");
class GetStatsResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGetStatsResponse(bb, obj) {
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGetStatsResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GetStatsResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new stats_1.Stats()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    iceRole() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : ice_role_1.IceRole.CONTROLLED;
    }
    iceState() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : ice_state_1.IceState.NEW;
    }
    iceSelectedTuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dtlsState() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : dtls_state_1.DtlsState.NEW;
    }
    static startGetStatsResponse(builder) {
        builder.startObject(5);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addIceRole(builder, iceRole) {
        builder.addFieldInt8(1, iceRole, ice_role_1.IceRole.CONTROLLED);
    }
    static addIceState(builder, iceState) {
        builder.addFieldInt8(2, iceState, ice_state_1.IceState.NEW);
    }
    static addIceSelectedTuple(builder, iceSelectedTupleOffset) {
        builder.addFieldOffset(3, iceSelectedTupleOffset, 0);
    }
    static addDtlsState(builder, dtlsState) {
        builder.addFieldInt8(4, dtlsState, dtls_state_1.DtlsState.NEW);
    }
    static endGetStatsResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        return offset;
    }
    unpack() {
        return new GetStatsResponseT((this.base() !== null ? this.base().unpack() : null), this.iceRole(), this.iceState(), (this.iceSelectedTuple() !== null ? this.iceSelectedTuple().unpack() : null), this.dtlsState());
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.iceRole = this.iceRole();
        _o.iceState = this.iceState();
        _o.iceSelectedTuple = (this.iceSelectedTuple() !== null ? this.iceSelectedTuple().unpack() : null);
        _o.dtlsState = this.dtlsState();
    }
}
exports.GetStatsResponse = GetStatsResponse;
class GetStatsResponseT {
    base;
    iceRole;
    iceState;
    iceSelectedTuple;
    dtlsState;
    constructor(base = null, iceRole = ice_role_1.IceRole.CONTROLLED, iceState = ice_state_1.IceState.NEW, iceSelectedTuple = null, dtlsState = dtls_state_1.DtlsState.NEW) {
        this.base = base;
        this.iceRole = iceRole;
        this.iceState = iceState;
        this.iceSelectedTuple = iceSelectedTuple;
        this.dtlsState = dtlsState;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const iceSelectedTuple = (this.iceSelectedTuple !== null ? this.iceSelectedTuple.pack(builder) : 0);
        GetStatsResponse.startGetStatsResponse(builder);
        GetStatsResponse.addBase(builder, base);
        GetStatsResponse.addIceRole(builder, this.iceRole);
        GetStatsResponse.addIceState(builder, this.iceState);
        GetStatsResponse.addIceSelectedTuple(builder, iceSelectedTuple);
        GetStatsResponse.addDtlsState(builder, this.dtlsState);
        return GetStatsResponse.endGetStatsResponse(builder);
    }
}
exports.GetStatsResponseT = GetStatsResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-tcp-type.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-tcp-type.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceCandidateTcpType = void 0;
var IceCandidateTcpType;
(function (IceCandidateTcpType) {
    IceCandidateTcpType[IceCandidateTcpType["PASSIVE"] = 0] = "PASSIVE";
})(IceCandidateTcpType || (exports.IceCandidateTcpType = IceCandidateTcpType = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-type.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-type.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceCandidateType = void 0;
var IceCandidateType;
(function (IceCandidateType) {
    IceCandidateType[IceCandidateType["HOST"] = 0] = "HOST";
})(IceCandidateType || (exports.IceCandidateType = IceCandidateType = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceCandidateT = exports.IceCandidate = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const protocol_1 = __webpack_require__(/*! ../../fbs/transport/protocol */ "../../node_modules/mediasoup/node/lib/fbs/transport/protocol.js");
const ice_candidate_type_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-candidate-type */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-candidate-type.js");
class IceCandidate {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsIceCandidate(bb, obj) {
        return (obj || new IceCandidate()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsIceCandidate(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new IceCandidate()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    foundation(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    priority() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    address(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    protocol() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : protocol_1.Protocol.UDP;
    }
    port() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : ice_candidate_type_1.IceCandidateType.HOST;
    }
    tcpType() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : null;
    }
    static startIceCandidate(builder) {
        builder.startObject(7);
    }
    static addFoundation(builder, foundationOffset) {
        builder.addFieldOffset(0, foundationOffset, 0);
    }
    static addPriority(builder, priority) {
        builder.addFieldInt32(1, priority, 0);
    }
    static addAddress(builder, addressOffset) {
        builder.addFieldOffset(2, addressOffset, 0);
    }
    static addProtocol(builder, protocol) {
        builder.addFieldInt8(3, protocol, protocol_1.Protocol.UDP);
    }
    static addPort(builder, port) {
        builder.addFieldInt16(4, port, 0);
    }
    static addType(builder, type) {
        builder.addFieldInt8(5, type, ice_candidate_type_1.IceCandidateType.HOST);
    }
    static addTcpType(builder, tcpType) {
        builder.addFieldInt8(6, tcpType, 0);
    }
    static endIceCandidate(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // foundation
        builder.requiredField(offset, 8); // address
        return offset;
    }
    static createIceCandidate(builder, foundationOffset, priority, addressOffset, protocol, port, type, tcpType) {
        IceCandidate.startIceCandidate(builder);
        IceCandidate.addFoundation(builder, foundationOffset);
        IceCandidate.addPriority(builder, priority);
        IceCandidate.addAddress(builder, addressOffset);
        IceCandidate.addProtocol(builder, protocol);
        IceCandidate.addPort(builder, port);
        IceCandidate.addType(builder, type);
        if (tcpType !== null)
            IceCandidate.addTcpType(builder, tcpType);
        return IceCandidate.endIceCandidate(builder);
    }
    unpack() {
        return new IceCandidateT(this.foundation(), this.priority(), this.address(), this.protocol(), this.port(), this.type(), this.tcpType());
    }
    unpackTo(_o) {
        _o.foundation = this.foundation();
        _o.priority = this.priority();
        _o.address = this.address();
        _o.protocol = this.protocol();
        _o.port = this.port();
        _o.type = this.type();
        _o.tcpType = this.tcpType();
    }
}
exports.IceCandidate = IceCandidate;
class IceCandidateT {
    foundation;
    priority;
    address;
    protocol;
    port;
    type;
    tcpType;
    constructor(foundation = null, priority = 0, address = null, protocol = protocol_1.Protocol.UDP, port = 0, type = ice_candidate_type_1.IceCandidateType.HOST, tcpType = null) {
        this.foundation = foundation;
        this.priority = priority;
        this.address = address;
        this.protocol = protocol;
        this.port = port;
        this.type = type;
        this.tcpType = tcpType;
    }
    pack(builder) {
        const foundation = (this.foundation !== null ? builder.createString(this.foundation) : 0);
        const address = (this.address !== null ? builder.createString(this.address) : 0);
        return IceCandidate.createIceCandidate(builder, foundation, this.priority, address, this.protocol, this.port, this.type, this.tcpType);
    }
}
exports.IceCandidateT = IceCandidateT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-parameters.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-parameters.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceParametersT = exports.IceParameters = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class IceParameters {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsIceParameters(bb, obj) {
        return (obj || new IceParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsIceParameters(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new IceParameters()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    usernameFragment(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    password(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    iceLite() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : true;
    }
    static startIceParameters(builder) {
        builder.startObject(3);
    }
    static addUsernameFragment(builder, usernameFragmentOffset) {
        builder.addFieldOffset(0, usernameFragmentOffset, 0);
    }
    static addPassword(builder, passwordOffset) {
        builder.addFieldOffset(1, passwordOffset, 0);
    }
    static addIceLite(builder, iceLite) {
        builder.addFieldInt8(2, +iceLite, +true);
    }
    static endIceParameters(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // username_fragment
        builder.requiredField(offset, 6); // password
        return offset;
    }
    static createIceParameters(builder, usernameFragmentOffset, passwordOffset, iceLite) {
        IceParameters.startIceParameters(builder);
        IceParameters.addUsernameFragment(builder, usernameFragmentOffset);
        IceParameters.addPassword(builder, passwordOffset);
        IceParameters.addIceLite(builder, iceLite);
        return IceParameters.endIceParameters(builder);
    }
    unpack() {
        return new IceParametersT(this.usernameFragment(), this.password(), this.iceLite());
    }
    unpackTo(_o) {
        _o.usernameFragment = this.usernameFragment();
        _o.password = this.password();
        _o.iceLite = this.iceLite();
    }
}
exports.IceParameters = IceParameters;
class IceParametersT {
    usernameFragment;
    password;
    iceLite;
    constructor(usernameFragment = null, password = null, iceLite = true) {
        this.usernameFragment = usernameFragment;
        this.password = password;
        this.iceLite = iceLite;
    }
    pack(builder) {
        const usernameFragment = (this.usernameFragment !== null ? builder.createString(this.usernameFragment) : 0);
        const password = (this.password !== null ? builder.createString(this.password) : 0);
        return IceParameters.createIceParameters(builder, usernameFragment, password, this.iceLite);
    }
}
exports.IceParametersT = IceParametersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-role.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-role.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceRole = void 0;
var IceRole;
(function (IceRole) {
    IceRole[IceRole["CONTROLLED"] = 0] = "CONTROLLED";
    IceRole[IceRole["CONTROLLING"] = 1] = "CONTROLLING";
})(IceRole || (exports.IceRole = IceRole = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-selected-tuple-change-notification.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-selected-tuple-change-notification.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceSelectedTupleChangeNotificationT = exports.IceSelectedTupleChangeNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const tuple_1 = __webpack_require__(/*! ../../fbs/transport/tuple */ "../../node_modules/mediasoup/node/lib/fbs/transport/tuple.js");
class IceSelectedTupleChangeNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsIceSelectedTupleChangeNotification(bb, obj) {
        return (obj || new IceSelectedTupleChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsIceSelectedTupleChangeNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new IceSelectedTupleChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    tuple(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new tuple_1.Tuple()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startIceSelectedTupleChangeNotification(builder) {
        builder.startObject(1);
    }
    static addTuple(builder, tupleOffset) {
        builder.addFieldOffset(0, tupleOffset, 0);
    }
    static endIceSelectedTupleChangeNotification(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // tuple
        return offset;
    }
    static createIceSelectedTupleChangeNotification(builder, tupleOffset) {
        IceSelectedTupleChangeNotification.startIceSelectedTupleChangeNotification(builder);
        IceSelectedTupleChangeNotification.addTuple(builder, tupleOffset);
        return IceSelectedTupleChangeNotification.endIceSelectedTupleChangeNotification(builder);
    }
    unpack() {
        return new IceSelectedTupleChangeNotificationT((this.tuple() !== null ? this.tuple().unpack() : null));
    }
    unpackTo(_o) {
        _o.tuple = (this.tuple() !== null ? this.tuple().unpack() : null);
    }
}
exports.IceSelectedTupleChangeNotification = IceSelectedTupleChangeNotification;
class IceSelectedTupleChangeNotificationT {
    tuple;
    constructor(tuple = null) {
        this.tuple = tuple;
    }
    pack(builder) {
        const tuple = (this.tuple !== null ? this.tuple.pack(builder) : 0);
        return IceSelectedTupleChangeNotification.createIceSelectedTupleChangeNotification(builder, tuple);
    }
}
exports.IceSelectedTupleChangeNotificationT = IceSelectedTupleChangeNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state-change-notification.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state-change-notification.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceStateChangeNotificationT = exports.IceStateChangeNotification = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const ice_state_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/ice-state */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state.js");
class IceStateChangeNotification {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsIceStateChangeNotification(bb, obj) {
        return (obj || new IceStateChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsIceStateChangeNotification(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new IceStateChangeNotification()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    iceState() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : ice_state_1.IceState.NEW;
    }
    static startIceStateChangeNotification(builder) {
        builder.startObject(1);
    }
    static addIceState(builder, iceState) {
        builder.addFieldInt8(0, iceState, ice_state_1.IceState.NEW);
    }
    static endIceStateChangeNotification(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createIceStateChangeNotification(builder, iceState) {
        IceStateChangeNotification.startIceStateChangeNotification(builder);
        IceStateChangeNotification.addIceState(builder, iceState);
        return IceStateChangeNotification.endIceStateChangeNotification(builder);
    }
    unpack() {
        return new IceStateChangeNotificationT(this.iceState());
    }
    unpackTo(_o) {
        _o.iceState = this.iceState();
    }
}
exports.IceStateChangeNotification = IceStateChangeNotification;
class IceStateChangeNotificationT {
    iceState;
    constructor(iceState = ice_state_1.IceState.NEW) {
        this.iceState = iceState;
    }
    pack(builder) {
        return IceStateChangeNotification.createIceStateChangeNotification(builder, this.iceState);
    }
}
exports.IceStateChangeNotificationT = IceStateChangeNotificationT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/ice-state.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IceState = void 0;
var IceState;
(function (IceState) {
    IceState[IceState["NEW"] = 0] = "NEW";
    IceState[IceState["CONNECTED"] = 1] = "CONNECTED";
    IceState[IceState["COMPLETED"] = 2] = "COMPLETED";
    IceState[IceState["DISCONNECTED"] = 3] = "DISCONNECTED";
})(IceState || (exports.IceState = IceState = {}));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen-individual.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen-individual.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListenIndividualT = exports.ListenIndividual = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const listen_info_1 = __webpack_require__(/*! ../../fbs/transport/listen-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/listen-info.js");
class ListenIndividual {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsListenIndividual(bb, obj) {
        return (obj || new ListenIndividual()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsListenIndividual(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ListenIndividual()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    listenInfos(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new listen_info_1.ListenInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    listenInfosLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startListenIndividual(builder) {
        builder.startObject(1);
    }
    static addListenInfos(builder, listenInfosOffset) {
        builder.addFieldOffset(0, listenInfosOffset, 0);
    }
    static createListenInfosVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startListenInfosVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endListenIndividual(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // listen_infos
        return offset;
    }
    static createListenIndividual(builder, listenInfosOffset) {
        ListenIndividual.startListenIndividual(builder);
        ListenIndividual.addListenInfos(builder, listenInfosOffset);
        return ListenIndividual.endListenIndividual(builder);
    }
    unpack() {
        return new ListenIndividualT(this.bb.createObjList(this.listenInfos.bind(this), this.listenInfosLength()));
    }
    unpackTo(_o) {
        _o.listenInfos = this.bb.createObjList(this.listenInfos.bind(this), this.listenInfosLength());
    }
}
exports.ListenIndividual = ListenIndividual;
class ListenIndividualT {
    listenInfos;
    constructor(listenInfos = []) {
        this.listenInfos = listenInfos;
    }
    pack(builder) {
        const listenInfos = ListenIndividual.createListenInfosVector(builder, builder.createObjectOffsetList(this.listenInfos));
        return ListenIndividual.createListenIndividual(builder, listenInfos);
    }
}
exports.ListenIndividualT = ListenIndividualT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen-server.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen-server.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListenServerT = exports.ListenServer = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class ListenServer {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsListenServer(bb, obj) {
        return (obj || new ListenServer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsListenServer(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ListenServer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    webRtcServerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startListenServer(builder) {
        builder.startObject(1);
    }
    static addWebRtcServerId(builder, webRtcServerIdOffset) {
        builder.addFieldOffset(0, webRtcServerIdOffset, 0);
    }
    static endListenServer(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // web_rtc_server_id
        return offset;
    }
    static createListenServer(builder, webRtcServerIdOffset) {
        ListenServer.startListenServer(builder);
        ListenServer.addWebRtcServerId(builder, webRtcServerIdOffset);
        return ListenServer.endListenServer(builder);
    }
    unpack() {
        return new ListenServerT(this.webRtcServerId());
    }
    unpackTo(_o) {
        _o.webRtcServerId = this.webRtcServerId();
    }
}
exports.ListenServer = ListenServer;
class ListenServerT {
    webRtcServerId;
    constructor(webRtcServerId = null) {
        this.webRtcServerId = webRtcServerId;
    }
    pack(builder) {
        const webRtcServerId = (this.webRtcServerId !== null ? builder.createString(this.webRtcServerId) : 0);
        return ListenServer.createListenServer(builder, webRtcServerId);
    }
}
exports.ListenServerT = ListenServerT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToListen = exports.unionToListen = exports.Listen = void 0;
const listen_individual_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/listen-individual */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen-individual.js");
const listen_server_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/listen-server */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen-server.js");
var Listen;
(function (Listen) {
    Listen[Listen["NONE"] = 0] = "NONE";
    Listen[Listen["ListenIndividual"] = 1] = "ListenIndividual";
    Listen[Listen["ListenServer"] = 2] = "ListenServer";
})(Listen || (exports.Listen = Listen = {}));
function unionToListen(type, accessor) {
    switch (Listen[type]) {
        case 'NONE': return null;
        case 'ListenIndividual': return accessor(new listen_individual_1.ListenIndividual());
        case 'ListenServer': return accessor(new listen_server_1.ListenServer());
        default: return null;
    }
}
exports.unionToListen = unionToListen;
function unionListToListen(type, accessor, index) {
    switch (Listen[type]) {
        case 'NONE': return null;
        case 'ListenIndividual': return accessor(index, new listen_individual_1.ListenIndividual());
        case 'ListenServer': return accessor(index, new listen_server_1.ListenServer());
        default: return null;
    }
}
exports.unionListToListen = unionListToListen;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/web-rtc-transport-options.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/web-rtc-transport-options.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebRtcTransportOptionsT = exports.WebRtcTransportOptions = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const options_1 = __webpack_require__(/*! ../../fbs/transport/options */ "../../node_modules/mediasoup/node/lib/fbs/transport/options.js");
const listen_1 = __webpack_require__(/*! ../../fbs/web-rtc-transport/listen */ "../../node_modules/mediasoup/node/lib/fbs/web-rtc-transport/listen.js");
class WebRtcTransportOptions {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsWebRtcTransportOptions(bb, obj) {
        return (obj || new WebRtcTransportOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsWebRtcTransportOptions(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new WebRtcTransportOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    base(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new options_1.Options()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    listenType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : listen_1.Listen.NONE;
    }
    listen(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    enableUdp() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : true;
    }
    enableTcp() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : true;
    }
    preferUdp() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    preferTcp() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startWebRtcTransportOptions(builder) {
        builder.startObject(7);
    }
    static addBase(builder, baseOffset) {
        builder.addFieldOffset(0, baseOffset, 0);
    }
    static addListenType(builder, listenType) {
        builder.addFieldInt8(1, listenType, listen_1.Listen.NONE);
    }
    static addListen(builder, listenOffset) {
        builder.addFieldOffset(2, listenOffset, 0);
    }
    static addEnableUdp(builder, enableUdp) {
        builder.addFieldInt8(3, +enableUdp, +true);
    }
    static addEnableTcp(builder, enableTcp) {
        builder.addFieldInt8(4, +enableTcp, +true);
    }
    static addPreferUdp(builder, preferUdp) {
        builder.addFieldInt8(5, +preferUdp, +false);
    }
    static addPreferTcp(builder, preferTcp) {
        builder.addFieldInt8(6, +preferTcp, +false);
    }
    static endWebRtcTransportOptions(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // base
        builder.requiredField(offset, 8); // listen
        return offset;
    }
    static createWebRtcTransportOptions(builder, baseOffset, listenType, listenOffset, enableUdp, enableTcp, preferUdp, preferTcp) {
        WebRtcTransportOptions.startWebRtcTransportOptions(builder);
        WebRtcTransportOptions.addBase(builder, baseOffset);
        WebRtcTransportOptions.addListenType(builder, listenType);
        WebRtcTransportOptions.addListen(builder, listenOffset);
        WebRtcTransportOptions.addEnableUdp(builder, enableUdp);
        WebRtcTransportOptions.addEnableTcp(builder, enableTcp);
        WebRtcTransportOptions.addPreferUdp(builder, preferUdp);
        WebRtcTransportOptions.addPreferTcp(builder, preferTcp);
        return WebRtcTransportOptions.endWebRtcTransportOptions(builder);
    }
    unpack() {
        return new WebRtcTransportOptionsT((this.base() !== null ? this.base().unpack() : null), this.listenType(), (() => {
            const temp = (0, listen_1.unionToListen)(this.listenType(), this.listen.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), this.enableUdp(), this.enableTcp(), this.preferUdp(), this.preferTcp());
    }
    unpackTo(_o) {
        _o.base = (this.base() !== null ? this.base().unpack() : null);
        _o.listenType = this.listenType();
        _o.listen = (() => {
            const temp = (0, listen_1.unionToListen)(this.listenType(), this.listen.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.enableUdp = this.enableUdp();
        _o.enableTcp = this.enableTcp();
        _o.preferUdp = this.preferUdp();
        _o.preferTcp = this.preferTcp();
    }
}
exports.WebRtcTransportOptions = WebRtcTransportOptions;
class WebRtcTransportOptionsT {
    base;
    listenType;
    listen;
    enableUdp;
    enableTcp;
    preferUdp;
    preferTcp;
    constructor(base = null, listenType = listen_1.Listen.NONE, listen = null, enableUdp = true, enableTcp = true, preferUdp = false, preferTcp = false) {
        this.base = base;
        this.listenType = listenType;
        this.listen = listen;
        this.enableUdp = enableUdp;
        this.enableTcp = enableTcp;
        this.preferUdp = preferUdp;
        this.preferTcp = preferTcp;
    }
    pack(builder) {
        const base = (this.base !== null ? this.base.pack(builder) : 0);
        const listen = builder.createObjectOffset(this.listen);
        return WebRtcTransportOptions.createWebRtcTransportOptions(builder, base, this.listenType, listen, this.enableUdp, this.enableTcp, this.preferUdp, this.preferTcp);
    }
}
exports.WebRtcTransportOptionsT = WebRtcTransportOptionsT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker.js":
/*!***********************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateSettingsRequestT = exports.UpdateSettingsRequest = exports.ResourceUsageResponseT = exports.ResourceUsageResponse = exports.DumpResponseT = exports.DumpResponse = exports.CreateWebRtcServerRequestT = exports.CreateWebRtcServerRequest = exports.CreateRouterRequestT = exports.CreateRouterRequest = exports.CloseWebRtcServerRequestT = exports.CloseWebRtcServerRequest = exports.CloseRouterRequestT = exports.CloseRouterRequest = exports.ChannelMessageHandlersT = exports.ChannelMessageHandlers = void 0;
var channel_message_handlers_1 = __webpack_require__(/*! ./worker/channel-message-handlers */ "../../node_modules/mediasoup/node/lib/fbs/worker/channel-message-handlers.js");
Object.defineProperty(exports, "ChannelMessageHandlers", ({ enumerable: true, get: function () { return channel_message_handlers_1.ChannelMessageHandlers; } }));
Object.defineProperty(exports, "ChannelMessageHandlersT", ({ enumerable: true, get: function () { return channel_message_handlers_1.ChannelMessageHandlersT; } }));
var close_router_request_1 = __webpack_require__(/*! ./worker/close-router-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/close-router-request.js");
Object.defineProperty(exports, "CloseRouterRequest", ({ enumerable: true, get: function () { return close_router_request_1.CloseRouterRequest; } }));
Object.defineProperty(exports, "CloseRouterRequestT", ({ enumerable: true, get: function () { return close_router_request_1.CloseRouterRequestT; } }));
var close_web_rtc_server_request_1 = __webpack_require__(/*! ./worker/close-web-rtc-server-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/close-web-rtc-server-request.js");
Object.defineProperty(exports, "CloseWebRtcServerRequest", ({ enumerable: true, get: function () { return close_web_rtc_server_request_1.CloseWebRtcServerRequest; } }));
Object.defineProperty(exports, "CloseWebRtcServerRequestT", ({ enumerable: true, get: function () { return close_web_rtc_server_request_1.CloseWebRtcServerRequestT; } }));
var create_router_request_1 = __webpack_require__(/*! ./worker/create-router-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/create-router-request.js");
Object.defineProperty(exports, "CreateRouterRequest", ({ enumerable: true, get: function () { return create_router_request_1.CreateRouterRequest; } }));
Object.defineProperty(exports, "CreateRouterRequestT", ({ enumerable: true, get: function () { return create_router_request_1.CreateRouterRequestT; } }));
var create_web_rtc_server_request_1 = __webpack_require__(/*! ./worker/create-web-rtc-server-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/create-web-rtc-server-request.js");
Object.defineProperty(exports, "CreateWebRtcServerRequest", ({ enumerable: true, get: function () { return create_web_rtc_server_request_1.CreateWebRtcServerRequest; } }));
Object.defineProperty(exports, "CreateWebRtcServerRequestT", ({ enumerable: true, get: function () { return create_web_rtc_server_request_1.CreateWebRtcServerRequestT; } }));
var dump_response_1 = __webpack_require__(/*! ./worker/dump-response */ "../../node_modules/mediasoup/node/lib/fbs/worker/dump-response.js");
Object.defineProperty(exports, "DumpResponse", ({ enumerable: true, get: function () { return dump_response_1.DumpResponse; } }));
Object.defineProperty(exports, "DumpResponseT", ({ enumerable: true, get: function () { return dump_response_1.DumpResponseT; } }));
var resource_usage_response_1 = __webpack_require__(/*! ./worker/resource-usage-response */ "../../node_modules/mediasoup/node/lib/fbs/worker/resource-usage-response.js");
Object.defineProperty(exports, "ResourceUsageResponse", ({ enumerable: true, get: function () { return resource_usage_response_1.ResourceUsageResponse; } }));
Object.defineProperty(exports, "ResourceUsageResponseT", ({ enumerable: true, get: function () { return resource_usage_response_1.ResourceUsageResponseT; } }));
var update_settings_request_1 = __webpack_require__(/*! ./worker/update-settings-request */ "../../node_modules/mediasoup/node/lib/fbs/worker/update-settings-request.js");
Object.defineProperty(exports, "UpdateSettingsRequest", ({ enumerable: true, get: function () { return update_settings_request_1.UpdateSettingsRequest; } }));
Object.defineProperty(exports, "UpdateSettingsRequestT", ({ enumerable: true, get: function () { return update_settings_request_1.UpdateSettingsRequestT; } }));


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker/channel-message-handlers.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker/channel-message-handlers.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelMessageHandlersT = exports.ChannelMessageHandlers = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class ChannelMessageHandlers {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsChannelMessageHandlers(bb, obj) {
        return (obj || new ChannelMessageHandlers()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsChannelMessageHandlers(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ChannelMessageHandlers()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    channelRequestHandlers(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    channelRequestHandlersLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    channelNotificationHandlers(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    channelNotificationHandlersLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startChannelMessageHandlers(builder) {
        builder.startObject(2);
    }
    static addChannelRequestHandlers(builder, channelRequestHandlersOffset) {
        builder.addFieldOffset(0, channelRequestHandlersOffset, 0);
    }
    static createChannelRequestHandlersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startChannelRequestHandlersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addChannelNotificationHandlers(builder, channelNotificationHandlersOffset) {
        builder.addFieldOffset(1, channelNotificationHandlersOffset, 0);
    }
    static createChannelNotificationHandlersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startChannelNotificationHandlersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endChannelMessageHandlers(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // channel_request_handlers
        builder.requiredField(offset, 6); // channel_notification_handlers
        return offset;
    }
    static createChannelMessageHandlers(builder, channelRequestHandlersOffset, channelNotificationHandlersOffset) {
        ChannelMessageHandlers.startChannelMessageHandlers(builder);
        ChannelMessageHandlers.addChannelRequestHandlers(builder, channelRequestHandlersOffset);
        ChannelMessageHandlers.addChannelNotificationHandlers(builder, channelNotificationHandlersOffset);
        return ChannelMessageHandlers.endChannelMessageHandlers(builder);
    }
    unpack() {
        return new ChannelMessageHandlersT(this.bb.createScalarList(this.channelRequestHandlers.bind(this), this.channelRequestHandlersLength()), this.bb.createScalarList(this.channelNotificationHandlers.bind(this), this.channelNotificationHandlersLength()));
    }
    unpackTo(_o) {
        _o.channelRequestHandlers = this.bb.createScalarList(this.channelRequestHandlers.bind(this), this.channelRequestHandlersLength());
        _o.channelNotificationHandlers = this.bb.createScalarList(this.channelNotificationHandlers.bind(this), this.channelNotificationHandlersLength());
    }
}
exports.ChannelMessageHandlers = ChannelMessageHandlers;
class ChannelMessageHandlersT {
    channelRequestHandlers;
    channelNotificationHandlers;
    constructor(channelRequestHandlers = [], channelNotificationHandlers = []) {
        this.channelRequestHandlers = channelRequestHandlers;
        this.channelNotificationHandlers = channelNotificationHandlers;
    }
    pack(builder) {
        const channelRequestHandlers = ChannelMessageHandlers.createChannelRequestHandlersVector(builder, builder.createObjectOffsetList(this.channelRequestHandlers));
        const channelNotificationHandlers = ChannelMessageHandlers.createChannelNotificationHandlersVector(builder, builder.createObjectOffsetList(this.channelNotificationHandlers));
        return ChannelMessageHandlers.createChannelMessageHandlers(builder, channelRequestHandlers, channelNotificationHandlers);
    }
}
exports.ChannelMessageHandlersT = ChannelMessageHandlersT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker/close-router-request.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker/close-router-request.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseRouterRequestT = exports.CloseRouterRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CloseRouterRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCloseRouterRequest(bb, obj) {
        return (obj || new CloseRouterRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCloseRouterRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CloseRouterRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    routerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCloseRouterRequest(builder) {
        builder.startObject(1);
    }
    static addRouterId(builder, routerIdOffset) {
        builder.addFieldOffset(0, routerIdOffset, 0);
    }
    static endCloseRouterRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // router_id
        return offset;
    }
    static createCloseRouterRequest(builder, routerIdOffset) {
        CloseRouterRequest.startCloseRouterRequest(builder);
        CloseRouterRequest.addRouterId(builder, routerIdOffset);
        return CloseRouterRequest.endCloseRouterRequest(builder);
    }
    unpack() {
        return new CloseRouterRequestT(this.routerId());
    }
    unpackTo(_o) {
        _o.routerId = this.routerId();
    }
}
exports.CloseRouterRequest = CloseRouterRequest;
class CloseRouterRequestT {
    routerId;
    constructor(routerId = null) {
        this.routerId = routerId;
    }
    pack(builder) {
        const routerId = (this.routerId !== null ? builder.createString(this.routerId) : 0);
        return CloseRouterRequest.createCloseRouterRequest(builder, routerId);
    }
}
exports.CloseRouterRequestT = CloseRouterRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker/close-web-rtc-server-request.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker/close-web-rtc-server-request.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseWebRtcServerRequestT = exports.CloseWebRtcServerRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CloseWebRtcServerRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCloseWebRtcServerRequest(bb, obj) {
        return (obj || new CloseWebRtcServerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCloseWebRtcServerRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CloseWebRtcServerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    webRtcServerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCloseWebRtcServerRequest(builder) {
        builder.startObject(1);
    }
    static addWebRtcServerId(builder, webRtcServerIdOffset) {
        builder.addFieldOffset(0, webRtcServerIdOffset, 0);
    }
    static endCloseWebRtcServerRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // web_rtc_server_id
        return offset;
    }
    static createCloseWebRtcServerRequest(builder, webRtcServerIdOffset) {
        CloseWebRtcServerRequest.startCloseWebRtcServerRequest(builder);
        CloseWebRtcServerRequest.addWebRtcServerId(builder, webRtcServerIdOffset);
        return CloseWebRtcServerRequest.endCloseWebRtcServerRequest(builder);
    }
    unpack() {
        return new CloseWebRtcServerRequestT(this.webRtcServerId());
    }
    unpackTo(_o) {
        _o.webRtcServerId = this.webRtcServerId();
    }
}
exports.CloseWebRtcServerRequest = CloseWebRtcServerRequest;
class CloseWebRtcServerRequestT {
    webRtcServerId;
    constructor(webRtcServerId = null) {
        this.webRtcServerId = webRtcServerId;
    }
    pack(builder) {
        const webRtcServerId = (this.webRtcServerId !== null ? builder.createString(this.webRtcServerId) : 0);
        return CloseWebRtcServerRequest.createCloseWebRtcServerRequest(builder, webRtcServerId);
    }
}
exports.CloseWebRtcServerRequestT = CloseWebRtcServerRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker/create-router-request.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker/create-router-request.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateRouterRequestT = exports.CreateRouterRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class CreateRouterRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCreateRouterRequest(bb, obj) {
        return (obj || new CreateRouterRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCreateRouterRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CreateRouterRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    routerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCreateRouterRequest(builder) {
        builder.startObject(1);
    }
    static addRouterId(builder, routerIdOffset) {
        builder.addFieldOffset(0, routerIdOffset, 0);
    }
    static endCreateRouterRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // router_id
        return offset;
    }
    static createCreateRouterRequest(builder, routerIdOffset) {
        CreateRouterRequest.startCreateRouterRequest(builder);
        CreateRouterRequest.addRouterId(builder, routerIdOffset);
        return CreateRouterRequest.endCreateRouterRequest(builder);
    }
    unpack() {
        return new CreateRouterRequestT(this.routerId());
    }
    unpackTo(_o) {
        _o.routerId = this.routerId();
    }
}
exports.CreateRouterRequest = CreateRouterRequest;
class CreateRouterRequestT {
    routerId;
    constructor(routerId = null) {
        this.routerId = routerId;
    }
    pack(builder) {
        const routerId = (this.routerId !== null ? builder.createString(this.routerId) : 0);
        return CreateRouterRequest.createCreateRouterRequest(builder, routerId);
    }
}
exports.CreateRouterRequestT = CreateRouterRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker/create-web-rtc-server-request.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker/create-web-rtc-server-request.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateWebRtcServerRequestT = exports.CreateWebRtcServerRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const listen_info_1 = __webpack_require__(/*! ../../fbs/transport/listen-info */ "../../node_modules/mediasoup/node/lib/fbs/transport/listen-info.js");
class CreateWebRtcServerRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCreateWebRtcServerRequest(bb, obj) {
        return (obj || new CreateWebRtcServerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCreateWebRtcServerRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CreateWebRtcServerRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    webRtcServerId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    listenInfos(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new listen_info_1.ListenInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    listenInfosLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startCreateWebRtcServerRequest(builder) {
        builder.startObject(2);
    }
    static addWebRtcServerId(builder, webRtcServerIdOffset) {
        builder.addFieldOffset(0, webRtcServerIdOffset, 0);
    }
    static addListenInfos(builder, listenInfosOffset) {
        builder.addFieldOffset(1, listenInfosOffset, 0);
    }
    static createListenInfosVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startListenInfosVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endCreateWebRtcServerRequest(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // web_rtc_server_id
        return offset;
    }
    static createCreateWebRtcServerRequest(builder, webRtcServerIdOffset, listenInfosOffset) {
        CreateWebRtcServerRequest.startCreateWebRtcServerRequest(builder);
        CreateWebRtcServerRequest.addWebRtcServerId(builder, webRtcServerIdOffset);
        CreateWebRtcServerRequest.addListenInfos(builder, listenInfosOffset);
        return CreateWebRtcServerRequest.endCreateWebRtcServerRequest(builder);
    }
    unpack() {
        return new CreateWebRtcServerRequestT(this.webRtcServerId(), this.bb.createObjList(this.listenInfos.bind(this), this.listenInfosLength()));
    }
    unpackTo(_o) {
        _o.webRtcServerId = this.webRtcServerId();
        _o.listenInfos = this.bb.createObjList(this.listenInfos.bind(this), this.listenInfosLength());
    }
}
exports.CreateWebRtcServerRequest = CreateWebRtcServerRequest;
class CreateWebRtcServerRequestT {
    webRtcServerId;
    listenInfos;
    constructor(webRtcServerId = null, listenInfos = []) {
        this.webRtcServerId = webRtcServerId;
        this.listenInfos = listenInfos;
    }
    pack(builder) {
        const webRtcServerId = (this.webRtcServerId !== null ? builder.createString(this.webRtcServerId) : 0);
        const listenInfos = CreateWebRtcServerRequest.createListenInfosVector(builder, builder.createObjectOffsetList(this.listenInfos));
        return CreateWebRtcServerRequest.createCreateWebRtcServerRequest(builder, webRtcServerId, listenInfos);
    }
}
exports.CreateWebRtcServerRequestT = CreateWebRtcServerRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker/dump-response.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker/dump-response.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpResponseT = exports.DumpResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
const dump_1 = __webpack_require__(/*! ../../fbs/lib-uring/dump */ "../../node_modules/mediasoup/node/lib/fbs/lib-uring/dump.js");
const channel_message_handlers_1 = __webpack_require__(/*! ../../fbs/worker/channel-message-handlers */ "../../node_modules/mediasoup/node/lib/fbs/worker/channel-message-handlers.js");
class DumpResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDumpResponse(bb, obj) {
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDumpResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DumpResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    pid() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    webRtcServerIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    webRtcServerIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    routerIds(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    routerIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    channelMessageHandlers(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new channel_message_handlers_1.ChannelMessageHandlers()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    liburing(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new dump_1.Dump()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startDumpResponse(builder) {
        builder.startObject(5);
    }
    static addPid(builder, pid) {
        builder.addFieldInt32(0, pid, 0);
    }
    static addWebRtcServerIds(builder, webRtcServerIdsOffset) {
        builder.addFieldOffset(1, webRtcServerIdsOffset, 0);
    }
    static createWebRtcServerIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startWebRtcServerIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRouterIds(builder, routerIdsOffset) {
        builder.addFieldOffset(2, routerIdsOffset, 0);
    }
    static createRouterIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRouterIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addChannelMessageHandlers(builder, channelMessageHandlersOffset) {
        builder.addFieldOffset(3, channelMessageHandlersOffset, 0);
    }
    static addLiburing(builder, liburingOffset) {
        builder.addFieldOffset(4, liburingOffset, 0);
    }
    static endDumpResponse(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // web_rtc_server_ids
        builder.requiredField(offset, 8); // router_ids
        builder.requiredField(offset, 10); // channel_message_handlers
        return offset;
    }
    unpack() {
        return new DumpResponseT(this.pid(), this.bb.createScalarList(this.webRtcServerIds.bind(this), this.webRtcServerIdsLength()), this.bb.createScalarList(this.routerIds.bind(this), this.routerIdsLength()), (this.channelMessageHandlers() !== null ? this.channelMessageHandlers().unpack() : null), (this.liburing() !== null ? this.liburing().unpack() : null));
    }
    unpackTo(_o) {
        _o.pid = this.pid();
        _o.webRtcServerIds = this.bb.createScalarList(this.webRtcServerIds.bind(this), this.webRtcServerIdsLength());
        _o.routerIds = this.bb.createScalarList(this.routerIds.bind(this), this.routerIdsLength());
        _o.channelMessageHandlers = (this.channelMessageHandlers() !== null ? this.channelMessageHandlers().unpack() : null);
        _o.liburing = (this.liburing() !== null ? this.liburing().unpack() : null);
    }
}
exports.DumpResponse = DumpResponse;
class DumpResponseT {
    pid;
    webRtcServerIds;
    routerIds;
    channelMessageHandlers;
    liburing;
    constructor(pid = 0, webRtcServerIds = [], routerIds = [], channelMessageHandlers = null, liburing = null) {
        this.pid = pid;
        this.webRtcServerIds = webRtcServerIds;
        this.routerIds = routerIds;
        this.channelMessageHandlers = channelMessageHandlers;
        this.liburing = liburing;
    }
    pack(builder) {
        const webRtcServerIds = DumpResponse.createWebRtcServerIdsVector(builder, builder.createObjectOffsetList(this.webRtcServerIds));
        const routerIds = DumpResponse.createRouterIdsVector(builder, builder.createObjectOffsetList(this.routerIds));
        const channelMessageHandlers = (this.channelMessageHandlers !== null ? this.channelMessageHandlers.pack(builder) : 0);
        const liburing = (this.liburing !== null ? this.liburing.pack(builder) : 0);
        DumpResponse.startDumpResponse(builder);
        DumpResponse.addPid(builder, this.pid);
        DumpResponse.addWebRtcServerIds(builder, webRtcServerIds);
        DumpResponse.addRouterIds(builder, routerIds);
        DumpResponse.addChannelMessageHandlers(builder, channelMessageHandlers);
        DumpResponse.addLiburing(builder, liburing);
        return DumpResponse.endDumpResponse(builder);
    }
}
exports.DumpResponseT = DumpResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker/resource-usage-response.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker/resource-usage-response.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResourceUsageResponseT = exports.ResourceUsageResponse = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class ResourceUsageResponse {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsResourceUsageResponse(bb, obj) {
        return (obj || new ResourceUsageResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsResourceUsageResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ResourceUsageResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ruUtime() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruStime() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruMaxrss() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruIxrss() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruIdrss() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruIsrss() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruMinflt() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruMajflt() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruNswap() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruInblock() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruOublock() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruMsgsnd() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruMsgrcv() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruNsignals() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruNvcsw() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ruNivcsw() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    static startResourceUsageResponse(builder) {
        builder.startObject(16);
    }
    static addRuUtime(builder, ruUtime) {
        builder.addFieldInt64(0, ruUtime, BigInt('0'));
    }
    static addRuStime(builder, ruStime) {
        builder.addFieldInt64(1, ruStime, BigInt('0'));
    }
    static addRuMaxrss(builder, ruMaxrss) {
        builder.addFieldInt64(2, ruMaxrss, BigInt('0'));
    }
    static addRuIxrss(builder, ruIxrss) {
        builder.addFieldInt64(3, ruIxrss, BigInt('0'));
    }
    static addRuIdrss(builder, ruIdrss) {
        builder.addFieldInt64(4, ruIdrss, BigInt('0'));
    }
    static addRuIsrss(builder, ruIsrss) {
        builder.addFieldInt64(5, ruIsrss, BigInt('0'));
    }
    static addRuMinflt(builder, ruMinflt) {
        builder.addFieldInt64(6, ruMinflt, BigInt('0'));
    }
    static addRuMajflt(builder, ruMajflt) {
        builder.addFieldInt64(7, ruMajflt, BigInt('0'));
    }
    static addRuNswap(builder, ruNswap) {
        builder.addFieldInt64(8, ruNswap, BigInt('0'));
    }
    static addRuInblock(builder, ruInblock) {
        builder.addFieldInt64(9, ruInblock, BigInt('0'));
    }
    static addRuOublock(builder, ruOublock) {
        builder.addFieldInt64(10, ruOublock, BigInt('0'));
    }
    static addRuMsgsnd(builder, ruMsgsnd) {
        builder.addFieldInt64(11, ruMsgsnd, BigInt('0'));
    }
    static addRuMsgrcv(builder, ruMsgrcv) {
        builder.addFieldInt64(12, ruMsgrcv, BigInt('0'));
    }
    static addRuNsignals(builder, ruNsignals) {
        builder.addFieldInt64(13, ruNsignals, BigInt('0'));
    }
    static addRuNvcsw(builder, ruNvcsw) {
        builder.addFieldInt64(14, ruNvcsw, BigInt('0'));
    }
    static addRuNivcsw(builder, ruNivcsw) {
        builder.addFieldInt64(15, ruNivcsw, BigInt('0'));
    }
    static endResourceUsageResponse(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createResourceUsageResponse(builder, ruUtime, ruStime, ruMaxrss, ruIxrss, ruIdrss, ruIsrss, ruMinflt, ruMajflt, ruNswap, ruInblock, ruOublock, ruMsgsnd, ruMsgrcv, ruNsignals, ruNvcsw, ruNivcsw) {
        ResourceUsageResponse.startResourceUsageResponse(builder);
        ResourceUsageResponse.addRuUtime(builder, ruUtime);
        ResourceUsageResponse.addRuStime(builder, ruStime);
        ResourceUsageResponse.addRuMaxrss(builder, ruMaxrss);
        ResourceUsageResponse.addRuIxrss(builder, ruIxrss);
        ResourceUsageResponse.addRuIdrss(builder, ruIdrss);
        ResourceUsageResponse.addRuIsrss(builder, ruIsrss);
        ResourceUsageResponse.addRuMinflt(builder, ruMinflt);
        ResourceUsageResponse.addRuMajflt(builder, ruMajflt);
        ResourceUsageResponse.addRuNswap(builder, ruNswap);
        ResourceUsageResponse.addRuInblock(builder, ruInblock);
        ResourceUsageResponse.addRuOublock(builder, ruOublock);
        ResourceUsageResponse.addRuMsgsnd(builder, ruMsgsnd);
        ResourceUsageResponse.addRuMsgrcv(builder, ruMsgrcv);
        ResourceUsageResponse.addRuNsignals(builder, ruNsignals);
        ResourceUsageResponse.addRuNvcsw(builder, ruNvcsw);
        ResourceUsageResponse.addRuNivcsw(builder, ruNivcsw);
        return ResourceUsageResponse.endResourceUsageResponse(builder);
    }
    unpack() {
        return new ResourceUsageResponseT(this.ruUtime(), this.ruStime(), this.ruMaxrss(), this.ruIxrss(), this.ruIdrss(), this.ruIsrss(), this.ruMinflt(), this.ruMajflt(), this.ruNswap(), this.ruInblock(), this.ruOublock(), this.ruMsgsnd(), this.ruMsgrcv(), this.ruNsignals(), this.ruNvcsw(), this.ruNivcsw());
    }
    unpackTo(_o) {
        _o.ruUtime = this.ruUtime();
        _o.ruStime = this.ruStime();
        _o.ruMaxrss = this.ruMaxrss();
        _o.ruIxrss = this.ruIxrss();
        _o.ruIdrss = this.ruIdrss();
        _o.ruIsrss = this.ruIsrss();
        _o.ruMinflt = this.ruMinflt();
        _o.ruMajflt = this.ruMajflt();
        _o.ruNswap = this.ruNswap();
        _o.ruInblock = this.ruInblock();
        _o.ruOublock = this.ruOublock();
        _o.ruMsgsnd = this.ruMsgsnd();
        _o.ruMsgrcv = this.ruMsgrcv();
        _o.ruNsignals = this.ruNsignals();
        _o.ruNvcsw = this.ruNvcsw();
        _o.ruNivcsw = this.ruNivcsw();
    }
}
exports.ResourceUsageResponse = ResourceUsageResponse;
class ResourceUsageResponseT {
    ruUtime;
    ruStime;
    ruMaxrss;
    ruIxrss;
    ruIdrss;
    ruIsrss;
    ruMinflt;
    ruMajflt;
    ruNswap;
    ruInblock;
    ruOublock;
    ruMsgsnd;
    ruMsgrcv;
    ruNsignals;
    ruNvcsw;
    ruNivcsw;
    constructor(ruUtime = BigInt('0'), ruStime = BigInt('0'), ruMaxrss = BigInt('0'), ruIxrss = BigInt('0'), ruIdrss = BigInt('0'), ruIsrss = BigInt('0'), ruMinflt = BigInt('0'), ruMajflt = BigInt('0'), ruNswap = BigInt('0'), ruInblock = BigInt('0'), ruOublock = BigInt('0'), ruMsgsnd = BigInt('0'), ruMsgrcv = BigInt('0'), ruNsignals = BigInt('0'), ruNvcsw = BigInt('0'), ruNivcsw = BigInt('0')) {
        this.ruUtime = ruUtime;
        this.ruStime = ruStime;
        this.ruMaxrss = ruMaxrss;
        this.ruIxrss = ruIxrss;
        this.ruIdrss = ruIdrss;
        this.ruIsrss = ruIsrss;
        this.ruMinflt = ruMinflt;
        this.ruMajflt = ruMajflt;
        this.ruNswap = ruNswap;
        this.ruInblock = ruInblock;
        this.ruOublock = ruOublock;
        this.ruMsgsnd = ruMsgsnd;
        this.ruMsgrcv = ruMsgrcv;
        this.ruNsignals = ruNsignals;
        this.ruNvcsw = ruNvcsw;
        this.ruNivcsw = ruNivcsw;
    }
    pack(builder) {
        return ResourceUsageResponse.createResourceUsageResponse(builder, this.ruUtime, this.ruStime, this.ruMaxrss, this.ruIxrss, this.ruIdrss, this.ruIsrss, this.ruMinflt, this.ruMajflt, this.ruNswap, this.ruInblock, this.ruOublock, this.ruMsgsnd, this.ruMsgrcv, this.ruNsignals, this.ruNvcsw, this.ruNivcsw);
    }
}
exports.ResourceUsageResponseT = ResourceUsageResponseT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/fbs/worker/update-settings-request.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/fbs/worker/update-settings-request.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateSettingsRequestT = exports.UpdateSettingsRequest = void 0;
const flatbuffers = __webpack_require__(/*! flatbuffers */ "../../node_modules/flatbuffers/mjs/flatbuffers.js");
class UpdateSettingsRequest {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUpdateSettingsRequest(bb, obj) {
        return (obj || new UpdateSettingsRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUpdateSettingsRequest(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new UpdateSettingsRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    logLevel(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    logTags(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    logTagsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startUpdateSettingsRequest(builder) {
        builder.startObject(2);
    }
    static addLogLevel(builder, logLevelOffset) {
        builder.addFieldOffset(0, logLevelOffset, 0);
    }
    static addLogTags(builder, logTagsOffset) {
        builder.addFieldOffset(1, logTagsOffset, 0);
    }
    static createLogTagsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startLogTagsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endUpdateSettingsRequest(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createUpdateSettingsRequest(builder, logLevelOffset, logTagsOffset) {
        UpdateSettingsRequest.startUpdateSettingsRequest(builder);
        UpdateSettingsRequest.addLogLevel(builder, logLevelOffset);
        UpdateSettingsRequest.addLogTags(builder, logTagsOffset);
        return UpdateSettingsRequest.endUpdateSettingsRequest(builder);
    }
    unpack() {
        return new UpdateSettingsRequestT(this.logLevel(), this.bb.createScalarList(this.logTags.bind(this), this.logTagsLength()));
    }
    unpackTo(_o) {
        _o.logLevel = this.logLevel();
        _o.logTags = this.bb.createScalarList(this.logTags.bind(this), this.logTagsLength());
    }
}
exports.UpdateSettingsRequest = UpdateSettingsRequest;
class UpdateSettingsRequestT {
    logLevel;
    logTags;
    constructor(logLevel = null, logTags = []) {
        this.logLevel = logLevel;
        this.logTags = logTags;
    }
    pack(builder) {
        const logLevel = (this.logLevel !== null ? builder.createString(this.logLevel) : 0);
        const logTags = UpdateSettingsRequest.createLogTagsVector(builder, builder.createObjectOffsetList(this.logTags));
        return UpdateSettingsRequest.createUpdateSettingsRequest(builder, logLevel, logTags);
    }
}
exports.UpdateSettingsRequestT = UpdateSettingsRequestT;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSupportedRtpCapabilities = exports.createWorker = exports.workerBin = exports.observer = exports.parseScalabilityMode = exports.version = exports.types = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "../../node_modules/mediasoup/node/lib/Logger.js");
const EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "../../node_modules/mediasoup/node/lib/EnhancedEventEmitter.js");
const Worker_1 = __webpack_require__(/*! ./Worker */ "../../node_modules/mediasoup/node/lib/Worker.js");
Object.defineProperty(exports, "workerBin", ({ enumerable: true, get: function () { return Worker_1.workerBin; } }));
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const supportedRtpCapabilities_1 = __webpack_require__(/*! ./supportedRtpCapabilities */ "../../node_modules/mediasoup/node/lib/supportedRtpCapabilities.js");
const types = __webpack_require__(/*! ./types */ "../../node_modules/mediasoup/node/lib/types.js");
exports.types = types;
/**
 * Expose mediasoup version.
 */
// eslint-disable-next-line @typescript-eslint/no-var-requires
exports.version = __webpack_require__(/*! ../../package.json */ "../../node_modules/mediasoup/package.json").version;
/**
 * Expose parseScalabilityMode() function.
 */
var scalabilityModes_1 = __webpack_require__(/*! ./scalabilityModes */ "../../node_modules/mediasoup/node/lib/scalabilityModes.js");
Object.defineProperty(exports, "parseScalabilityMode", ({ enumerable: true, get: function () { return scalabilityModes_1.parse; } }));
const observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
exports.observer = observer;
const logger = new Logger_1.Logger();
/**
 * Create a Worker.
 */
async function createWorker({ logLevel = 'error', logTags, rtcMinPort = 10000, rtcMaxPort = 59999, dtlsCertificateFile, dtlsPrivateKeyFile, libwebrtcFieldTrials, appData, } = {}) {
    logger.debug('createWorker()');
    if (appData && typeof appData !== 'object') {
        throw new TypeError('if given, appData must be an object');
    }
    const worker = new Worker_1.Worker({
        logLevel,
        logTags,
        rtcMinPort,
        rtcMaxPort,
        dtlsCertificateFile,
        dtlsPrivateKeyFile,
        libwebrtcFieldTrials,
        appData,
    });
    return new Promise((resolve, reject) => {
        worker.on('@success', () => {
            // Emit observer event.
            observer.safeEmit('newworker', worker);
            resolve(worker);
        });
        worker.on('@failure', reject);
    });
}
exports.createWorker = createWorker;
/**
 * Get a cloned copy of the mediasoup supported RTP capabilities.
 */
function getSupportedRtpCapabilities() {
    return utils.clone(supportedRtpCapabilities_1.supportedRtpCapabilities);
}
exports.getSupportedRtpCapabilities = getSupportedRtpCapabilities;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/ortc.js":
/*!*****************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/ortc.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeRtpMapping = exports.getPipeConsumerRtpParameters = exports.getConsumerRtpParameters = exports.canConsume = exports.getConsumableRtpParameters = exports.getProducerRtpParametersMapping = exports.generateRouterRtpCapabilities = exports.validateSctpStreamParameters = exports.validateRtpParameters = exports.validateRtpCapabilities = void 0;
const h264 = __webpack_require__(/*! h264-profile-level-id */ "../../node_modules/h264-profile-level-id/lib/index.js");
const supportedRtpCapabilities_1 = __webpack_require__(/*! ./supportedRtpCapabilities */ "../../node_modules/mediasoup/node/lib/supportedRtpCapabilities.js");
const scalabilityModes_1 = __webpack_require__(/*! ./scalabilityModes */ "../../node_modules/mediasoup/node/lib/scalabilityModes.js");
const utils = __webpack_require__(/*! ./utils */ "../../node_modules/mediasoup/node/lib/utils.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/mediasoup/node/lib/errors.js");
const FbsRtpParameters = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
const DynamicPayloadTypes = [
    100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
    115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 96, 97, 98,
    99,
];
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCapabilities(caps) {
    if (typeof caps !== 'object') {
        throw new TypeError('caps is not an object');
    }
    // codecs is optional. If unset, fill with an empty array.
    if (caps.codecs && !Array.isArray(caps.codecs)) {
        throw new TypeError('caps.codecs is not an array');
    }
    else if (!caps.codecs) {
        caps.codecs = [];
    }
    for (const codec of caps.codecs) {
        validateRtpCodecCapability(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
        throw new TypeError('caps.headerExtensions is not an array');
    }
    else if (!caps.headerExtensions) {
        caps.headerExtensions = [];
    }
    for (const ext of caps.headerExtensions) {
        validateRtpHeaderExtension(ext);
    }
}
exports.validateRtpCapabilities = validateRtpCapabilities;
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpParameters(params) {
    if (typeof params !== 'object') {
        throw new TypeError('params is not an object');
    }
    // mid is optional.
    if (params.mid && typeof params.mid !== 'string') {
        throw new TypeError('params.mid is not a string');
    }
    // codecs is mandatory.
    if (!Array.isArray(params.codecs)) {
        throw new TypeError('missing params.codecs');
    }
    for (const codec of params.codecs) {
        validateRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
        throw new TypeError('params.headerExtensions is not an array');
    }
    else if (!params.headerExtensions) {
        params.headerExtensions = [];
    }
    for (const ext of params.headerExtensions) {
        validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
    if (params.encodings && !Array.isArray(params.encodings)) {
        throw new TypeError('params.encodings is not an array');
    }
    else if (!params.encodings) {
        params.encodings = [];
    }
    for (const encoding of params.encodings) {
        validateRtpEncodingParameters(encoding);
    }
    // rtcp is optional. If unset, fill with an empty object.
    if (params.rtcp && typeof params.rtcp !== 'object') {
        throw new TypeError('params.rtcp is not an object');
    }
    else if (!params.rtcp) {
        params.rtcp = {};
    }
    validateRtcpParameters(params.rtcp);
}
exports.validateRtpParameters = validateRtpParameters;
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpStreamParameters(params) {
    if (typeof params !== 'object') {
        throw new TypeError('params is not an object');
    }
    // streamId is mandatory.
    if (typeof params.streamId !== 'number') {
        throw new TypeError('missing params.streamId');
    }
    // ordered is optional.
    let orderedGiven = false;
    if (typeof params.ordered === 'boolean') {
        orderedGiven = true;
    }
    else {
        params.ordered = true;
    }
    // maxPacketLifeTime is optional.
    if (params.maxPacketLifeTime &&
        typeof params.maxPacketLifeTime !== 'number') {
        throw new TypeError('invalid params.maxPacketLifeTime');
    }
    // maxRetransmits is optional.
    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {
        throw new TypeError('invalid params.maxRetransmits');
    }
    if (params.maxPacketLifeTime && params.maxRetransmits) {
        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
    }
    if (orderedGiven &&
        params.ordered &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
    }
    else if (!orderedGiven &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        params.ordered = false;
    }
}
exports.validateSctpStreamParameters = validateSctpStreamParameters;
/**
 * Generate RTP capabilities for the Router based on the given media codecs and
 * mediasoup supported RTP capabilities.
 */
function generateRouterRtpCapabilities(mediaCodecs = []) {
    // Normalize supported RTP capabilities.
    validateRtpCapabilities(supportedRtpCapabilities_1.supportedRtpCapabilities);
    if (!Array.isArray(mediaCodecs)) {
        throw new TypeError('mediaCodecs must be an Array');
    }
    const clonedSupportedRtpCapabilities = utils.clone(supportedRtpCapabilities_1.supportedRtpCapabilities);
    const dynamicPayloadTypes = utils.clone(DynamicPayloadTypes);
    const caps = {
        codecs: [],
        headerExtensions: clonedSupportedRtpCapabilities.headerExtensions,
    };
    for (const mediaCodec of mediaCodecs) {
        // This may throw.
        validateRtpCodecCapability(mediaCodec);
        const matchedSupportedCodec = clonedSupportedRtpCapabilities.codecs.find(supportedCodec => matchCodecs(mediaCodec, supportedCodec, { strict: false }));
        if (!matchedSupportedCodec) {
            throw new errors_1.UnsupportedError(`media codec not supported [mimeType:${mediaCodec.mimeType}]`);
        }
        // Clone the supported codec.
        const codec = utils.clone(matchedSupportedCodec);
        // If the given media codec has preferredPayloadType, keep it.
        if (typeof mediaCodec.preferredPayloadType === 'number') {
            codec.preferredPayloadType = mediaCodec.preferredPayloadType;
            // Also remove the pt from the list of available dynamic values.
            const idx = dynamicPayloadTypes.indexOf(codec.preferredPayloadType);
            if (idx > -1) {
                dynamicPayloadTypes.splice(idx, 1);
            }
        }
        // Otherwise if the supported codec has preferredPayloadType, use it.
        else if (typeof codec.preferredPayloadType === 'number') {
            // No need to remove it from the list since it's not a dynamic value.
        }
        // Otherwise choose a dynamic one.
        else {
            // Take the first available pt and remove it from the list.
            const pt = dynamicPayloadTypes.shift();
            if (!pt) {
                throw new Error('cannot allocate more dynamic codec payload types');
            }
            codec.preferredPayloadType = pt;
        }
        // Ensure there is not duplicated preferredPayloadType values.
        if (caps.codecs.some(c => c.preferredPayloadType === codec.preferredPayloadType)) {
            throw new TypeError('duplicated codec.preferredPayloadType');
        }
        // Merge the media codec parameters.
        codec.parameters = { ...codec.parameters, ...mediaCodec.parameters };
        // Append to the codec list.
        caps.codecs.push(codec);
        // Add a RTX video codec if video.
        if (codec.kind === 'video') {
            // Take the first available pt and remove it from the list.
            const pt = dynamicPayloadTypes.shift();
            if (!pt) {
                throw new Error('cannot allocate more dynamic codec payload types');
            }
            const rtxCodec = {
                kind: codec.kind,
                mimeType: `${codec.kind}/rtx`,
                preferredPayloadType: pt,
                clockRate: codec.clockRate,
                parameters: {
                    apt: codec.preferredPayloadType,
                },
                rtcpFeedback: [],
            };
            // Append to the codec list.
            caps.codecs.push(rtxCodec);
        }
    }
    return caps;
}
exports.generateRouterRtpCapabilities = generateRouterRtpCapabilities;
/**
 * Get a mapping of codec payloads and encodings of the given Producer RTP
 * parameters as values expected by the Router.
 *
 * It may throw if invalid or non supported RTP parameters are given.
 */
function getProducerRtpParametersMapping(params, caps) {
    const rtpMapping = {
        codecs: [],
        encodings: [],
    };
    // Match parameters media codecs to capabilities media codecs.
    const codecToCapCodec = new Map();
    for (const codec of params.codecs) {
        if (isRtxCodec(codec)) {
            continue;
        }
        // Search for the same media codec in capabilities.
        const matchedCapCodec = caps.codecs.find(capCodec => matchCodecs(codec, capCodec, { strict: true, modify: true }));
        if (!matchedCapCodec) {
            throw new errors_1.UnsupportedError(`unsupported codec [mimeType:${codec.mimeType}, payloadType:${codec.payloadType}]`);
        }
        codecToCapCodec.set(codec, matchedCapCodec);
    }
    // Match parameters RTX codecs to capabilities RTX codecs.
    for (const codec of params.codecs) {
        if (!isRtxCodec(codec)) {
            continue;
        }
        // Search for the associated media codec.
        const associatedMediaCodec = params.codecs.find(mediaCodec => mediaCodec.payloadType === codec.parameters.apt);
        if (!associatedMediaCodec) {
            throw new TypeError(`missing media codec found for RTX PT ${codec.payloadType}`);
        }
        const capMediaCodec = codecToCapCodec.get(associatedMediaCodec);
        // Ensure that the capabilities media codec has a RTX codec.
        const associatedCapRtxCodec = caps.codecs.find(capCodec => isRtxCodec(capCodec) &&
            capCodec.parameters.apt === capMediaCodec.preferredPayloadType);
        if (!associatedCapRtxCodec) {
            throw new errors_1.UnsupportedError(`no RTX codec for capability codec PT ${capMediaCodec.preferredPayloadType}`);
        }
        codecToCapCodec.set(codec, associatedCapRtxCodec);
    }
    // Generate codecs mapping.
    for (const [codec, capCodec] of codecToCapCodec) {
        rtpMapping.codecs.push({
            payloadType: codec.payloadType,
            mappedPayloadType: capCodec.preferredPayloadType,
        });
    }
    // Generate encodings mapping.
    let mappedSsrc = utils.generateRandomNumber();
    for (const encoding of params.encodings) {
        const mappedEncoding = {};
        mappedEncoding.mappedSsrc = mappedSsrc++;
        if (encoding.rid) {
            mappedEncoding.rid = encoding.rid;
        }
        if (encoding.ssrc) {
            mappedEncoding.ssrc = encoding.ssrc;
        }
        if (encoding.scalabilityMode) {
            mappedEncoding.scalabilityMode = encoding.scalabilityMode;
        }
        rtpMapping.encodings.push(mappedEncoding);
    }
    return rtpMapping;
}
exports.getProducerRtpParametersMapping = getProducerRtpParametersMapping;
/**
 * Generate RTP parameters to be internally used by Consumers given the RTP
 * parameters of a Producer and the RTP capabilities of the Router.
 */
function getConsumableRtpParameters(kind, params, caps, rtpMapping) {
    const consumableParams = {
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {},
    };
    for (const codec of params.codecs) {
        if (isRtxCodec(codec)) {
            continue;
        }
        const consumableCodecPt = rtpMapping.codecs.find(entry => entry.payloadType === codec.payloadType).mappedPayloadType;
        const matchedCapCodec = caps.codecs.find(capCodec => capCodec.preferredPayloadType === consumableCodecPt);
        const consumableCodec = {
            mimeType: matchedCapCodec.mimeType,
            payloadType: matchedCapCodec.preferredPayloadType,
            clockRate: matchedCapCodec.clockRate,
            channels: matchedCapCodec.channels,
            parameters: codec.parameters, // Keep the Producer codec parameters.
            rtcpFeedback: matchedCapCodec.rtcpFeedback,
        };
        consumableParams.codecs.push(consumableCodec);
        const consumableCapRtxCodec = caps.codecs.find(capRtxCodec => isRtxCodec(capRtxCodec) &&
            capRtxCodec.parameters.apt === consumableCodec.payloadType);
        if (consumableCapRtxCodec) {
            const consumableRtxCodec = {
                mimeType: consumableCapRtxCodec.mimeType,
                payloadType: consumableCapRtxCodec.preferredPayloadType,
                clockRate: consumableCapRtxCodec.clockRate,
                parameters: consumableCapRtxCodec.parameters,
                rtcpFeedback: consumableCapRtxCodec.rtcpFeedback,
            };
            consumableParams.codecs.push(consumableRtxCodec);
        }
    }
    for (const capExt of caps.headerExtensions) {
        // Just take RTP header extension that can be used in Consumers.
        if (capExt.kind !== kind ||
            (capExt.direction !== 'sendrecv' && capExt.direction !== 'sendonly')) {
            continue;
        }
        const consumableExt = {
            uri: capExt.uri,
            id: capExt.preferredId,
            encrypt: capExt.preferredEncrypt,
            parameters: {},
        };
        consumableParams.headerExtensions.push(consumableExt);
    }
    // Clone Producer encodings since we'll mangle them.
    const consumableEncodings = utils.clone(params.encodings) ?? [];
    for (let i = 0; i < consumableEncodings.length; ++i) {
        const consumableEncoding = consumableEncodings[i];
        const { mappedSsrc } = rtpMapping.encodings[i];
        // Remove useless fields.
        delete consumableEncoding.rid;
        delete consumableEncoding.rtx;
        delete consumableEncoding.codecPayloadType;
        // Set the mapped ssrc.
        consumableEncoding.ssrc = mappedSsrc;
        consumableParams.encodings.push(consumableEncoding);
    }
    consumableParams.rtcp = {
        cname: params.rtcp.cname,
        reducedSize: true,
    };
    return consumableParams;
}
exports.getConsumableRtpParameters = getConsumableRtpParameters;
/**
 * Check whether the given RTP capabilities can consume the given Producer.
 */
function canConsume(consumableParams, caps) {
    // This may throw.
    validateRtpCapabilities(caps);
    const matchingCodecs = [];
    for (const codec of consumableParams.codecs) {
        const matchedCapCodec = caps.codecs.find(capCodec => matchCodecs(capCodec, codec, { strict: true }));
        if (!matchedCapCodec) {
            continue;
        }
        matchingCodecs.push(codec);
    }
    // Ensure there is at least one media codec.
    if (matchingCodecs.length === 0 || isRtxCodec(matchingCodecs[0])) {
        return false;
    }
    return true;
}
exports.canConsume = canConsume;
/**
 * Generate RTP parameters for a specific Consumer.
 *
 * It reduces encodings to just one and takes into account given RTP
 * capabilities to reduce codecs, codecs' RTCP feedback and header extensions,
 * and also enables or disables RTX.
 */
function getConsumerRtpParameters({ consumableRtpParameters, remoteRtpCapabilities, pipe, enableRtx, }) {
    const consumerParams = {
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: consumableRtpParameters.rtcp,
    };
    for (const capCodec of remoteRtpCapabilities.codecs) {
        validateRtpCodecCapability(capCodec);
    }
    const consumableCodecs = utils.clone(consumableRtpParameters.codecs) ?? [];
    let rtxSupported = false;
    for (const codec of consumableCodecs) {
        if (!enableRtx && isRtxCodec(codec)) {
            continue;
        }
        const matchedCapCodec = remoteRtpCapabilities.codecs.find(capCodec => matchCodecs(capCodec, codec, { strict: true }));
        if (!matchedCapCodec) {
            continue;
        }
        codec.rtcpFeedback = matchedCapCodec.rtcpFeedback.filter(fb => enableRtx || fb.type !== 'nack' || fb.parameter);
        consumerParams.codecs.push(codec);
    }
    // Must sanitize the list of matched codecs by removing useless RTX codecs.
    for (let idx = consumerParams.codecs.length - 1; idx >= 0; --idx) {
        const codec = consumerParams.codecs[idx];
        if (isRtxCodec(codec)) {
            // Search for the associated media codec.
            const associatedMediaCodec = consumerParams.codecs.find(mediaCodec => mediaCodec.payloadType === codec.parameters.apt);
            if (associatedMediaCodec) {
                rtxSupported = true;
            }
            else {
                consumerParams.codecs.splice(idx, 1);
            }
        }
    }
    // Ensure there is at least one media codec.
    if (consumerParams.codecs.length === 0 ||
        isRtxCodec(consumerParams.codecs[0])) {
        throw new errors_1.UnsupportedError('no compatible media codecs');
    }
    consumerParams.headerExtensions =
        consumableRtpParameters.headerExtensions.filter(ext => remoteRtpCapabilities.headerExtensions.some(capExt => capExt.preferredId === ext.id && capExt.uri === ext.uri));
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
    if (consumerParams.headerExtensions.some(ext => ext.uri ===
        'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {
        for (const codec of consumerParams.codecs) {
            codec.rtcpFeedback = codec.rtcpFeedback.filter(fb => fb.type !== 'goog-remb');
        }
    }
    else if (consumerParams.headerExtensions.some(ext => ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {
        for (const codec of consumerParams.codecs) {
            codec.rtcpFeedback = codec.rtcpFeedback.filter(fb => fb.type !== 'transport-cc');
        }
    }
    else {
        for (const codec of consumerParams.codecs) {
            codec.rtcpFeedback = codec.rtcpFeedback.filter(fb => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');
        }
    }
    if (!pipe) {
        const consumerEncoding = {
            ssrc: utils.generateRandomNumber(),
        };
        if (rtxSupported) {
            consumerEncoding.rtx = { ssrc: consumerEncoding.ssrc + 1 };
        }
        // If any of the consumableRtpParameters.encodings has scalabilityMode,
        // process it (assume all encodings have the same value).
        const encodingWithScalabilityMode = consumableRtpParameters.encodings.find(encoding => encoding.scalabilityMode);
        let scalabilityMode = encodingWithScalabilityMode
            ? encodingWithScalabilityMode.scalabilityMode
            : undefined;
        // If there is simulast, mangle spatial layers in scalabilityMode.
        if (consumableRtpParameters.encodings.length > 1) {
            const { temporalLayers } = (0, scalabilityModes_1.parse)(scalabilityMode);
            scalabilityMode = `L${consumableRtpParameters.encodings.length}T${temporalLayers}`;
        }
        if (scalabilityMode) {
            consumerEncoding.scalabilityMode = scalabilityMode;
        }
        // Use the maximum maxBitrate in any encoding and honor it in the Consumer's
        // encoding.
        const maxEncodingMaxBitrate = consumableRtpParameters.encodings.reduce((maxBitrate, encoding) => encoding.maxBitrate && encoding.maxBitrate > maxBitrate
            ? encoding.maxBitrate
            : maxBitrate, 0);
        if (maxEncodingMaxBitrate) {
            consumerEncoding.maxBitrate = maxEncodingMaxBitrate;
        }
        // Set a single encoding for the Consumer.
        consumerParams.encodings.push(consumerEncoding);
    }
    else {
        const consumableEncodings = utils.clone(consumableRtpParameters.encodings) ?? [];
        const baseSsrc = utils.generateRandomNumber();
        const baseRtxSsrc = utils.generateRandomNumber();
        for (let i = 0; i < consumableEncodings.length; ++i) {
            const encoding = consumableEncodings[i];
            encoding.ssrc = baseSsrc + i;
            if (rtxSupported) {
                encoding.rtx = { ssrc: baseRtxSsrc + i };
            }
            else {
                delete encoding.rtx;
            }
            consumerParams.encodings.push(encoding);
        }
    }
    return consumerParams;
}
exports.getConsumerRtpParameters = getConsumerRtpParameters;
/**
 * Generate RTP parameters for a pipe Consumer.
 *
 * It keeps all original consumable encodings and removes support for BWE. If
 * enableRtx is false, it also removes RTX and NACK support.
 */
function getPipeConsumerRtpParameters({ consumableRtpParameters, enableRtx, }) {
    const consumerParams = {
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: consumableRtpParameters.rtcp,
    };
    const consumableCodecs = utils.clone(consumableRtpParameters.codecs) ?? [];
    for (const codec of consumableCodecs) {
        if (!enableRtx && isRtxCodec(codec)) {
            continue;
        }
        codec.rtcpFeedback = codec.rtcpFeedback.filter(fb => (fb.type === 'nack' && fb.parameter === 'pli') ||
            (fb.type === 'ccm' && fb.parameter === 'fir') ||
            (enableRtx && fb.type === 'nack' && !fb.parameter));
        consumerParams.codecs.push(codec);
    }
    // Reduce RTP extensions by disabling transport MID and BWE related ones.
    consumerParams.headerExtensions =
        consumableRtpParameters.headerExtensions.filter(ext => ext.uri !== 'urn:ietf:params:rtp-hdrext:sdes:mid' &&
            ext.uri !==
                'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time' &&
            ext.uri !==
                'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01');
    const consumableEncodings = utils.clone(consumableRtpParameters.encodings) ?? [];
    const baseSsrc = utils.generateRandomNumber();
    const baseRtxSsrc = utils.generateRandomNumber();
    for (let i = 0; i < consumableEncodings.length; ++i) {
        const encoding = consumableEncodings[i];
        encoding.ssrc = baseSsrc + i;
        if (enableRtx) {
            encoding.rtx = { ssrc: baseRtxSsrc + i };
        }
        else {
            delete encoding.rtx;
        }
        consumerParams.encodings.push(encoding);
    }
    return consumerParams;
}
exports.getPipeConsumerRtpParameters = getPipeConsumerRtpParameters;
function isRtxCodec(codec) {
    return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
    const aMimeType = aCodec.mimeType.toLowerCase();
    const bMimeType = bCodec.mimeType.toLowerCase();
    if (aMimeType !== bMimeType) {
        return false;
    }
    if (aCodec.clockRate !== bCodec.clockRate) {
        return false;
    }
    if (aCodec.channels !== bCodec.channels) {
        return false;
    }
    // Per codec special checks.
    switch (aMimeType) {
        case 'audio/multiopus': {
            const aNumStreams = aCodec.parameters['num_streams'];
            const bNumStreams = bCodec.parameters['num_streams'];
            if (aNumStreams !== bNumStreams) {
                return false;
            }
            const aCoupledStreams = aCodec.parameters['coupled_streams'];
            const bCoupledStreams = bCodec.parameters['coupled_streams'];
            if (aCoupledStreams !== bCoupledStreams) {
                return false;
            }
            break;
        }
        case 'video/h264':
        case 'video/h264-svc': {
            if (strict) {
                const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;
                const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;
                if (aPacketizationMode !== bPacketizationMode) {
                    return false;
                }
                if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                    return false;
                }
                let selectedProfileLevelId;
                try {
                    selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
                }
                catch (error) {
                    return false;
                }
                if (modify) {
                    if (selectedProfileLevelId) {
                        aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                    }
                    else {
                        delete aCodec.parameters['profile-level-id'];
                    }
                }
            }
            break;
        }
        case 'video/vp9': {
            if (strict) {
                const aProfileId = aCodec.parameters['profile-id'] || 0;
                const bProfileId = bCodec.parameters['profile-id'] || 0;
                if (aProfileId !== bProfileId) {
                    return false;
                }
            }
            break;
        }
    }
    return true;
}
function serializeRtpMapping(builder, rtpMapping) {
    const codecs = [];
    for (const codec of rtpMapping.codecs) {
        codecs.push(FbsRtpParameters.CodecMapping.createCodecMapping(builder, codec.payloadType, codec.mappedPayloadType));
    }
    const codecsOffset = FbsRtpParameters.RtpMapping.createCodecsVector(builder, codecs);
    const encodings = [];
    for (const encoding of rtpMapping.encodings) {
        encodings.push(FbsRtpParameters.EncodingMapping.createEncodingMapping(builder, builder.createString(encoding.rid), encoding.ssrc ?? null, builder.createString(encoding.scalabilityMode), encoding.mappedSsrc));
    }
    const encodingsOffset = FbsRtpParameters.RtpMapping.createEncodingsVector(builder, encodings);
    return FbsRtpParameters.RtpMapping.createRtpMapping(builder, codecsOffset, encodingsOffset);
}
exports.serializeRtpMapping = serializeRtpMapping;
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecCapability(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object') {
        throw new TypeError('codec is not an object');
    }
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string') {
        throw new TypeError('missing codec.mimeType');
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    // Just override kind with media component of mimeType.
    codec.kind = mimeTypeMatch[1].toLowerCase();
    // preferredPayloadType is optional.
    if (codec.preferredPayloadType &&
        typeof codec.preferredPayloadType !== 'number') {
        throw new TypeError('invalid codec.preferredPayloadType');
    }
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number') {
        throw new TypeError('missing codec.clockRate');
    }
    // channels is optional. If unset, set it to 1 (just if audio).
    if (codec.kind === 'audio') {
        if (typeof codec.channels !== 'number') {
            codec.channels = 1;
        }
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object') {
        codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number') {
                throw new TypeError('invalid codec apt parameter');
            }
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
        validateRtcpFeedback(fb);
    }
}
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpFeedback(fb) {
    if (typeof fb !== 'object') {
        throw new TypeError('fb is not an object');
    }
    // type is mandatory.
    if (!fb.type || typeof fb.type !== 'string') {
        throw new TypeError('missing fb.type');
    }
    // parameter is optional. If unset set it to an empty string.
    if (!fb.parameter || typeof fb.parameter !== 'string') {
        fb.parameter = '';
    }
}
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtension(ext) {
    if (typeof ext !== 'object') {
        throw new TypeError('ext is not an object');
    }
    if (ext.kind !== 'audio' && ext.kind !== 'video') {
        throw new TypeError('invalid ext.kind');
    }
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string') {
        throw new TypeError('missing ext.uri');
    }
    // preferredId is mandatory.
    if (typeof ext.preferredId !== 'number') {
        throw new TypeError('missing ext.preferredId');
    }
    // preferredEncrypt is optional. If unset set it to false.
    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {
        throw new TypeError('invalid ext.preferredEncrypt');
    }
    else if (!ext.preferredEncrypt) {
        ext.preferredEncrypt = false;
    }
    // direction is optional. If unset set it to sendrecv.
    if (ext.direction && typeof ext.direction !== 'string') {
        throw new TypeError('invalid ext.direction');
    }
    else if (!ext.direction) {
        ext.direction = 'sendrecv';
    }
}
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecParameters(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object') {
        throw new TypeError('codec is not an object');
    }
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string') {
        throw new TypeError('missing codec.mimeType');
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    // payloadType is mandatory.
    if (typeof codec.payloadType !== 'number') {
        throw new TypeError('missing codec.payloadType');
    }
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number') {
        throw new TypeError('missing codec.clockRate');
    }
    const kind = mimeTypeMatch[1].toLowerCase();
    // channels is optional. If unset, set it to 1 (just if audio).
    if (kind === 'audio') {
        if (typeof codec.channels !== 'number') {
            codec.channels = 1;
        }
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object') {
        codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number') {
                throw new TypeError('invalid codec apt parameter');
            }
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
        validateRtcpFeedback(fb);
    }
}
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding
 * missing fields with default values. It throws if invalid.
 */
function validateRtpHeaderExtensionParameters(ext) {
    if (typeof ext !== 'object') {
        throw new TypeError('ext is not an object');
    }
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string') {
        throw new TypeError('missing ext.uri');
    }
    // id is mandatory.
    if (typeof ext.id !== 'number') {
        throw new TypeError('missing ext.id');
    }
    // encrypt is optional. If unset set it to false.
    if (ext.encrypt && typeof ext.encrypt !== 'boolean') {
        throw new TypeError('invalid ext.encrypt');
    }
    else if (!ext.encrypt) {
        ext.encrypt = false;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!ext.parameters || typeof ext.parameters !== 'object') {
        ext.parameters = {};
    }
    for (const key of Object.keys(ext.parameters)) {
        let value = ext.parameters[key];
        if (value === undefined) {
            ext.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError('invalid header extension parameter');
        }
    }
}
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpEncodingParameters(encoding) {
    if (typeof encoding !== 'object') {
        throw new TypeError('encoding is not an object');
    }
    // ssrc is optional.
    if (encoding.ssrc && typeof encoding.ssrc !== 'number') {
        throw new TypeError('invalid encoding.ssrc');
    }
    // rid is optional.
    if (encoding.rid && typeof encoding.rid !== 'string') {
        throw new TypeError('invalid encoding.rid');
    }
    // rtx is optional.
    if (encoding.rtx && typeof encoding.rtx !== 'object') {
        throw new TypeError('invalid encoding.rtx');
    }
    else if (encoding.rtx) {
        // RTX ssrc is mandatory if rtx is present.
        if (typeof encoding.rtx.ssrc !== 'number') {
            throw new TypeError('missing encoding.rtx.ssrc');
        }
    }
    // dtx is optional. If unset set it to false.
    if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {
        encoding.dtx = false;
    }
    // scalabilityMode is optional.
    if (encoding.scalabilityMode &&
        typeof encoding.scalabilityMode !== 'string') {
        throw new TypeError('invalid encoding.scalabilityMode');
    }
}
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpParameters(rtcp) {
    if (typeof rtcp !== 'object') {
        throw new TypeError('rtcp is not an object');
    }
    // cname is optional.
    if (rtcp.cname && typeof rtcp.cname !== 'string') {
        throw new TypeError('invalid rtcp.cname');
    }
    // reducedSize is optional. If unset set it to true.
    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {
        rtcp.reducedSize = true;
    }
}


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/scalabilityModes.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/scalabilityModes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = void 0;
const ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})(_KEY)?');
function parse(scalabilityMode) {
    const match = ScalabilityModeRegex.exec(scalabilityMode || '');
    if (match) {
        return {
            spatialLayers: Number(match[1]),
            temporalLayers: Number(match[2]),
            ksvc: Boolean(match[3]),
        };
    }
    else {
        return {
            spatialLayers: 1,
            temporalLayers: 1,
            ksvc: false,
        };
    }
}
exports.parse = parse;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/supportedRtpCapabilities.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/supportedRtpCapabilities.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.supportedRtpCapabilities = void 0;
const supportedRtpCapabilities = {
    codecs: [
        {
            kind: 'audio',
            mimeType: 'audio/opus',
            clockRate: 48000,
            channels: 2,
            rtcpFeedback: [{ type: 'nack' }, { type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/multiopus',
            clockRate: 48000,
            channels: 4,
            // Quad channel.
            parameters: {
                channel_mapping: '0,1,2,3',
                num_streams: 2,
                coupled_streams: 2,
            },
            rtcpFeedback: [{ type: 'nack' }, { type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/multiopus',
            clockRate: 48000,
            channels: 6,
            // 5.1.
            parameters: {
                channel_mapping: '0,4,1,2,3,5',
                num_streams: 4,
                coupled_streams: 2,
            },
            rtcpFeedback: [{ type: 'nack' }, { type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/multiopus',
            clockRate: 48000,
            channels: 8,
            // 7.1.
            parameters: {
                channel_mapping: '0,6,1,2,3,4,5,7',
                num_streams: 5,
                coupled_streams: 3,
            },
            rtcpFeedback: [{ type: 'nack' }, { type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/PCMU',
            preferredPayloadType: 0,
            clockRate: 8000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/PCMA',
            preferredPayloadType: 8,
            clockRate: 8000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/ISAC',
            clockRate: 32000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/ISAC',
            clockRate: 16000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/G722',
            preferredPayloadType: 9,
            clockRate: 8000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/iLBC',
            clockRate: 8000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/SILK',
            clockRate: 24000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/SILK',
            clockRate: 16000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/SILK',
            clockRate: 12000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/SILK',
            clockRate: 8000,
            rtcpFeedback: [{ type: 'transport-cc' }],
        },
        {
            kind: 'audio',
            mimeType: 'audio/CN',
            preferredPayloadType: 13,
            clockRate: 32000,
        },
        {
            kind: 'audio',
            mimeType: 'audio/CN',
            preferredPayloadType: 13,
            clockRate: 16000,
        },
        {
            kind: 'audio',
            mimeType: 'audio/CN',
            preferredPayloadType: 13,
            clockRate: 8000,
        },
        {
            kind: 'audio',
            mimeType: 'audio/telephone-event',
            clockRate: 48000,
        },
        {
            kind: 'audio',
            mimeType: 'audio/telephone-event',
            clockRate: 32000,
        },
        {
            kind: 'audio',
            mimeType: 'audio/telephone-event',
            clockRate: 16000,
        },
        {
            kind: 'audio',
            mimeType: 'audio/telephone-event',
            clockRate: 8000,
        },
        {
            kind: 'video',
            mimeType: 'video/VP8',
            clockRate: 90000,
            rtcpFeedback: [
                { type: 'nack' },
                { type: 'nack', parameter: 'pli' },
                { type: 'ccm', parameter: 'fir' },
                { type: 'goog-remb' },
                { type: 'transport-cc' },
            ],
        },
        {
            kind: 'video',
            mimeType: 'video/VP9',
            clockRate: 90000,
            rtcpFeedback: [
                { type: 'nack' },
                { type: 'nack', parameter: 'pli' },
                { type: 'ccm', parameter: 'fir' },
                { type: 'goog-remb' },
                { type: 'transport-cc' },
            ],
        },
        {
            kind: 'video',
            mimeType: 'video/H264',
            clockRate: 90000,
            parameters: {
                'level-asymmetry-allowed': 1,
            },
            rtcpFeedback: [
                { type: 'nack' },
                { type: 'nack', parameter: 'pli' },
                { type: 'ccm', parameter: 'fir' },
                { type: 'goog-remb' },
                { type: 'transport-cc' },
            ],
        },
        {
            kind: 'video',
            mimeType: 'video/H264-SVC',
            clockRate: 90000,
            parameters: {
                'level-asymmetry-allowed': 1,
            },
            rtcpFeedback: [
                { type: 'nack' },
                { type: 'nack', parameter: 'pli' },
                { type: 'ccm', parameter: 'fir' },
                { type: 'goog-remb' },
                { type: 'transport-cc' },
            ],
        },
        {
            kind: 'video',
            mimeType: 'video/H265',
            clockRate: 90000,
            parameters: {
                'level-asymmetry-allowed': 1,
            },
            rtcpFeedback: [
                { type: 'nack' },
                { type: 'nack', parameter: 'pli' },
                { type: 'ccm', parameter: 'fir' },
                { type: 'goog-remb' },
                { type: 'transport-cc' },
            ],
        },
    ],
    headerExtensions: [
        {
            kind: 'audio',
            uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
            preferredId: 1,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'video',
            uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
            preferredId: 1,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'video',
            uri: 'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id',
            preferredId: 2,
            preferredEncrypt: false,
            direction: 'recvonly',
        },
        {
            kind: 'video',
            uri: 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id',
            preferredId: 3,
            preferredEncrypt: false,
            direction: 'recvonly',
        },
        {
            kind: 'audio',
            uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
            preferredId: 4,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'video',
            uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
            preferredId: 4,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        // NOTE: For audio we just enable transport-wide-cc-01 when receiving media.
        {
            kind: 'audio',
            uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
            preferredId: 5,
            preferredEncrypt: false,
            direction: 'recvonly',
        },
        {
            kind: 'video',
            uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
            preferredId: 5,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        // NOTE: Remove this once framemarking draft becomes RFC.
        {
            kind: 'video',
            uri: 'http://tools.ietf.org/html/draft-ietf-avtext-framemarking-07',
            preferredId: 6,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'video',
            uri: 'urn:ietf:params:rtp-hdrext:framemarking',
            preferredId: 7,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'audio',
            uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
            preferredId: 10,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'video',
            uri: 'urn:3gpp:video-orientation',
            preferredId: 11,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'video',
            uri: 'urn:ietf:params:rtp-hdrext:toffset',
            preferredId: 12,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'audio',
            uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time',
            preferredId: 13,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
        {
            kind: 'video',
            uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time',
            preferredId: 13,
            preferredEncrypt: false,
            direction: 'sendrecv',
        },
    ],
};
exports.supportedRtpCapabilities = supportedRtpCapabilities;


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/types.js":
/*!******************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/types.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./Worker */ "../../node_modules/mediasoup/node/lib/Worker.js"), exports);
__exportStar(__webpack_require__(/*! ./WebRtcServer */ "../../node_modules/mediasoup/node/lib/WebRtcServer.js"), exports);
__exportStar(__webpack_require__(/*! ./Router */ "../../node_modules/mediasoup/node/lib/Router.js"), exports);
__exportStar(__webpack_require__(/*! ./Transport */ "../../node_modules/mediasoup/node/lib/Transport.js"), exports);
__exportStar(__webpack_require__(/*! ./WebRtcTransport */ "../../node_modules/mediasoup/node/lib/WebRtcTransport.js"), exports);
__exportStar(__webpack_require__(/*! ./PlainTransport */ "../../node_modules/mediasoup/node/lib/PlainTransport.js"), exports);
__exportStar(__webpack_require__(/*! ./PipeTransport */ "../../node_modules/mediasoup/node/lib/PipeTransport.js"), exports);
__exportStar(__webpack_require__(/*! ./DirectTransport */ "../../node_modules/mediasoup/node/lib/DirectTransport.js"), exports);
__exportStar(__webpack_require__(/*! ./Producer */ "../../node_modules/mediasoup/node/lib/Producer.js"), exports);
__exportStar(__webpack_require__(/*! ./Consumer */ "../../node_modules/mediasoup/node/lib/Consumer.js"), exports);
__exportStar(__webpack_require__(/*! ./DataProducer */ "../../node_modules/mediasoup/node/lib/DataProducer.js"), exports);
__exportStar(__webpack_require__(/*! ./DataConsumer */ "../../node_modules/mediasoup/node/lib/DataConsumer.js"), exports);
__exportStar(__webpack_require__(/*! ./RtpObserver */ "../../node_modules/mediasoup/node/lib/RtpObserver.js"), exports);
__exportStar(__webpack_require__(/*! ./ActiveSpeakerObserver */ "../../node_modules/mediasoup/node/lib/ActiveSpeakerObserver.js"), exports);
__exportStar(__webpack_require__(/*! ./AudioLevelObserver */ "../../node_modules/mediasoup/node/lib/AudioLevelObserver.js"), exports);
__exportStar(__webpack_require__(/*! ./RtpParameters */ "../../node_modules/mediasoup/node/lib/RtpParameters.js"), exports);
__exportStar(__webpack_require__(/*! ./SctpParameters */ "../../node_modules/mediasoup/node/lib/SctpParameters.js"), exports);
__exportStar(__webpack_require__(/*! ./SrtpParameters */ "../../node_modules/mediasoup/node/lib/SrtpParameters.js"), exports);
__exportStar(__webpack_require__(/*! ./errors */ "../../node_modules/mediasoup/node/lib/errors.js"), exports);


/***/ }),

/***/ "../../node_modules/mediasoup/node/lib/utils.js":
/*!******************************************************!*\
  !*** ../../node_modules/mediasoup/node/lib/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deepFreeze = exports.parseStringStringArrayVector = exports.parseUint32StringVector = exports.parseUint16StringVector = exports.parseStringUint8Vector = exports.parseStringStringVector = exports.parseVector = exports.getRtpParametersType = exports.generateRandomNumber = exports.generateUUIDv4 = exports.clone = void 0;
const node_crypto_1 = __webpack_require__(/*! node:crypto */ "node:crypto");
const rtp_parameters_1 = __webpack_require__(/*! ./fbs/rtp-parameters */ "../../node_modules/mediasoup/node/lib/fbs/rtp-parameters.js");
/**
 * Clones the given value.
 */
function clone(value) {
    if (value === undefined) {
        return undefined;
    }
    else if (Number.isNaN(value)) {
        return NaN;
    }
    else if (typeof structuredClone === 'function') {
        // Available in Node >= 18.
        return structuredClone(value);
    }
    else {
        return JSON.parse(JSON.stringify(value));
    }
}
exports.clone = clone;
/**
 * Generates a random UUID v4.
 */
function generateUUIDv4() {
    return (0, node_crypto_1.randomUUID)();
}
exports.generateUUIDv4 = generateUUIDv4;
/**
 * Generates a random positive integer.
 */
function generateRandomNumber() {
    return (0, node_crypto_1.randomInt)(100_000_000, 999_999_999);
}
exports.generateRandomNumber = generateRandomNumber;
/**
 * Get the flatbuffers RtpParameters type for a given Producer.
 */
function getRtpParametersType(producerType, pipe) {
    if (pipe) {
        return rtp_parameters_1.Type.PIPE;
    }
    switch (producerType) {
        case 'simple': {
            return rtp_parameters_1.Type.SIMPLE;
        }
        case 'simulcast': {
            return rtp_parameters_1.Type.SIMULCAST;
        }
        case 'svc': {
            return rtp_parameters_1.Type.SVC;
        }
    }
}
exports.getRtpParametersType = getRtpParametersType;
/**
 * Parse flatbuffers vector into an array of the given type.
 */
function parseVector(binary, methodName, parseFn) {
    const array = [];
    for (let i = 0; i < binary[`${methodName}Length`](); ++i) {
        if (parseFn) {
            array.push(parseFn(binary[methodName](i)));
        }
        else {
            array.push(binary[methodName](i));
        }
    }
    return array;
}
exports.parseVector = parseVector;
/**
 * Parse flatbuffers vector of StringString into the corresponding array.
 */
function parseStringStringVector(binary, methodName) {
    const array = [];
    for (let i = 0; i < binary[`${methodName}Length`](); ++i) {
        const kv = binary[methodName](i);
        array.push({ key: kv.key(), value: kv.value() });
    }
    return array;
}
exports.parseStringStringVector = parseStringStringVector;
/**
 * Parse flatbuffers vector of StringUint8 into the corresponding array.
 */
function parseStringUint8Vector(binary, methodName) {
    const array = [];
    for (let i = 0; i < binary[`${methodName}Length`](); ++i) {
        const kv = binary[methodName](i);
        array.push({ key: kv.key(), value: kv.value() });
    }
    return array;
}
exports.parseStringUint8Vector = parseStringUint8Vector;
/**
 * Parse flatbuffers vector of Uint16String into the corresponding array.
 */
function parseUint16StringVector(binary, methodName) {
    const array = [];
    for (let i = 0; i < binary[`${methodName}Length`](); ++i) {
        const kv = binary[methodName](i);
        array.push({ key: kv.key(), value: kv.value() });
    }
    return array;
}
exports.parseUint16StringVector = parseUint16StringVector;
/**
 * Parse flatbuffers vector of Uint32String into the corresponding array.
 */
function parseUint32StringVector(binary, methodName) {
    const array = [];
    for (let i = 0; i < binary[`${methodName}Length`](); ++i) {
        const kv = binary[methodName](i);
        array.push({ key: kv.key(), value: kv.value() });
    }
    return array;
}
exports.parseUint32StringVector = parseUint32StringVector;
/**
 * Parse flatbuffers vector of StringStringArray into the corresponding array.
 */
function parseStringStringArrayVector(binary, methodName) {
    const array = [];
    for (let i = 0; i < binary[`${methodName}Length`](); ++i) {
        const kv = binary[methodName](i);
        const values = [];
        for (let i2 = 0; i2 < kv.valuesLength(); ++i2) {
            values.push(kv.values(i2));
        }
        array.push({ key: kv.key(), values });
    }
    return array;
}
exports.parseStringStringArrayVector = parseStringStringArrayVector;
/**
 * Make an object or array recursively immutable.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze.
 */
function deepFreeze(object) {
    // Retrieve the property names defined on object.
    const propNames = Reflect.ownKeys(object);
    // Freeze properties before freezing self.
    for (const name of propNames) {
        const value = object[name];
        if ((value && typeof value === 'object') || typeof value === 'function') {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}
exports.deepFreeze = deepFreeze;


/***/ }),

/***/ "../../node_modules/mediasoup/node_modules/debug/src/browser.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mediasoup/node_modules/debug/src/browser.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/mediasoup/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/mediasoup/node_modules/debug/src/common.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/mediasoup/node_modules/debug/src/common.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/mediasoup/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../node_modules/mediasoup/node_modules/debug/src/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mediasoup/node_modules/debug/src/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "../../node_modules/mediasoup/node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "../../node_modules/mediasoup/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "../../node_modules/mediasoup/node_modules/debug/src/node.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mediasoup/node_modules/debug/src/node.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "../../node_modules/mediasoup/node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/mediasoup/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "../../node_modules/mediasoup/node_modules/ms/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/mediasoup/node_modules/ms/index.js ***!
  \*************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/mime-db/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/mime-db/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(/*! ./db.json */ "../../node_modules/mime-db/db.json")


/***/ }),

/***/ "../../node_modules/mime-types/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/mime-types/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "../../node_modules/mime-db/index.js")
var extname = (__webpack_require__(/*! path */ "path").extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ "../../node_modules/negotiator/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/negotiator/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



var preferredCharsets = __webpack_require__(/*! ./lib/charset */ "../../node_modules/negotiator/lib/charset.js")
var preferredEncodings = __webpack_require__(/*! ./lib/encoding */ "../../node_modules/negotiator/lib/encoding.js")
var preferredLanguages = __webpack_require__(/*! ./lib/language */ "../../node_modules/negotiator/lib/language.js")
var preferredMediaTypes = __webpack_require__(/*! ./lib/mediaType */ "../../node_modules/negotiator/lib/mediaType.js")

/**
 * Module exports.
 * @public
 */

module.exports = Negotiator;
module.exports.Negotiator = Negotiator;

/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available) {
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};

// Backwards compatibility
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;


/***/ }),

/***/ "../../node_modules/negotiator/lib/charset.js":
/*!****************************************************!*\
  !*** ../../node_modules/negotiator/lib/charset.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;

/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */

function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;

  var charset = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a charset.
 * @private
 */

function getCharsetPriority(charset, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the charset.
 * @private
 */

function specify(charset, spec, index) {
  var s = 0;
  if(spec.charset.toLowerCase() === charset.toLowerCase()){
    s |= 1;
  } else if (spec.charset !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}

/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */

function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  });

  // sorted list of accepted charsets
  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full charset string.
 * @private
 */

function getFullCharset(spec) {
  return spec.charset;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "../../node_modules/negotiator/lib/encoding.js":
/*!*****************************************************!*\
  !*** ../../node_modules/negotiator/lib/encoding.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;

/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}

/**
 * Get the priority of an encoding.
 * @private
 */

function getEncodingPriority(encoding, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the encoding.
 * @private
 */

function specify(encoding, spec, index) {
  var s = 0;
  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
    s |= 1;
  } else if (spec.encoding !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  });

  // sorted list of accepted encodings
  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full encoding string.
 * @private
 */

function getFullEncoding(spec) {
  return spec.encoding;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "../../node_modules/negotiator/lib/language.js":
/*!*****************************************************!*\
  !*** ../../node_modules/negotiator/lib/language.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;

/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 */

function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  var prefix = match[1]
  var suffix = match[2]
  var full = prefix

  if (suffix) full += "-" + suffix;

  var q = 1;
  if (match[3]) {
    var params = match[3].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}

/**
 * Get the priority of a language.
 * @private
 */

function getLanguagePriority(language, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 */

function specify(language, spec, index) {
  var p = parseLanguage(language)
  if (!p) return null;
  var s = 0;
  if(spec.full.toLowerCase() === p.full.toLowerCase()){
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  });

  // sorted list of accepted languages
  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full language string.
 * @private
 */

function getFullLanguage(spec) {
  return spec.full;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),

/***/ "../../node_modules/negotiator/lib/mediaType.js":
/*!******************************************************!*\
  !*** ../../node_modules/negotiator/lib/mediaType.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;

/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a media type from the Accept header.
 * @private
 */

function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;

  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];

      // get the value, unwrapping quotes
      var value = val && val[0] === '"' && val[val.length - 1] === '"'
        ? val.substr(1, val.length - 2)
        : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      }

      // store parameter
      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a media type.
 * @private
 */

function getMediaTypePriority(type, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the media type.
 * @private
 */

function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4
  } else if(spec.type != '*') {
    return null;
  }

  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2
  } else if(spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1
    } else {
      return null
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s,
  }
}

/**
 * Get the preferred media types from an Accept header.
 * @public
 */

function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  });

  // sorted list of accepted types
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full type string.
 * @private
 */

function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}

/**
 * Count the number of quotes in a string.
 * @private
 */

function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}

/**
 * Split a key value pair.
 * @private
 */

function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}

/**
 * Split an Accept header into media types.
 * @private
 */

function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  }

  // trim accepts
  accepts.length = j + 1;

  return accepts;
}

/**
 * Split a string of parameters.
 * @private
 */

function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  }

  // trim parameters
  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}


/***/ }),

/***/ "../../node_modules/object-assign/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "../../node_modules/socket.io-adapter/dist/contrib/yeast.js":
/*!******************************************************************!*\
  !*** ../../node_modules/socket.io-adapter/dist/contrib/yeast.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
// imported from https://github.com/unshiftio/yeast

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.yeast = exports.decode = exports.encode = void 0;
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i = 0, prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
    let encoded = "";
    do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
}
exports.encode = encode;
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
    let decoded = 0;
    for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
    }
    return decoded;
}
exports.decode = decode;
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
    const now = encode(+new Date());
    if (now !== prev)
        return (seed = 0), (prev = now);
    return now + "." + encode(seed++);
}
exports.yeast = yeast;
//
// Map each character to its index.
//
for (; i < length; i++)
    map[alphabet[i]] = i;


/***/ }),

/***/ "../../node_modules/socket.io-adapter/dist/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/socket.io-adapter/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionAwareAdapter = exports.Adapter = void 0;
const events_1 = __webpack_require__(/*! events */ "events");
const yeast_1 = __webpack_require__(/*! ./contrib/yeast */ "../../node_modules/socket.io-adapter/dist/contrib/yeast.js");
const WebSocket = __webpack_require__(/*! ws */ "../../node_modules/ws/index.js");
const canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === "function";
class Adapter extends events_1.EventEmitter {
    /**
     * In-memory adapter constructor.
     *
     * @param {Namespace} nsp
     */
    constructor(nsp) {
        super();
        this.nsp = nsp;
        this.rooms = new Map();
        this.sids = new Map();
        this.encoder = nsp.server.encoder;
    }
    /**
     * To be overridden
     */
    init() { }
    /**
     * To be overridden
     */
    close() { }
    /**
     * Returns the number of Socket.IO servers in the cluster
     *
     * @public
     */
    serverCount() {
        return Promise.resolve(1);
    }
    /**
     * Adds a socket to a list of room.
     *
     * @param {SocketId}  id      the socket id
     * @param {Set<Room>} rooms   a set of rooms
     * @public
     */
    addAll(id, rooms) {
        if (!this.sids.has(id)) {
            this.sids.set(id, new Set());
        }
        for (const room of rooms) {
            this.sids.get(id).add(room);
            if (!this.rooms.has(room)) {
                this.rooms.set(room, new Set());
                this.emit("create-room", room);
            }
            if (!this.rooms.get(room).has(id)) {
                this.rooms.get(room).add(id);
                this.emit("join-room", room, id);
            }
        }
    }
    /**
     * Removes a socket from a room.
     *
     * @param {SocketId} id     the socket id
     * @param {Room}     room   the room name
     */
    del(id, room) {
        if (this.sids.has(id)) {
            this.sids.get(id).delete(room);
        }
        this._del(room, id);
    }
    _del(room, id) {
        const _room = this.rooms.get(room);
        if (_room != null) {
            const deleted = _room.delete(id);
            if (deleted) {
                this.emit("leave-room", room, id);
            }
            if (_room.size === 0 && this.rooms.delete(room)) {
                this.emit("delete-room", room);
            }
        }
    }
    /**
     * Removes a socket from all rooms it's joined.
     *
     * @param {SocketId} id   the socket id
     */
    delAll(id) {
        if (!this.sids.has(id)) {
            return;
        }
        for (const room of this.sids.get(id)) {
            this._del(room, id);
        }
        this.sids.delete(id);
    }
    /**
     * Broadcasts a packet.
     *
     * Options:
     *  - `flags` {Object} flags for this packet
     *  - `except` {Array} sids that should be excluded
     *  - `rooms` {Array} list of rooms to broadcast to
     *
     * @param {Object} packet   the packet object
     * @param {Object} opts     the options
     * @public
     */
    broadcast(packet, opts) {
        const flags = opts.flags || {};
        const packetOpts = {
            preEncoded: true,
            volatile: flags.volatile,
            compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        const encodedPackets = this._encode(packet, packetOpts);
        this.apply(opts, (socket) => {
            if (typeof socket.notifyOutgoingListeners === "function") {
                socket.notifyOutgoingListeners(packet);
            }
            socket.client.writeToEngine(encodedPackets, packetOpts);
        });
    }
    /**
     * Broadcasts a packet and expects multiple acknowledgements.
     *
     * Options:
     *  - `flags` {Object} flags for this packet
     *  - `except` {Array} sids that should be excluded
     *  - `rooms` {Array} list of rooms to broadcast to
     *
     * @param {Object} packet   the packet object
     * @param {Object} opts     the options
     * @param clientCountCallback - the number of clients that received the packet
     * @param ack                 - the callback that will be called for each client response
     *
     * @public
     */
    broadcastWithAck(packet, opts, clientCountCallback, ack) {
        const flags = opts.flags || {};
        const packetOpts = {
            preEncoded: true,
            volatile: flags.volatile,
            compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        // we can use the same id for each packet, since the _ids counter is common (no duplicate)
        packet.id = this.nsp._ids++;
        const encodedPackets = this._encode(packet, packetOpts);
        let clientCount = 0;
        this.apply(opts, (socket) => {
            // track the total number of acknowledgements that are expected
            clientCount++;
            // call the ack callback for each client response
            socket.acks.set(packet.id, ack);
            if (typeof socket.notifyOutgoingListeners === "function") {
                socket.notifyOutgoingListeners(packet);
            }
            socket.client.writeToEngine(encodedPackets, packetOpts);
        });
        clientCountCallback(clientCount);
    }
    _encode(packet, packetOpts) {
        const encodedPackets = this.encoder.encode(packet);
        if (canPreComputeFrame &&
            encodedPackets.length === 1 &&
            typeof encodedPackets[0] === "string") {
            // "4" being the "message" packet type in the Engine.IO protocol
            const data = Buffer.from("4" + encodedPackets[0]);
            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469
            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {
                readOnly: false,
                mask: false,
                rsv1: false,
                opcode: 1,
                fin: true,
            });
        }
        return encodedPackets;
    }
    /**
     * Gets a list of sockets by sid.
     *
     * @param {Set<Room>} rooms   the explicit set of rooms to check.
     */
    sockets(rooms) {
        const sids = new Set();
        this.apply({ rooms }, (socket) => {
            sids.add(socket.id);
        });
        return Promise.resolve(sids);
    }
    /**
     * Gets the list of rooms a given socket has joined.
     *
     * @param {SocketId} id   the socket id
     */
    socketRooms(id) {
        return this.sids.get(id);
    }
    /**
     * Returns the matching socket instances
     *
     * @param opts - the filters to apply
     */
    fetchSockets(opts) {
        const sockets = [];
        this.apply(opts, (socket) => {
            sockets.push(socket);
        });
        return Promise.resolve(sockets);
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to join
     */
    addSockets(opts, rooms) {
        this.apply(opts, (socket) => {
            socket.join(rooms);
        });
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to leave
     */
    delSockets(opts, rooms) {
        this.apply(opts, (socket) => {
            rooms.forEach((room) => socket.leave(room));
        });
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param opts - the filters to apply
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(opts, close) {
        this.apply(opts, (socket) => {
            socket.disconnect(close);
        });
    }
    apply(opts, callback) {
        const rooms = opts.rooms;
        const except = this.computeExceptSids(opts.except);
        if (rooms.size) {
            const ids = new Set();
            for (const room of rooms) {
                if (!this.rooms.has(room))
                    continue;
                for (const id of this.rooms.get(room)) {
                    if (ids.has(id) || except.has(id))
                        continue;
                    const socket = this.nsp.sockets.get(id);
                    if (socket) {
                        callback(socket);
                        ids.add(id);
                    }
                }
            }
        }
        else {
            for (const [id] of this.sids) {
                if (except.has(id))
                    continue;
                const socket = this.nsp.sockets.get(id);
                if (socket)
                    callback(socket);
            }
        }
    }
    computeExceptSids(exceptRooms) {
        const exceptSids = new Set();
        if (exceptRooms && exceptRooms.size > 0) {
            for (const room of exceptRooms) {
                if (this.rooms.has(room)) {
                    this.rooms.get(room).forEach((sid) => exceptSids.add(sid));
                }
            }
        }
        return exceptSids;
    }
    /**
     * Send a packet to the other Socket.IO servers in the cluster
     * @param packet - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(packet) {
        console.warn("this adapter does not support the serverSideEmit() functionality");
    }
    /**
     * Save the client session in order to restore it upon reconnection.
     */
    persistSession(session) { }
    /**
     * Restore the session and find the packets that were missed by the client.
     * @param pid
     * @param offset
     */
    restoreSession(pid, offset) {
        return null;
    }
}
exports.Adapter = Adapter;
class SessionAwareAdapter extends Adapter {
    constructor(nsp) {
        super(nsp);
        this.nsp = nsp;
        this.sessions = new Map();
        this.packets = [];
        this.maxDisconnectionDuration =
            nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
        const timer = setInterval(() => {
            const threshold = Date.now() - this.maxDisconnectionDuration;
            this.sessions.forEach((session, sessionId) => {
                const hasExpired = session.disconnectedAt < threshold;
                if (hasExpired) {
                    this.sessions.delete(sessionId);
                }
            });
            for (let i = this.packets.length - 1; i >= 0; i--) {
                const hasExpired = this.packets[i].emittedAt < threshold;
                if (hasExpired) {
                    this.packets.splice(0, i + 1);
                    break;
                }
            }
        }, 60 * 1000);
        // prevents the timer from keeping the process alive
        timer.unref();
    }
    persistSession(session) {
        session.disconnectedAt = Date.now();
        this.sessions.set(session.pid, session);
    }
    restoreSession(pid, offset) {
        const session = this.sessions.get(pid);
        if (!session) {
            // the session may have expired
            return null;
        }
        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
        if (hasExpired) {
            // the session has expired
            this.sessions.delete(pid);
            return null;
        }
        const index = this.packets.findIndex((packet) => packet.id === offset);
        if (index === -1) {
            // the offset may be too old
            return null;
        }
        const missedPackets = [];
        for (let i = index + 1; i < this.packets.length; i++) {
            const packet = this.packets[i];
            if (shouldIncludePacket(session.rooms, packet.opts)) {
                missedPackets.push(packet.data);
            }
        }
        return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));
    }
    broadcast(packet, opts) {
        var _a;
        const isEventPacket = packet.type === 2;
        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and
        // restored on another server upon reconnection
        const withoutAcknowledgement = packet.id === undefined;
        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;
        if (isEventPacket && withoutAcknowledgement && notVolatile) {
            const id = (0, yeast_1.yeast)();
            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has
            // processed (and the format is backward-compatible)
            packet.data.push(id);
            this.packets.push({
                id,
                opts,
                data: packet.data,
                emittedAt: Date.now(),
            });
        }
        super.broadcast(packet, opts);
    }
}
exports.SessionAwareAdapter = SessionAwareAdapter;
function shouldIncludePacket(sessionRooms, opts) {
    const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));
    const notExcluded = sessionRooms.every((room) => !opts.except.has(room));
    return included && notExcluded;
}


/***/ }),

/***/ "../../node_modules/socket.io-parser/node_modules/debug/src/browser.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/socket.io-parser/node_modules/debug/src/browser.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/socket.io-parser/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/socket.io-parser/node_modules/debug/src/common.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/socket.io-parser/node_modules/debug/src/common.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/socket.io-parser/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../node_modules/socket.io-parser/node_modules/debug/src/index.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/socket.io-parser/node_modules/debug/src/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "../../node_modules/socket.io-parser/node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "../../node_modules/socket.io-parser/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "../../node_modules/socket.io-parser/node_modules/debug/src/node.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/socket.io-parser/node_modules/debug/src/node.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "../../node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/socket.io-parser/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "../../node_modules/socket.io-parser/node_modules/ms/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/socket.io-parser/node_modules/ms/index.js ***!
  \********************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/socket.io/node_modules/debug/src/browser.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/socket.io/node_modules/debug/src/browser.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/socket.io/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/socket.io/node_modules/debug/src/common.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/socket.io/node_modules/debug/src/common.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/socket.io/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../node_modules/socket.io/node_modules/debug/src/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/socket.io/node_modules/debug/src/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "../../node_modules/socket.io/node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "../../node_modules/socket.io/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "../../node_modules/socket.io/node_modules/debug/src/node.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/socket.io/node_modules/debug/src/node.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "../../node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/socket.io/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "../../node_modules/socket.io/node_modules/ms/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/socket.io/node_modules/ms/index.js ***!
  \*************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/supports-color/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/supports-color/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "../../node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "./src/configure.ts":
/*!**************************!*\
  !*** ./src/configure.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ANNOUNCED_IP: () => (/* binding */ ANNOUNCED_IP),
/* harmony export */   LISTEN_IP: () => (/* binding */ LISTEN_IP),
/* harmony export */   LISTEN_PORT: () => (/* binding */ LISTEN_PORT),
/* harmony export */   LOG_LEVEL: () => (/* binding */ LOG_LEVEL),
/* harmony export */   MEDIA_CODECS: () => (/* binding */ MEDIA_CODECS),
/* harmony export */   RTC_MAX_PORT: () => (/* binding */ RTC_MAX_PORT),
/* harmony export */   RTC_MIN_PORT: () => (/* binding */ RTC_MIN_PORT)
/* harmony export */ });
const LISTEN_PORT = parseInt(process.env.MEDIASOUP_LISTEN_PORT) || 3000;
const LISTEN_IP = process.env.MEDIASOUP_LISTEN_IP || '127.0.0.1';
const ANNOUNCED_IP = process.env.MEDIASOUP_ANNOUNCED_IP || '127.0.0.1';
// TODO: Configurable
const RTC_MAX_PORT = parseInt(process.env.MEDIASOUP_RTC_MAX_PORT) || 2100;
const RTC_MIN_PORT = parseInt(process.env.MEDIASOUP_RTC_MIN_PORT) || 2000;
const LOG_LEVEL = 'debug';
const MEDIA_CODECS = [
    {
        kind: 'audio',
        mimeType: 'audio/opus',
        clockRate: 48000,
        channels: 2
    },
    {
        kind: 'video',
        mimeType: 'video/VP8',
        clockRate: 90000,
        parameters: {
            'x-google-start-bitrate': 1000
        }
    }
];


/***/ }),

/***/ "./src/logger.ts":
/*!***********************!*\
  !*** ./src/logger.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   Logger: () => (/* binding */ Logger)
/* harmony export */ });
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["debug"] = 0] = "debug";
    LogLevel[LogLevel["info"] = 1] = "info";
    LogLevel[LogLevel["log"] = 2] = "log";
    LogLevel[LogLevel["warn"] = 3] = "warn";
    LogLevel[LogLevel["error"] = 4] = "error";
    LogLevel[LogLevel["none"] = 5] = "none";
})(LogLevel || (LogLevel = {}));
;
const timestamp = () => {
    return (performance.now() * 1000).toFixed(0);
};
class Logger {
    static setLevel(level) {
        Logger.level = level;
    }
    static debug(message) {
        if (LogLevel.debug >= Logger.level) {
            console.debug(`[debug:${timestamp()}] ${message}`);
        }
    }
    static info(message) {
        if (LogLevel.info >= Logger.level) {
            console.info(`[info:${timestamp()}] ${message}`);
        }
    }
    static log(message) {
        if (LogLevel.log >= Logger.level) {
            console.log(`[log:${timestamp()}] ${message}`);
        }
    }
    static warn(message) {
        if (LogLevel.warn >= Logger.level) {
            console.warn(`[warn:${timestamp()}] ${message}`);
        }
    }
    static error(message) {
        if (LogLevel.error >= Logger.level) {
            console.error(`[error:${timestamp()}]`, message);
        }
    }
}
Logger.level = LogLevel.debug;


/***/ }),

/***/ "./src/message.ts":
/*!************************!*\
  !*** ./src/message.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getConsumerParams: () => (/* binding */ getConsumerParams),
/* harmony export */   getTransportParams: () => (/* binding */ getTransportParams)
/* harmony export */ });
const getTransportParams = (transport) => {
    return {
        id: transport.id,
        iceParameters: transport.iceParameters,
        iceCandidates: transport.iceCandidates,
        dtlsParameters: transport.dtlsParameters
    };
};
const getConsumerParams = (consumerPeerId, producerPeerId, producerId, consumer) => {
    return {
        id: consumer.id,
        consumerPeerId,
        producerPeerId,
        producerId,
        kind: consumer.kind,
        rtpParameters: consumer.rtpParameters,
        type: consumer.type,
        producerPaused: consumer.producerPaused
    };
};


/***/ }),

/***/ "./src/peer.ts":
/*!*********************!*\
  !*** ./src/peer.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Peer: () => (/* binding */ Peer)
/* harmony export */ });
class Peer {
    constructor(id) {
        this.id = id;
        this._rtpCapabilities = null;
        this._joined = false;
        this._consumerIds = new Set();
        this._consumerTransportId = null;
        this._producerIds = new Set();
        this._producerTransportId = null;
    }
    get joined() {
        return this._joined;
    }
    get producerTransportId() {
        return this._producerTransportId;
    }
    get consumerTransportId() {
        return this._consumerTransportId;
    }
    // This getter must be called after join
    get rtpCapabilities() {
        return this._rtpCapabilities;
    }
    get producerIds() {
        const ids = [];
        for (const id of this._producerIds.values()) {
            ids.push(id);
        }
        return ids;
    }
    get consumerIds() {
        const ids = [];
        for (const id of this._consumerIds.values()) {
            ids.push(id);
        }
        return ids;
    }
    join(rtpCapabilities) {
        if (this.joined === true) {
            throw new Error(`Peer ${this.id} has already joined.`);
        }
        this._joined = true;
        this._rtpCapabilities = rtpCapabilities;
    }
    leave() {
        if (this.joined === false) {
            throw new Error(`Peer ${this.id} has not joined.`);
        }
        this._joined = false;
        this._rtpCapabilities = null;
    }
    dispose() {
        // TODO: Implement
    }
    setConsumerTransportId(id) {
        if (id !== null && this.consumerTransportId !== null) {
            throw new Error(`Consumer transport is already set.`);
        }
        else if (id === null && this.consumerTransportId === null) {
            throw new Error(`Consumer transport is already unset.`);
        }
        this._consumerTransportId = id;
    }
    setProducerTransportId(id) {
        if (id !== null && this.producerTransportId !== null) {
            throw new Error(`Producer transport is already set.`);
        }
        else if (id === null && this.producerTransportId === null) {
            throw new Error(`Producer transport is already unset.`);
        }
        this._producerTransportId = id;
    }
    addConsumerId(id) {
        if (this._consumerIds.has(id)) {
            throw new Error(`Consumer ${id} is already registered.`);
        }
        this._consumerIds.add(id);
    }
    clearConsumerIds() {
        this._consumerIds.clear();
    }
    addProducerId(id) {
        if (this._producerIds.has(id)) {
            throw new Error(`Producer ${id} is already registered.`);
        }
        this._producerIds.add(id);
    }
    clearProducerIds() {
        this._producerIds.clear();
    }
}


/***/ }),

/***/ "./src/room.ts":
/*!*********************!*\
  !*** ./src/room.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Room: () => (/* binding */ Room)
/* harmony export */ });
/* harmony import */ var _configure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configure */ "./src/configure.ts");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message */ "./src/message.ts");
/* harmony import */ var _peer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./peer */ "./src/peer.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class Room {
    static create(id, worker) {
        return __awaiter(this, void 0, void 0, function* () {
            const router = yield worker.createRouter({
                mediaCodecs: _configure__WEBPACK_IMPORTED_MODULE_0__.MEDIA_CODECS
            });
            return new Room(id, router);
        });
    }
    constructor(id, router) {
        this.id = id;
        this.router = router;
        this.consumers = new Map();
        this.consumerTransports = new Map();
        this.peers = new Map();
        this.producers = new Map();
        this.producerTransports = new Map();
    }
    get rtpCapabilities() {
        return this.router.rtpCapabilities;
    }
    get peerIds() {
        const ids = [];
        for (const p of this.peers.values()) {
            ids.push(p.id);
        }
        return ids;
    }
    get joinnedPeerIds() {
        const ids = [];
        for (const p of this.peers.values()) {
            if (p.joined) {
                ids.push(p.id);
            }
        }
        return ids;
    }
    close() {
        // TODO: Implement
    }
    hasPeer(peerId) {
        return this.peers.has(peerId);
    }
    getPeer(peerId) {
        return this.peers.get(peerId);
    }
    mustBeInRoom(peerId) {
        if (!this.peers.has(peerId)) {
            throw new Error(`Peer ${peerId} is not found in the Room ${this.id}.`);
        }
    }
    mustNotBeInRoom(peerId) {
        if (this.peers.has(peerId)) {
            throw new Error(`Peer ${peerId} is already in the Room ${this.id}.`);
        }
    }
    enter(peerId) {
        this.mustNotBeInRoom(peerId);
        this.peers.set(peerId, new _peer__WEBPACK_IMPORTED_MODULE_2__.Peer(peerId));
    }
    exit(peerId) {
        this.mustBeInRoom(peerId);
        this.closeProducerTransport(peerId);
        this.closeConsumerTransport(peerId);
        this.closeProducers(peerId);
        this.closeConsumers(peerId);
        this.peers.get(peerId).dispose();
        this.peers.delete(peerId);
    }
    join(peerId, rtpCapabilities) {
        this.mustBeInRoom(peerId);
        this.peers.get(peerId).join(rtpCapabilities);
    }
    leave(peerId) {
        this.mustBeInRoom(peerId);
        this.closeProducerTransport(peerId);
        this.closeConsumerTransport(peerId);
        this.closeProducers(peerId);
        this.closeConsumers(peerId);
        this.peers.get(peerId).leave();
        this.peers.delete(peerId);
    }
    empty() {
        return this.peers.size === 0;
    }
    createWebRtcTransport() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.router.createWebRtcTransport({
                listenIps: [{ announcedIp: _configure__WEBPACK_IMPORTED_MODULE_0__.ANNOUNCED_IP, ip: _configure__WEBPACK_IMPORTED_MODULE_0__.LISTEN_IP }],
                // TODO: Configurable
                enableUdp: true,
                enableTcp: true,
                preferUdp: true
            });
        });
    }
    createProducerTransport(peerId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.mustBeInRoom(peerId);
            const transport = yield this.createWebRtcTransport();
            // TODO: What if the peer has already left and entered again the room?
            if (!this.peers.has(peerId) || !this.peers.get(peerId).joined) {
                transport.close();
                throw new Error(`Peer ${peerId} has already been left while waiting for producer transport creation.`);
            }
            this.producerTransports.set(transport.id, transport);
            this.peers.get(peerId).setProducerTransportId(transport.id);
            return (0,_message__WEBPACK_IMPORTED_MODULE_1__.getTransportParams)(transport);
        });
    }
    closeProducerTransport(peerId) {
        this.mustBeInRoom(peerId);
        const peer = this.peers.get(peerId);
        if (peer.producerTransportId !== null) {
            const transportId = peer.producerTransportId;
            const transport = this.producerTransports.get(transportId);
            transport.close();
            peer.setProducerTransportId(null);
        }
    }
    createConsumerTransport(peerId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.mustBeInRoom(peerId);
            const transport = yield this.createWebRtcTransport();
            // TODO: What if the peer has already left and entered again the room?
            if (!this.peers.has(peerId) || !this.peers.get(peerId).joined) {
                transport.close();
                throw new Error(`Peer ${peerId} has already been left while waiting for consumer transport creation.`);
            }
            this.consumerTransports.set(transport.id, transport);
            this.peers.get(peerId).setConsumerTransportId(transport.id);
            return (0,_message__WEBPACK_IMPORTED_MODULE_1__.getTransportParams)(transport);
        });
    }
    closeConsumerTransport(peerId) {
        this.mustBeInRoom(peerId);
        const peer = this.peers.get(peerId);
        if (peer.consumerTransportId !== null) {
            const transportId = peer.consumerTransportId;
            const transport = this.consumerTransports.get(transportId);
            transport.close();
            peer.setConsumerTransportId(null);
        }
    }
    connectProducerTransport(peerId, dtlsParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            this.mustBeInRoom(peerId);
            const transportId = this.peers.get(peerId).producerTransportId;
            if (transportId === null) {
                throw new Error(`Peer ${peerId} doesn't have producer transport.`);
            }
            if (!this.producerTransports.has(transportId)) {
                throw new Error(`Producer transport ${transportId} of Peer ${peerId} is not found.`);
            }
            yield this.producerTransports.get(transportId).connect({ dtlsParameters });
        });
    }
    connectConsumerTransport(peerId, dtlsParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            this.mustBeInRoom(peerId);
            const transportId = this.peers.get(peerId).consumerTransportId;
            if (transportId === null) {
                throw new Error(`Peer ${peerId} doesn't have consumer transport.`);
            }
            if (!this.consumerTransports.has(transportId)) {
                throw new Error(`Consumer transport ${transportId} of Peer ${peerId} is not found.`);
            }
            yield this.consumerTransports.get(transportId).connect({ dtlsParameters });
        });
    }
    produce(peerId, kind, rtpParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            this.mustBeInRoom(peerId);
            const peer = this.peers.get(peerId);
            const transportId = peer.producerTransportId;
            if (transportId === null) {
                throw new Error(`Peer ${peerId} doesn't have consumer transport yet.`);
            }
            if (!this.producerTransports.has(transportId)) {
                throw new Error(`Producer transport ${transportId} is not found.`);
            }
            const producer = yield this.producerTransports.get(transportId).produce({
                kind,
                rtpParameters
            });
            if (!this.peers.has(peerId) || !this.peers.get(peerId).joined) {
                producer.close();
                throw new Error(`Peer ${peerId} has already left while waiting for producer creation.`);
            }
            this.producers.set(producer.id, producer);
            peer.addProducerId(producer.id);
            return producer.id;
        });
    }
    closeProducers(peerId) {
        this.mustBeInRoom(peerId);
        const peer = this.peers.get(peerId);
        for (const producerId of peer.producerIds) {
            const producer = this.producers.get(producerId);
            producer.close();
        }
        peer.clearProducerIds();
    }
    consume(consumerPeerId, producerPeerId, producerId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.mustBeInRoom(consumerPeerId);
            this.mustBeInRoom(producerPeerId);
            if (!this.producers.has(producerId)) {
                throw new Error(`Producer ${producerId} is not found.`);
            }
            const consumerPeer = this.peers.get(consumerPeerId);
            const transportId = consumerPeer.consumerTransportId;
            if (transportId === null) {
                throw new Error(`Consumer peer ${consumerPeerId} doesn't have consumer transport yet.`);
            }
            if (!this.consumerTransports.has(transportId)) {
                throw new Error(`Consumer transport ${transportId} is not found.`);
            }
            const consumer = yield this.consumerTransports.get(transportId).consume({
                producerId: producerId,
                rtpCapabilities: consumerPeer.rtpCapabilities,
                paused: true
            });
            if (!this.peers.has(producerPeerId) || !this.peers.get(producerPeerId).joined) {
                throw new Error(`Producer peer ${producerPeerId} has already left while waiting for consumer creation.`);
            }
            if (!this.peers.has(consumerPeerId) || !this.peers.get(consumerPeerId).joined) {
                throw new Error(`Consumer peer ${consumerPeerId} has already left while waiting for consumer creation.`);
            }
            // TODO: Record producerPeerId - consumer association and
            //       close condumer when it's producer peer is left.
            this.consumers.set(consumer.id, consumer);
            consumerPeer.addConsumerId(consumer.id);
            return (0,_message__WEBPACK_IMPORTED_MODULE_1__.getConsumerParams)(consumerPeerId, producerPeerId, producerId, consumer);
        });
    }
    closeConsumers(peerId) {
        this.mustBeInRoom(peerId);
        const peer = this.peers.get(peerId);
        for (const consumerId of peer.consumerIds) {
            const consumer = this.consumers.get(consumerId);
            consumer.close();
        }
        peer.clearConsumerIds();
    }
    resumeConsumer(consumerId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.consumers.has(consumerId)) {
                throw new Error(`Consumer ${consumerId} is not found.`);
            }
            yield this.consumers.get(consumerId).resume();
        });
    }
}


/***/ }),

/***/ "./src/server.ts":
/*!***********************!*\
  !*** ./src/server.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Server: () => (/* binding */ Server)
/* harmony export */ });
/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! express */ "express");
/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(express__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ "http");
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mediasoup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mediasoup */ "../../node_modules/mediasoup/node/lib/index.js");
/* harmony import */ var socket_io__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io */ "../../node_modules/socket.io/wrapper.mjs");
/* harmony import */ var _configure__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./configure */ "./src/configure.ts");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logger */ "./src/logger.ts");
/* harmony import */ var _room__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./room */ "./src/room.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







// TODO: Avoid race conditions when multiple threads are used.
class Server {
    static create() {
        return __awaiter(this, void 0, void 0, function* () {
            _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.info('Create servers.');
            // WebServer
            const app = express__WEBPACK_IMPORTED_MODULE_0___default()();
            app.use(express__WEBPACK_IMPORTED_MODULE_0___default()["static"](__dirname));
            const webServer = http__WEBPACK_IMPORTED_MODULE_1___default().createServer(app);
            // SocketServer
            const socketServer = new socket_io__WEBPACK_IMPORTED_MODULE_3__.Server(webServer, {
                // TODO: Proper configuration
                cors: {
                    origin: '*'
                }
            });
            // Mediasoup Worker
            const worker = yield mediasoup__WEBPACK_IMPORTED_MODULE_2__.createWorker({
                logLevel: _configure__WEBPACK_IMPORTED_MODULE_4__.LOG_LEVEL,
                rtcMaxPort: _configure__WEBPACK_IMPORTED_MODULE_4__.RTC_MAX_PORT,
                rtcMinPort: _configure__WEBPACK_IMPORTED_MODULE_4__.RTC_MIN_PORT
            });
            const server = new Server(webServer, socketServer, worker);
            yield server.initWebServer();
            server.initSocketServer();
            return server;
        });
    }
    constructor(webServer, socketServer, worker) {
        this.worker = worker;
        this.webServer = webServer;
        this.socketServer = socketServer;
        this.peerIdToSocket = new Map();
        this.socketInfos = new Map();
        this.rooms = new Map();
    }
    close() {
        _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.info('Close servers.');
        // TODO: Implement properly
        this.worker.close();
        this.webServer.close();
        this.socketServer.close();
        for (const room of this.rooms.values()) {
            room.close();
        }
        this.rooms.clear();
    }
    initWebServer() {
        return __awaiter(this, void 0, void 0, function* () {
            _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.info('Initialize Web server.');
            const server = this.webServer;
            server.on('error', (error) => {
                // TODO: Proper error handling
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.error(error);
            });
            yield new Promise((resolve) => {
                server.listen(_configure__WEBPACK_IMPORTED_MODULE_4__.LISTEN_PORT, _configure__WEBPACK_IMPORTED_MODULE_4__.LISTEN_IP, () => {
                    _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.info(`Web server is running at http://${_configure__WEBPACK_IMPORTED_MODULE_4__.LISTEN_IP}:${_configure__WEBPACK_IMPORTED_MODULE_4__.LISTEN_PORT}.`);
                    resolve(undefined);
                });
            });
        });
    }
    initSocketServer() {
        _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.info('Initialize Socket server.');
        const rooms = this.rooms;
        const server = this.socketServer;
        const worker = this.worker;
        // TODO: Add types for parameters and callbacks
        server.on('connection', (socket) => {
            _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket ${socket.id} is connected.`);
            // Helpers
            // TODO: Avoid any
            const callErrorCallback = (errorback, error) => {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.error(error);
                errorback({ error: error.message });
            };
            const socketMustHaveEntered = (errorback) => {
                if (!this.socketInfos.has(socket)) {
                    // TODO: Handle properly
                    callErrorCallback(errorback, new Error(`Socket ${socket.id} has not entered any Room.`));
                    return false;
                }
                return true;
            };
            const socketMustNotHaveEntered = (errorback) => {
                if (this.socketInfos.has(socket)) {
                    // TODO: Handle properly
                    const { peerId, roomId } = this.socketInfos.get(socket);
                    callErrorCallback(errorback, new Error(`Socket ${socket.id} has alerady entered Room ${roomId} as Peer ${peerId}.`));
                    return false;
                }
                return true;
            };
            const roomMustExist = (roomId, errorback) => {
                if (!rooms.has(roomId)) {
                    // TODO: Proper error handling
                    callErrorCallback(errorback, new Error(`Unknown Room ${roomId}.`));
                    return false;
                }
                return true;
            };
            const peerMustBeInRoom = (roomId, peerId, errorback) => {
                // Room existence must be checked beforehand
                if (!rooms.get(roomId).hasPeer(peerId)) {
                    callErrorCallback(errorback, new Error(`Peer ${peerId} already exists in Room ${roomId}.`));
                    return false;
                }
                return true;
            };
            const peerMustNotBeInRoom = (roomId, peerId, errorback) => {
                // Room existence must be checked beforehand
                if (rooms.get(roomId).hasPeer(peerId)) {
                    callErrorCallback(errorback, new Error(`Peer ${peerId} is not in Room ${roomId}.`));
                    return false;
                }
                return true;
            };
            const exitRoom = (roomId, peerId) => {
                if (rooms.has(roomId)) {
                    const room = rooms.get(roomId);
                    if (room.hasPeer(peerId)) {
                        room.exit(peerId);
                        if (room.empty()) {
                            _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Room ${roomId} became empty then closing it.`);
                            room.close();
                            rooms.delete(roomId);
                        }
                        for (const remotePeerId of room.peerIds) {
                            _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to notify exited Peer to Peer ${remotePeerId}.`);
                            this.peerIdToSocket.get(remotePeerId).emit('exitedPeer', { id: peerId });
                        }
                    }
                    else {
                        // Should not happen
                        _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.error(new Error(`Peer ${peerId} doesn't exist in Room ${roomId}.`));
                        return;
                    }
                }
                else {
                    // Should not happen
                    _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.error(new Error(`Room ${roomId} doesn't exist`));
                    return;
                }
                if (this.socketInfos.has(socket)) {
                    this.socketInfos.delete(socket);
                    this.peerIdToSocket.delete(peerId);
                }
                else {
                    // Should not happen
                    _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.error(new Error(`SocketInfo is not found ${socket.id}.`));
                    return;
                }
            };
            // Event handlers
            socket.on('disconnect', () => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket disconnect event: ${socket.id}`);
                // TODO: Check whether it is guaranteed that disconnect event
                //       is fired when disconnected.
                // TODO: Proper handling
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket ${socket.id} is dicsonnected.`);
                if (!this.socketInfos.has(socket)) {
                    return;
                }
                const { peerId, roomId } = this.socketInfos.get(socket);
                exitRoom(roomId, peerId);
            }));
            socket.on('enter', (data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket enter event: ${socket.id}`);
                if (!socketMustNotHaveEntered(callback)) {
                    return;
                }
                const { peerId, roomId } = data;
                // TODO: Validate input data
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to enter Room ${roomId}.`);
                // TODO: Consider to save peerId and roomId to socket.
                //       Clients no longer need to send peerId and roomId
                //       in the following requests.
                if (!rooms.has(roomId)) {
                    _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Room ${roomId} is not found then creating it.`);
                    rooms.set(roomId, yield _room__WEBPACK_IMPORTED_MODULE_6__.Room.create(roomId, worker));
                }
                if (!peerMustNotBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                const room = rooms.get(roomId);
                room.enter(peerId);
                this.socketInfos.set(socket, { peerId, roomId });
                this.peerIdToSocket.set(peerId, socket);
                const remotePeerIds = [];
                for (const remotePeerId of room.peerIds) {
                    if (peerId === remotePeerId) {
                        continue;
                    }
                    remotePeerIds.push({
                        id: remotePeerId,
                        joined: room.getPeer(remotePeerId).joined
                    });
                    _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to notify new Peer entrance to Peer ${remotePeerId}.`);
                    this.peerIdToSocket.get(remotePeerId).emit('newPeer', { id: peerId });
                }
                callback(remotePeerIds);
            }));
            socket.on('exit', (_data, callback) => {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket exit event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to exit Room ${roomId}.`);
                if (!roomMustExist(roomId, callback) || !peerMustBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                exitRoom(roomId, peerId);
                callback(true);
            });
            socket.on('getRouterRtpCapabilities', (_data, callback) => {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket getRouterRtpCapabilities event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to get routerRtpCapabilities of Room ${roomId}.`);
                if (!roomMustExist(roomId, callback)) {
                    return;
                }
                callback(rooms.get(roomId).rtpCapabilities);
            });
            socket.on('join', (data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket join event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { rtpCapabilities } = data;
                // TODO: Validate input data
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to join Room ${roomId}.`);
                if (!roomMustExist(roomId, callback) || !peerMustBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                const room = rooms.get(roomId);
                try {
                    room.join(peerId, rtpCapabilities);
                }
                catch (error) {
                    callErrorCallback(callback, error);
                    return;
                }
                for (const remotePeerId of room.peerIds) {
                    if (peerId === remotePeerId) {
                        continue;
                    }
                    _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to notify joined Peer to Peer ${remotePeerId}.`);
                    this.peerIdToSocket.get(remotePeerId).emit('joinedPeer', { id: peerId });
                }
                // TODO: Return with authorized token?
                callback(true);
            }));
            socket.on('leave', (_data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket leave event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to leave Room ${roomId}.`);
                if (!roomMustExist(roomId, callback) || !peerMustBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                const room = rooms.get(roomId);
                try {
                    room.leave(peerId);
                }
                catch (error) {
                    callErrorCallback(callback, error);
                    return;
                }
                for (const remotePeerId of room.peerIds) {
                    if (peerId === remotePeerId) {
                        continue;
                    }
                    _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to notify left Peer to Peer ${remotePeerId}.`);
                    this.peerIdToSocket.get(remotePeerId).emit('leftPeer', { id: peerId });
                }
                callback(true);
            }));
            socket.on('createProducerTransport', (_data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket createProduceTransport event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to create transport for producer in Room ${roomId}.`);
                if (!roomMustExist(roomId, callback) || !peerMustBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                try {
                    callback(yield rooms.get(roomId).createProducerTransport(peerId));
                }
                catch (error) {
                    callErrorCallback(callback, error);
                    return;
                }
            }));
            socket.on('createConsumerTransport', (_data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket createConsumerTransport event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to create transport for consumer in Room ${roomId}.`);
                if (!roomMustExist(roomId, callback) || !peerMustBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                const room = rooms.get(roomId);
                try {
                    callback(yield room.createConsumerTransport(peerId));
                }
                catch (error) {
                    callErrorCallback(callback, error);
                    return;
                }
                // Consume every producers in a room except for mine
                for (const producerPeerId of room.joinnedPeerIds) {
                    if (producerPeerId === peerId) {
                        continue;
                    }
                    for (const producerId of room.getPeer(producerPeerId).producerIds) {
                        _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to consume Producer ${producerId} of Peer ${producerPeerId}.`);
                        room.consume(peerId, producerPeerId, producerId).then((params) => {
                            if (room.hasPeer(peerId) && room.getPeer(peerId).joined &&
                                room.hasPeer(producerPeerId) && room.getPeer(producerPeerId).joined) {
                                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to emit newConsumer to client for Producer ${producerId}.`);
                                socket.emit('newConsumer', params);
                            }
                            else {
                                // TODO: Close the consumer?
                            }
                        }).catch(_logger__WEBPACK_IMPORTED_MODULE_5__.Logger.error);
                    }
                }
            }));
            socket.on('connectProducerTransport', (data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket connectProducerTransport event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { dtlsParameters } = data;
                // TODO: Validate input data
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to connect Producer transport in Room ${roomId}.`);
                if (!roomMustExist(roomId, callback) || !peerMustBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                try {
                    yield rooms.get(roomId).connectProducerTransport(peerId, dtlsParameters);
                    callback(true);
                }
                catch (error) {
                    callErrorCallback(callback, error);
                }
            }));
            socket.on('connectConsumerTransport', (data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket connectConsumerTransport event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { dtlsParameters } = data;
                // TODO: Validate input data
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to connect Consumer transport in Room ${roomId}.`);
                if (!roomMustExist(roomId, callback) || !peerMustBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                try {
                    yield rooms.get(roomId).connectConsumerTransport(peerId, dtlsParameters);
                    callback(true);
                }
                catch (error) {
                    callErrorCallback(callback, error);
                }
            }));
            socket.on('produce', (data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket produce event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { kind, rtpParameters } = data;
                // TODO: Validate input data
                const { peerId, roomId } = this.socketInfos.get(socket);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to produce in Room ${roomId}.`);
                if (!roomMustExist(roomId, callback) && !peerMustBeInRoom(roomId, peerId, callback)) {
                    return;
                }
                const room = rooms.get(roomId);
                let producerId;
                try {
                    producerId = yield room.produce(peerId, kind, rtpParameters);
                    callback({ id: producerId });
                }
                catch (error) {
                    callErrorCallback(callback, error);
                    return;
                }
                // Let remote peers consume this producer
                for (const remotePeerId of room.joinnedPeerIds) {
                    if (remotePeerId === peerId) {
                        continue;
                    }
                    if (room.getPeer(remotePeerId).consumerTransportId === null) {
                        continue;
                    }
                    _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${remotePeerId} attempts to consume Producer ${producerId} of Peer ${peerId}.`);
                    room.consume(remotePeerId, peerId, producerId).then((params) => {
                        if (room.hasPeer(remotePeerId) && room.getPeer(remotePeerId).joined &&
                            room.hasPeer(peerId) && room.getPeer(peerId).joined) {
                            _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${remotePeerId} attempts to emit newConsumer to client.`);
                            this.peerIdToSocket.get(remotePeerId).emit('newConsumer', params);
                        }
                        else {
                            // TODO: Close the consumer?
                        }
                    }).catch(_logger__WEBPACK_IMPORTED_MODULE_5__.Logger.error);
                }
            }));
            socket.on('resumeConsumer', (data, callback) => __awaiter(this, void 0, void 0, function* () {
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Socket resumeConsumer event: ${socket.id}`);
                if (!socketMustHaveEntered(callback)) {
                    return;
                }
                const { consumerId } = data;
                // TODO: Validate input data
                const { peerId, roomId } = this.socketInfos.get(socket);
                if (!roomMustExist(roomId, callback)) {
                    return;
                }
                const room = rooms.get(roomId);
                _logger__WEBPACK_IMPORTED_MODULE_5__.Logger.debug(`Peer ${peerId} attempts to resume consumer ${consumerId}.`);
                try {
                    yield room.resumeConsumer(consumerId);
                    callback();
                }
                catch (error) {
                    callErrorCallback(callback, error);
                    return;
                }
            }));
        });
    }
}


/***/ }),

/***/ "../../node_modules/vary/index.js":
/*!****************************************!*\
  !*** ../../node_modules/vary/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = vary
module.exports.append = append

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse(String(field))
    : field

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header
  var vals = parse(header.toLowerCase())

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase()

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld)
      val = val
        ? val + ', ' + fields[i]
        : fields[i]
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse (header) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(header.substring(start, end))

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || ''
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val)

  // set new header
  if ((val = append(header, field))) {
    res.setHeader('Vary', val)
  }
}


/***/ }),

/***/ "../../node_modules/ws/index.js":
/*!**************************************!*\
  !*** ../../node_modules/ws/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WebSocket = __webpack_require__(/*! ./lib/websocket */ "../../node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "../../node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "../../node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "../../node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "../../node_modules/ws/lib/sender.js");

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ "../../node_modules/ws/lib/buffer-util.js":
/*!************************************************!*\
  !*** ../../node_modules/ws/lib/buffer-util.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "../../node_modules/ws/lib/constants.js");

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __webpack_require__(/*! bufferutil */ "bufferutil");

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "../../node_modules/ws/lib/constants.js":
/*!**********************************************!*\
  !*** ../../node_modules/ws/lib/constants.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ "../../node_modules/ws/lib/event-target.js":
/*!*************************************************!*\
  !*** ../../node_modules/ws/lib/event-target.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ "../../node_modules/ws/lib/constants.js");

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ "../../node_modules/ws/lib/extension.js":
/*!**********************************************!*\
  !*** ../../node_modules/ws/lib/extension.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "../../node_modules/ws/lib/validation.js");

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "../../node_modules/ws/lib/limiter.js":
/*!********************************************!*\
  !*** ../../node_modules/ws/lib/limiter.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "../../node_modules/ws/lib/permessage-deflate.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ws/lib/permessage-deflate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "../../node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "../../node_modules/ws/lib/limiter.js");
const { kStatusCode } = __webpack_require__(/*! ./constants */ "../../node_modules/ws/lib/constants.js");

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "../../node_modules/ws/lib/receiver.js":
/*!*********************************************!*\
  !*** ../../node_modules/ws/lib/receiver.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "../../node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "../../node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "../../node_modules/ws/lib/validation.js");

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );
      }

      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );
      }
    } else {
      this._loop = false;
      return error(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );
      }
    } else if (this._masked) {
      this._loop = false;
      return error(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(
              RangeError,
              'Max payload size exceeded',
              false,
              1009,
              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
            )
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data, true);
      } else {
        const buf = concat(fragments, messageLength);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          this._loop = false;
          return error(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );
        }

        this.emit('message', buf, false);
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else if (data.length === 1) {
        return error(
          RangeError,
          'invalid payload length 1',
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );
        }

        const buf = data.slice(2);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          return error(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );
        }

        this.emit('conclude', code, buf);
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @param {String} errorCode The exposed error code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode, errorCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err.code = errorCode;
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ "../../node_modules/ws/lib/sender.js":
/*!*******************************************!*\
  !*** ../../node_modules/ws/lib/sender.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */



const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "../../node_modules/ws/lib/constants.js");
const { isValidStatusCode } = __webpack_require__(/*! ./validation */ "../../node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "../../node_modules/ws/lib/buffer-util.js");

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        randomFillSync(mask, 0, 4);
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const params = this._queue[i];
          const callback = params[params.length - 1];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ "../../node_modules/ws/lib/stream.js":
/*!*******************************************!*\
  !*** ../../node_modules/ws/lib/stream.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "../../node_modules/ws/lib/subprotocol.js":
/*!************************************************!*\
  !*** ../../node_modules/ws/lib/subprotocol.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "../../node_modules/ws/lib/validation.js");

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ "../../node_modules/ws/lib/validation.js":
/*!***********************************************!*\
  !*** ../../node_modules/ws/lib/validation.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = {
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

/* istanbul ignore else  */
if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ "utf-8-validate");

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "../../node_modules/ws/lib/websocket-server.js":
/*!*****************************************************!*\
  !*** ../../node_modules/ws/lib/websocket-server.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls|https$" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const http = __webpack_require__(/*! http */ "http");
const https = __webpack_require__(/*! https */ "https");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");

const extension = __webpack_require__(/*! ./extension */ "../../node_modules/ws/lib/extension.js");
const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../node_modules/ws/lib/permessage-deflate.js");
const subprotocol = __webpack_require__(/*! ./subprotocol */ "../../node_modules/ws/lib/subprotocol.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "../../node_modules/ws/lib/websocket.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "../../node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (req.headers.upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!key || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ "../../node_modules/ws/lib/websocket.js":
/*!**********************************************!*\
  !*** ../../node_modules/ws/lib/websocket.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Readable$" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { Readable } = __webpack_require__(/*! stream */ "stream");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "../../node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "../../node_modules/ws/lib/sender.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "../../node_modules/ws/lib/constants.js");
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(/*! ./event-target */ "../../node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "../../node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "../../node_modules/ws/lib/buffer-util.js");

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    this._sender = new Sender(socket, this._extensions, options.generateMask);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }

    websocket._url = address;
  }

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
        ? false
        : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    if (res.headers.upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  req.end();
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  websocket.emit('error', err);
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("express");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:child_process":
/*!*************************************!*\
  !*** external "node:child_process" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:child_process");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "node:events":
/*!******************************!*\
  !*** external "node:events" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:events");

/***/ }),

/***/ "node:os":
/*!**************************!*\
  !*** external "node:os" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:os");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ "node:tty":
/*!***************************!*\
  !*** external "node:tty" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:tty");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "bufferutil":
/*!*****************************!*\
  !*** external "bufferutil" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
if(typeof bufferutil === 'undefined') { var e = new Error("Cannot find module 'bufferutil'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = bufferutil;

/***/ }),

/***/ "utf-8-validate":
/*!*********************************!*\
  !*** external "utf-8-validate" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
if(typeof utf-8-validate === 'undefined') { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = utf-8-validate;

/***/ }),

/***/ "../../node_modules/engine.io-parser/build/cjs/commons.js":
/*!****************************************************************!*\
  !*** ../../node_modules/engine.io-parser/build/cjs/commons.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
exports.ERROR_PACKET = ERROR_PACKET;


/***/ }),

/***/ "../../node_modules/engine.io-parser/build/cjs/decodePacket.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/engine.io-parser/build/cjs/decodePacket.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodePacket = void 0;
const commons_js_1 = __webpack_require__(/*! ./commons.js */ "../../node_modules/engine.io-parser/build/cjs/commons.js");
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType),
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        const buffer = Buffer.from(encodedPacket.substring(1), "base64");
        return {
            type: "message",
            data: mapBinary(buffer, binaryType),
        };
    }
    if (!commons_js_1.PACKET_TYPES_REVERSE[type]) {
        return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
        }
        : {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
        };
};
exports.decodePacket = decodePacket;
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "arraybuffer":
            if (data instanceof ArrayBuffer) {
                // from WebSocket & binaryType "arraybuffer"
                return data;
            }
            else if (Buffer.isBuffer(data)) {
                // from HTTP long-polling
                return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
            }
            else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
        case "nodebuffer":
        default:
            if (Buffer.isBuffer(data)) {
                // from HTTP long-polling or WebSocket & binaryType "nodebuffer" (default)
                return data;
            }
            else {
                // from WebTransport (Uint8Array)
                return Buffer.from(data);
            }
    }
};


/***/ }),

/***/ "../../node_modules/engine.io-parser/build/cjs/encodePacket.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/engine.io-parser/build/cjs/encodePacket.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodePacketToBinary = exports.encodePacket = void 0;
const commons_js_1 = __webpack_require__(/*! ./commons.js */ "../../node_modules/engine.io-parser/build/cjs/commons.js");
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
        return callback(supportsBinary ? data : "b" + toBuffer(data, true).toString("base64"));
    }
    // plain string
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};
exports.encodePacket = encodePacket;
const toBuffer = (data, forceBufferConversion) => {
    if (Buffer.isBuffer(data) ||
        (data instanceof Uint8Array && !forceBufferConversion)) {
        return data;
    }
    else if (data instanceof ArrayBuffer) {
        return Buffer.from(data);
    }
    else {
        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    }
};
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return callback(toBuffer(packet.data, false));
    }
    (0, exports.encodePacket)(packet, true, (encoded) => {
        if (!TEXT_ENCODER) {
            // lazily created for compatibility with Node.js 10
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}
exports.encodePacketToBinary = encodePacketToBinary;


/***/ }),

/***/ "../../node_modules/engine.io-parser/build/cjs/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/engine.io-parser/build/cjs/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = exports.createPacketDecoderStream = exports.createPacketEncoderStream = void 0;
const encodePacket_js_1 = __webpack_require__(/*! ./encodePacket.js */ "../../node_modules/engine.io-parser/build/cjs/encodePacket.js");
Object.defineProperty(exports, "encodePacket", ({ enumerable: true, get: function () { return encodePacket_js_1.encodePacket; } }));
const decodePacket_js_1 = __webpack_require__(/*! ./decodePacket.js */ "../../node_modules/engine.io-parser/build/cjs/decodePacket.js");
Object.defineProperty(exports, "decodePacket", ({ enumerable: true, get: function () { return decodePacket_js_1.decodePacket; } }));
const commons_js_1 = __webpack_require__(/*! ./commons.js */ "../../node_modules/engine.io-parser/build/cjs/commons.js");
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
exports.encodePayload = encodePayload;
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
exports.decodePayload = decodePayload;
function createPacketEncoderStream() {
    // @ts-expect-error
    return new TransformStream({
        transform(packet, controller) {
            (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                }
                else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                }
                else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        },
    });
}
exports.createPacketEncoderStream = createPacketEncoderStream;
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* READ_HEADER */;
    let expectedLength = -1;
    let isBinary = false;
    // @ts-expect-error
    return new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            while (true) {
                if (state === 0 /* READ_HEADER */) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* READ_PAYLOAD */;
                    }
                    else if (expectedLength === 126) {
                        state = 1 /* READ_EXTENDED_LENGTH_16 */;
                    }
                    else {
                        state = 2 /* READ_EXTENDED_LENGTH_64 */;
                    }
                }
                else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* READ_PAYLOAD */;
                }
                else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(commons_js_1.ERROR_PACKET);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* READ_PAYLOAD */;
                }
                else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* READ_HEADER */;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(commons_js_1.ERROR_PACKET);
                    break;
                }
            }
        },
    });
}
exports.createPacketDecoderStream = createPacketDecoderStream;
exports.protocol = 4;


/***/ }),

/***/ "../../node_modules/engine.io/build/engine.io.js":
/*!*******************************************************!*\
  !*** ../../node_modules/engine.io/build/engine.io.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.attach = exports.listen = exports.transports = exports.Server = void 0;
const http_1 = __webpack_require__(/*! http */ "http");
const server_1 = __webpack_require__(/*! ./server */ "../../node_modules/engine.io/build/server.js");
Object.defineProperty(exports, "Server", ({ enumerable: true, get: function () { return server_1.Server; } }));
const index_1 = __webpack_require__(/*! ./transports/index */ "../../node_modules/engine.io/build/transports/index.js");
exports.transports = index_1.default;
const parser = __webpack_require__(/*! engine.io-parser */ "../../node_modules/engine.io-parser/build/cjs/index.js");
exports.parser = parser;
var userver_1 = __webpack_require__(/*! ./userver */ "../../node_modules/engine.io/build/userver.js");
Object.defineProperty(exports, "uServer", ({ enumerable: true, get: function () { return userver_1.uServer; } }));
var socket_1 = __webpack_require__(/*! ./socket */ "../../node_modules/engine.io/build/socket.js");
Object.defineProperty(exports, "Socket", ({ enumerable: true, get: function () { return socket_1.Socket; } }));
var transport_1 = __webpack_require__(/*! ./transport */ "../../node_modules/engine.io/build/transport.js");
Object.defineProperty(exports, "Transport", ({ enumerable: true, get: function () { return transport_1.Transport; } }));
exports.protocol = parser.protocol;
/**
 * Creates an http.Server exclusively used for WS upgrades.
 *
 * @param {Number} port
 * @param {Function} callback
 * @param {Object} options
 * @return {Server} websocket.io server
 * @api public
 */
function listen(port, options, fn) {
    if ("function" === typeof options) {
        fn = options;
        options = {};
    }
    const server = (0, http_1.createServer)(function (req, res) {
        res.writeHead(501);
        res.end("Not Implemented");
    });
    // create engine server
    const engine = attach(server, options);
    engine.httpServer = server;
    server.listen(port, fn);
    return engine;
}
exports.listen = listen;
/**
 * Captures upgrade requests for a http.Server.
 *
 * @param {http.Server} server
 * @param {Object} options
 * @return {Server} engine server
 * @api public
 */
function attach(server, options) {
    const engine = new server_1.Server(options);
    engine.attach(server, options);
    return engine;
}
exports.attach = attach;


/***/ }),

/***/ "../../node_modules/engine.io/build/parser-v3/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/engine.io/build/parser-v3/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;
/**
 * Module dependencies.
 */
var utf8 = __webpack_require__(/*! ./utf8 */ "../../node_modules/engine.io/build/parser-v3/utf8.js");
/**
 * Current protocol version.
 */
exports.protocol = 3;
const hasBinary = (packets) => {
    for (const packet of packets) {
        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
            return true;
        }
    }
    return false;
};
/**
 * Packet types.
 */
exports.packets = {
    open: 0 // non-ws
    ,
    close: 1 // non-ws
    ,
    ping: 2,
    pong: 3,
    message: 4,
    upgrade: 5,
    noop: 6
};
var packetslist = Object.keys(exports.packets);
/**
 * Premade error packet.
 */
var err = { type: 'error', data: 'parser error' };
const EMPTY_BUFFER = Buffer.concat([]);
/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */
function encodePacket(packet, supportsBinary, utf8encode, callback) {
    if (typeof supportsBinary === 'function') {
        callback = supportsBinary;
        supportsBinary = null;
    }
    if (typeof utf8encode === 'function') {
        callback = utf8encode;
        utf8encode = null;
    }
    if (Buffer.isBuffer(packet.data)) {
        return encodeBuffer(packet, supportsBinary, callback);
    }
    else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
        return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
    }
    // Sending data as a utf-8 string
    var encoded = exports.packets[packet.type];
    // data fragment is optional
    if (undefined !== packet.data) {
        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
    }
    return callback('' + encoded);
}
exports.encodePacket = encodePacket;
;
/**
 * Encode Buffer data
 */
function encodeBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
        return encodeBase64Packet(packet, callback);
    }
    var data = packet.data;
    var typeBuffer = Buffer.allocUnsafe(1);
    typeBuffer[0] = exports.packets[packet.type];
    return callback(Buffer.concat([typeBuffer, data]));
}
/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */
function encodeBase64Packet(packet, callback) {
    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
    var message = 'b' + exports.packets[packet.type];
    message += data.toString('base64');
    return callback(message);
}
exports.encodeBase64Packet = encodeBase64Packet;
;
/**
 * Decodes a packet. Data also available as an ArrayBuffer if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */
function decodePacket(data, binaryType, utf8decode) {
    if (data === undefined) {
        return err;
    }
    var type;
    // String data
    if (typeof data === 'string') {
        type = data.charAt(0);
        if (type === 'b') {
            return decodeBase64Packet(data.slice(1), binaryType);
        }
        if (utf8decode) {
            data = tryDecode(data);
            if (data === false) {
                return err;
            }
        }
        if (Number(type) != type || !packetslist[type]) {
            return err;
        }
        if (data.length > 1) {
            return { type: packetslist[type], data: data.slice(1) };
        }
        else {
            return { type: packetslist[type] };
        }
    }
    // Binary data
    if (binaryType === 'arraybuffer') {
        // wrap Buffer/ArrayBuffer data into an Uint8Array
        var intArray = new Uint8Array(data);
        type = intArray[0];
        return { type: packetslist[type], data: intArray.buffer.slice(1) };
    }
    if (data instanceof ArrayBuffer) {
        data = arrayBufferToBuffer(data);
    }
    type = data[0];
    return { type: packetslist[type], data: data.slice(1) };
}
exports.decodePacket = decodePacket;
;
function tryDecode(data) {
    try {
        data = utf8.decode(data, { strict: false });
    }
    catch (e) {
        return false;
    }
    return data;
}
/**
 * Decodes a packet encoded in a base64 string.
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */
function decodeBase64Packet(msg, binaryType) {
    var type = packetslist[msg.charAt(0)];
    var data = Buffer.from(msg.slice(1), 'base64');
    if (binaryType === 'arraybuffer') {
        var abv = new Uint8Array(data.length);
        for (var i = 0; i < abv.length; i++) {
            abv[i] = data[i];
        }
        // @ts-ignore
        data = abv.buffer;
    }
    return { type: type, data: data };
}
exports.decodeBase64Packet = decodeBase64Packet;
;
/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */
function encodePayload(packets, supportsBinary, callback) {
    if (typeof supportsBinary === 'function') {
        callback = supportsBinary;
        supportsBinary = null;
    }
    if (supportsBinary && hasBinary(packets)) {
        return encodePayloadAsBinary(packets, callback);
    }
    if (!packets.length) {
        return callback('0:');
    }
    function encodeOne(packet, doneCallback) {
        encodePacket(packet, supportsBinary, false, function (message) {
            doneCallback(null, setLengthHeader(message));
        });
    }
    map(packets, encodeOne, function (err, results) {
        return callback(results.join(''));
    });
}
exports.encodePayload = encodePayload;
;
function setLengthHeader(message) {
    return message.length + ':' + message;
}
/**
 * Async array map using after
 */
function map(ary, each, done) {
    const results = new Array(ary.length);
    let count = 0;
    for (let i = 0; i < ary.length; i++) {
        each(ary[i], (error, msg) => {
            results[i] = msg;
            if (++count === ary.length) {
                done(null, results);
            }
        });
    }
}
/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */
function decodePayload(data, binaryType, callback) {
    if (typeof data !== 'string') {
        return decodePayloadAsBinary(data, binaryType, callback);
    }
    if (typeof binaryType === 'function') {
        callback = binaryType;
        binaryType = null;
    }
    if (data === '') {
        // parser error - ignoring payload
        return callback(err, 0, 1);
    }
    var length = '', n, msg, packet;
    for (var i = 0, l = data.length; i < l; i++) {
        var chr = data.charAt(i);
        if (chr !== ':') {
            length += chr;
            continue;
        }
        // @ts-ignore
        if (length === '' || (length != (n = Number(length)))) {
            // parser error - ignoring payload
            return callback(err, 0, 1);
        }
        msg = data.slice(i + 1, i + 1 + n);
        if (length != msg.length) {
            // parser error - ignoring payload
            return callback(err, 0, 1);
        }
        if (msg.length) {
            packet = decodePacket(msg, binaryType, false);
            if (err.type === packet.type && err.data === packet.data) {
                // parser error in individual packet - ignoring payload
                return callback(err, 0, 1);
            }
            var more = callback(packet, i + n, l);
            if (false === more)
                return;
        }
        // advance cursor
        i += n;
        length = '';
    }
    if (length !== '') {
        // parser error - ignoring payload
        return callback(err, 0, 1);
    }
}
exports.decodePayload = decodePayload;
;
/**
 *
 * Converts a buffer to a utf8.js encoded string
 *
 * @api private
 */
function bufferToString(buffer) {
    var str = '';
    for (var i = 0, l = buffer.length; i < l; i++) {
        str += String.fromCharCode(buffer[i]);
    }
    return str;
}
/**
 *
 * Converts a utf8.js encoded string to a buffer
 *
 * @api private
 */
function stringToBuffer(string) {
    var buf = Buffer.allocUnsafe(string.length);
    for (var i = 0, l = string.length; i < l; i++) {
        buf.writeUInt8(string.charCodeAt(i), i);
    }
    return buf;
}
/**
 *
 * Converts an ArrayBuffer to a Buffer
 *
 * @api private
 */
function arrayBufferToBuffer(data) {
    // data is either an ArrayBuffer or ArrayBufferView.
    var length = data.byteLength || data.length;
    var offset = data.byteOffset || 0;
    return Buffer.from(data.buffer || data, offset, length);
}
/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {Buffer} encoded payload
 * @api private
 */
function encodePayloadAsBinary(packets, callback) {
    if (!packets.length) {
        return callback(EMPTY_BUFFER);
    }
    map(packets, encodeOneBinaryPacket, function (err, results) {
        return callback(Buffer.concat(results));
    });
}
exports.encodePayloadAsBinary = encodePayloadAsBinary;
;
function encodeOneBinaryPacket(p, doneCallback) {
    function onBinaryPacketEncode(packet) {
        var encodingLength = '' + packet.length;
        var sizeBuffer;
        if (typeof packet === 'string') {
            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
            sizeBuffer[0] = 0; // is a string (not true binary = 0)
            for (var i = 0; i < encodingLength.length; i++) {
                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
            }
            sizeBuffer[sizeBuffer.length - 1] = 255;
            return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
        }
        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
        sizeBuffer[0] = 1; // is binary (true binary = 1)
        for (var i = 0; i < encodingLength.length; i++) {
            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
        }
        sizeBuffer[sizeBuffer.length - 1] = 255;
        doneCallback(null, Buffer.concat([sizeBuffer, packet]));
    }
    encodePacket(p, true, true, onBinaryPacketEncode);
}
/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary

 * @param {Buffer} data, callback method
 * @api public
 */
function decodePayloadAsBinary(data, binaryType, callback) {
    if (typeof binaryType === 'function') {
        callback = binaryType;
        binaryType = null;
    }
    var bufferTail = data;
    var buffers = [];
    var i;
    while (bufferTail.length > 0) {
        var strLen = '';
        var isString = bufferTail[0] === 0;
        for (i = 1;; i++) {
            if (bufferTail[i] === 255)
                break;
            // 310 = char length of Number.MAX_VALUE
            if (strLen.length > 310) {
                return callback(err, 0, 1);
            }
            strLen += '' + bufferTail[i];
        }
        bufferTail = bufferTail.slice(strLen.length + 1);
        var msgLength = parseInt(strLen, 10);
        var msg = bufferTail.slice(1, msgLength + 1);
        if (isString)
            msg = bufferToString(msg);
        buffers.push(msg);
        bufferTail = bufferTail.slice(msgLength + 1);
    }
    var total = buffers.length;
    for (i = 0; i < total; i++) {
        var buffer = buffers[i];
        callback(decodePacket(buffer, binaryType, true), i, total);
    }
}
exports.decodePayloadAsBinary = decodePayloadAsBinary;
;


/***/ }),

/***/ "../../node_modules/engine.io/build/parser-v3/utf8.js":
/*!************************************************************!*\
  !*** ../../node_modules/engine.io/build/parser-v3/utf8.js ***!
  \************************************************************/
/***/ ((module) => {

/*! https://mths.be/utf8js v2.1.2 by @mathias */
var stringFromCharCode = String.fromCharCode;
// Taken from https://mths.be/punycode
function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    var value;
    var extra;
    while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            // high surrogate, and there is a next character
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            }
            else {
                // unmatched surrogate; only append this code unit, in case the next
                // code unit is the high surrogate of a surrogate pair
                output.push(value);
                counter--;
            }
        }
        else {
            output.push(value);
        }
    }
    return output;
}
// Taken from https://mths.be/punycode
function ucs2encode(array) {
    var length = array.length;
    var index = -1;
    var value;
    var output = '';
    while (++index < length) {
        value = array[index];
        if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
        }
        output += stringFromCharCode(value);
    }
    return output;
}
function checkScalarValue(codePoint, strict) {
    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
        if (strict) {
            throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
                ' is not a scalar value');
        }
        return false;
    }
    return true;
}
/*--------------------------------------------------------------------------*/
function createByte(codePoint, shift) {
    return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}
function encodeCodePoint(codePoint, strict) {
    if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
        return stringFromCharCode(codePoint);
    }
    var symbol = '';
    if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
        symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
    }
    else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
        if (!checkScalarValue(codePoint, strict)) {
            codePoint = 0xFFFD;
        }
        symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
        symbol += createByte(codePoint, 6);
    }
    else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
        symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
        symbol += createByte(codePoint, 12);
        symbol += createByte(codePoint, 6);
    }
    symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
    return symbol;
}
function utf8encode(string, opts) {
    opts = opts || {};
    var strict = false !== opts.strict;
    var codePoints = ucs2decode(string);
    var length = codePoints.length;
    var index = -1;
    var codePoint;
    var byteString = '';
    while (++index < length) {
        codePoint = codePoints[index];
        byteString += encodeCodePoint(codePoint, strict);
    }
    return byteString;
}
/*--------------------------------------------------------------------------*/
function readContinuationByte() {
    if (byteIndex >= byteCount) {
        throw Error('Invalid byte index');
    }
    var continuationByte = byteArray[byteIndex] & 0xFF;
    byteIndex++;
    if ((continuationByte & 0xC0) == 0x80) {
        return continuationByte & 0x3F;
    }
    // If we end up here, its not a continuation byte
    throw Error('Invalid continuation byte');
}
function decodeSymbol(strict) {
    var byte1;
    var byte2;
    var byte3;
    var byte4;
    var codePoint;
    if (byteIndex > byteCount) {
        throw Error('Invalid byte index');
    }
    if (byteIndex == byteCount) {
        return false;
    }
    // Read first byte
    byte1 = byteArray[byteIndex] & 0xFF;
    byteIndex++;
    // 1-byte sequence (no continuation bytes)
    if ((byte1 & 0x80) == 0) {
        return byte1;
    }
    // 2-byte sequence
    if ((byte1 & 0xE0) == 0xC0) {
        byte2 = readContinuationByte();
        codePoint = ((byte1 & 0x1F) << 6) | byte2;
        if (codePoint >= 0x80) {
            return codePoint;
        }
        else {
            throw Error('Invalid continuation byte');
        }
    }
    // 3-byte sequence (may include unpaired surrogates)
    if ((byte1 & 0xF0) == 0xE0) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
        if (codePoint >= 0x0800) {
            return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
        }
        else {
            throw Error('Invalid continuation byte');
        }
    }
    // 4-byte sequence
    if ((byte1 & 0xF8) == 0xF0) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        byte4 = readContinuationByte();
        codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
            (byte3 << 0x06) | byte4;
        if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
            return codePoint;
        }
    }
    throw Error('Invalid UTF-8 detected');
}
var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
    opts = opts || {};
    var strict = false !== opts.strict;
    byteArray = ucs2decode(byteString);
    byteCount = byteArray.length;
    byteIndex = 0;
    var codePoints = [];
    var tmp;
    while ((tmp = decodeSymbol(strict)) !== false) {
        codePoints.push(tmp);
    }
    return ucs2encode(codePoints);
}
module.exports = {
    version: '2.1.2',
    encode: utf8encode,
    decode: utf8decode
};


/***/ }),

/***/ "../../node_modules/engine.io/build/server.js":
/*!****************************************************!*\
  !*** ../../node_modules/engine.io/build/server.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Server = exports.BaseServer = void 0;
const qs = __webpack_require__(/*! querystring */ "querystring");
const url_1 = __webpack_require__(/*! url */ "url");
const base64id = __webpack_require__(/*! base64id */ "../../node_modules/base64id/lib/base64id.js");
const transports_1 = __webpack_require__(/*! ./transports */ "../../node_modules/engine.io/build/transports/index.js");
const events_1 = __webpack_require__(/*! events */ "events");
const socket_1 = __webpack_require__(/*! ./socket */ "../../node_modules/engine.io/build/socket.js");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const cookie_1 = __webpack_require__(/*! cookie */ "../../node_modules/engine.io/node_modules/cookie/index.js");
const ws_1 = __webpack_require__(/*! ws */ "../../node_modules/ws/index.js");
const webtransport_1 = __webpack_require__(/*! ./transports/webtransport */ "../../node_modules/engine.io/build/transports/webtransport.js");
const engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ "../../node_modules/engine.io-parser/build/cjs/index.js");
const debug = (0, debug_1.default)("engine");
const kResponseHeaders = Symbol("responseHeaders");
function parseSessionId(data) {
    try {
        const parsed = JSON.parse(data);
        if (typeof parsed.sid === "string") {
            return parsed.sid;
        }
    }
    catch (e) { }
}
class BaseServer extends events_1.EventEmitter {
    /**
     * Server constructor.
     *
     * @param {Object} opts - options
     * @api public
     */
    constructor(opts = {}) {
        super();
        this.middlewares = [];
        this.clients = {};
        this.clientsCount = 0;
        this.opts = Object.assign({
            wsEngine: ws_1.Server,
            pingTimeout: 20000,
            pingInterval: 25000,
            upgradeTimeout: 10000,
            maxHttpBufferSize: 1e6,
            transports: ["polling", "websocket"],
            allowUpgrades: true,
            httpCompression: {
                threshold: 1024,
            },
            cors: false,
            allowEIO3: false,
        }, opts);
        if (opts.cookie) {
            this.opts.cookie = Object.assign({
                name: "io",
                path: "/",
                // @ts-ignore
                httpOnly: opts.cookie.path !== false,
                sameSite: "lax",
            }, opts.cookie);
        }
        if (this.opts.cors) {
            this.use(__webpack_require__(/*! cors */ "../../node_modules/cors/lib/index.js")(this.opts.cors));
        }
        if (opts.perMessageDeflate) {
            this.opts.perMessageDeflate = Object.assign({
                threshold: 1024,
            }, opts.perMessageDeflate);
        }
        this.init();
    }
    /**
     * Compute the pathname of the requests that are handled by the server
     * @param options
     * @protected
     */
    _computePath(options) {
        let path = (options.path || "/engine.io").replace(/\/$/, "");
        if (options.addTrailingSlash !== false) {
            // normalize path
            path += "/";
        }
        return path;
    }
    /**
     * Returns a list of available transports for upgrade given a certain transport.
     *
     * @return {Array}
     * @api public
     */
    upgrades(transport) {
        if (!this.opts.allowUpgrades)
            return [];
        return transports_1.default[transport].upgradesTo || [];
    }
    /**
     * Verifies a request.
     *
     * @param {http.IncomingMessage}
     * @return {Boolean} whether the request is valid
     * @api private
     */
    verify(req, upgrade, fn) {
        // transport check
        const transport = req._query.transport;
        // WebTransport does not go through the verify() method, see the onWebTransportSession() method
        if (!~this.opts.transports.indexOf(transport) ||
            transport === "webtransport") {
            debug('unknown transport "%s"', transport);
            return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });
        }
        // 'Origin' header check
        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
        if (isOriginInvalid) {
            const origin = req.headers.origin;
            req.headers.origin = null;
            debug("origin header invalid");
            return fn(Server.errors.BAD_REQUEST, {
                name: "INVALID_ORIGIN",
                origin,
            });
        }
        // sid check
        const sid = req._query.sid;
        if (sid) {
            if (!this.clients.hasOwnProperty(sid)) {
                debug('unknown sid "%s"', sid);
                return fn(Server.errors.UNKNOWN_SID, {
                    sid,
                });
            }
            const previousTransport = this.clients[sid].transport.name;
            if (!upgrade && previousTransport !== transport) {
                debug("bad request: unexpected transport without upgrade");
                return fn(Server.errors.BAD_REQUEST, {
                    name: "TRANSPORT_MISMATCH",
                    transport,
                    previousTransport,
                });
            }
        }
        else {
            // handshake is GET only
            if ("GET" !== req.method) {
                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
                    method: req.method,
                });
            }
            if (transport === "websocket" && !upgrade) {
                debug("invalid transport upgrade");
                return fn(Server.errors.BAD_REQUEST, {
                    name: "TRANSPORT_HANDSHAKE_ERROR",
                });
            }
            if (!this.opts.allowRequest)
                return fn();
            return this.opts.allowRequest(req, (message, success) => {
                if (!success) {
                    return fn(Server.errors.FORBIDDEN, {
                        message,
                    });
                }
                fn();
            });
        }
        fn();
    }
    /**
     * Adds a new middleware.
     *
     * @example
     * import helmet from "helmet";
     *
     * engine.use(helmet());
     *
     * @param fn
     */
    use(fn) {
        this.middlewares.push(fn);
    }
    /**
     * Apply the middlewares to the request.
     *
     * @param req
     * @param res
     * @param callback
     * @protected
     */
    _applyMiddlewares(req, res, callback) {
        if (this.middlewares.length === 0) {
            debug("no middleware to apply, skipping");
            return callback();
        }
        const apply = (i) => {
            debug("applying middleware n%d", i + 1);
            this.middlewares[i](req, res, (err) => {
                if (err) {
                    return callback(err);
                }
                if (i + 1 < this.middlewares.length) {
                    apply(i + 1);
                }
                else {
                    callback();
                }
            });
        };
        apply(0);
    }
    /**
     * Closes all clients.
     *
     * @api public
     */
    close() {
        debug("closing all open clients");
        for (let i in this.clients) {
            if (this.clients.hasOwnProperty(i)) {
                this.clients[i].close(true);
            }
        }
        this.cleanup();
        return this;
    }
    /**
     * generate a socket id.
     * Overwrite this method to generate your custom socket id
     *
     * @param {Object} request object
     * @api public
     */
    generateId(req) {
        return base64id.generateId();
    }
    /**
     * Handshakes a new client.
     *
     * @param {String} transport name
     * @param {Object} request object
     * @param {Function} closeConnection
     *
     * @api protected
     */
    async handshake(transportName, req, closeConnection) {
        const protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default
        if (protocol === 3 && !this.opts.allowEIO3) {
            debug("unsupported protocol version");
            this.emit("connection_error", {
                req,
                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
                context: {
                    protocol,
                },
            });
            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
            return;
        }
        let id;
        try {
            id = await this.generateId(req);
        }
        catch (e) {
            debug("error while generating an id");
            this.emit("connection_error", {
                req,
                code: Server.errors.BAD_REQUEST,
                message: Server.errorMessages[Server.errors.BAD_REQUEST],
                context: {
                    name: "ID_GENERATION_ERROR",
                    error: e,
                },
            });
            closeConnection(Server.errors.BAD_REQUEST);
            return;
        }
        debug('handshaking client "%s"', id);
        try {
            var transport = this.createTransport(transportName, req);
            if ("polling" === transportName) {
                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
                transport.httpCompression = this.opts.httpCompression;
            }
            else if ("websocket" === transportName) {
                transport.perMessageDeflate = this.opts.perMessageDeflate;
            }
        }
        catch (e) {
            debug('error handshaking to transport "%s"', transportName);
            this.emit("connection_error", {
                req,
                code: Server.errors.BAD_REQUEST,
                message: Server.errorMessages[Server.errors.BAD_REQUEST],
                context: {
                    name: "TRANSPORT_HANDSHAKE_ERROR",
                    error: e,
                },
            });
            closeConnection(Server.errors.BAD_REQUEST);
            return;
        }
        const socket = new socket_1.Socket(id, this, transport, req, protocol);
        transport.on("headers", (headers, req) => {
            const isInitialRequest = !req._query.sid;
            if (isInitialRequest) {
                if (this.opts.cookie) {
                    headers["Set-Cookie"] = [
                        // @ts-ignore
                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie),
                    ];
                }
                this.emit("initial_headers", headers, req);
            }
            this.emit("headers", headers, req);
        });
        transport.onRequest(req);
        this.clients[id] = socket;
        this.clientsCount++;
        socket.once("close", () => {
            delete this.clients[id];
            this.clientsCount--;
        });
        this.emit("connection", socket);
        return transport;
    }
    async onWebTransportSession(session) {
        const timeout = setTimeout(() => {
            debug("the client failed to establish a bidirectional stream in the given period");
            session.close();
        }, this.opts.upgradeTimeout);
        const streamReader = session.incomingBidirectionalStreams.getReader();
        const result = await streamReader.read();
        if (result.done) {
            debug("session is closed");
            return;
        }
        const stream = result.value;
        const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, "nodebuffer");
        const reader = stream.readable.pipeThrough(transformStream).getReader();
        // reading the first packet of the stream
        const { value, done } = await reader.read();
        if (done) {
            debug("stream is closed");
            return;
        }
        clearTimeout(timeout);
        if (value.type !== "open") {
            debug("invalid WebTransport handshake");
            return session.close();
        }
        if (value.data === undefined) {
            const transport = new webtransport_1.WebTransport(session, stream, reader);
            // note: we cannot use "this.generateId()", because there is no "req" argument
            const id = base64id.generateId();
            debug('handshaking client "%s" (WebTransport)', id);
            const socket = new socket_1.Socket(id, this, transport, null, 4);
            this.clients[id] = socket;
            this.clientsCount++;
            socket.once("close", () => {
                delete this.clients[id];
                this.clientsCount--;
            });
            this.emit("connection", socket);
            return;
        }
        const sid = parseSessionId(value.data);
        if (!sid) {
            debug("invalid WebTransport handshake");
            return session.close();
        }
        const client = this.clients[sid];
        if (!client) {
            debug("upgrade attempt for closed client");
            session.close();
        }
        else if (client.upgrading) {
            debug("transport has already been trying to upgrade");
            session.close();
        }
        else if (client.upgraded) {
            debug("transport had already been upgraded");
            session.close();
        }
        else {
            debug("upgrading existing transport");
            const transport = new webtransport_1.WebTransport(session, stream, reader);
            client.maybeUpgrade(transport);
        }
    }
}
exports.BaseServer = BaseServer;
/**
 * Protocol errors mappings.
 */
BaseServer.errors = {
    UNKNOWN_TRANSPORT: 0,
    UNKNOWN_SID: 1,
    BAD_HANDSHAKE_METHOD: 2,
    BAD_REQUEST: 3,
    FORBIDDEN: 4,
    UNSUPPORTED_PROTOCOL_VERSION: 5,
};
BaseServer.errorMessages = {
    0: "Transport unknown",
    1: "Session ID unknown",
    2: "Bad handshake method",
    3: "Bad request",
    4: "Forbidden",
    5: "Unsupported protocol version",
};
/**
 * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade
 * request.
 *
 * @see https://nodejs.org/api/http.html#class-httpserverresponse
 */
class WebSocketResponse {
    constructor(req, socket) {
        this.req = req;
        this.socket = socket;
        // temporarily store the response headers on the req object (see the "headers" event)
        req[kResponseHeaders] = {};
    }
    setHeader(name, value) {
        this.req[kResponseHeaders][name] = value;
    }
    getHeader(name) {
        return this.req[kResponseHeaders][name];
    }
    removeHeader(name) {
        delete this.req[kResponseHeaders][name];
    }
    write() { }
    writeHead() { }
    end() {
        // we could return a proper error code, but the WebSocket client will emit an "error" event anyway.
        this.socket.destroy();
    }
}
class Server extends BaseServer {
    /**
     * Initialize websocket server
     *
     * @api protected
     */
    init() {
        if (!~this.opts.transports.indexOf("websocket"))
            return;
        if (this.ws)
            this.ws.close();
        this.ws = new this.opts.wsEngine({
            noServer: true,
            clientTracking: false,
            perMessageDeflate: this.opts.perMessageDeflate,
            maxPayload: this.opts.maxHttpBufferSize,
        });
        if (typeof this.ws.on === "function") {
            this.ws.on("headers", (headersArray, req) => {
                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)
                // we could also try to parse the array and then sync the values, but that will be error-prone
                const additionalHeaders = req[kResponseHeaders] || {};
                delete req[kResponseHeaders];
                const isInitialRequest = !req._query.sid;
                if (isInitialRequest) {
                    this.emit("initial_headers", additionalHeaders, req);
                }
                this.emit("headers", additionalHeaders, req);
                debug("writing headers: %j", additionalHeaders);
                Object.keys(additionalHeaders).forEach((key) => {
                    headersArray.push(`${key}: ${additionalHeaders[key]}`);
                });
            });
        }
    }
    cleanup() {
        if (this.ws) {
            debug("closing webSocketServer");
            this.ws.close();
            // don't delete this.ws because it can be used again if the http server starts listening again
        }
    }
    /**
     * Prepares a request by processing the query string.
     *
     * @api private
     */
    prepare(req) {
        // try to leverage pre-existing `req._query` (e.g: from connect)
        if (!req._query) {
            req._query = ~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {};
        }
    }
    createTransport(transportName, req) {
        return new transports_1.default[transportName](req);
    }
    /**
     * Handles an Engine.IO HTTP request.
     *
     * @param {IncomingMessage} req
     * @param {ServerResponse} res
     * @api public
     */
    handleRequest(req, res) {
        debug('handling "%s" http request "%s"', req.method, req.url);
        this.prepare(req);
        // @ts-ignore
        req.res = res;
        const callback = (errorCode, errorContext) => {
            if (errorCode !== undefined) {
                this.emit("connection_error", {
                    req,
                    code: errorCode,
                    message: Server.errorMessages[errorCode],
                    context: errorContext,
                });
                abortRequest(res, errorCode, errorContext);
                return;
            }
            // @ts-ignore
            if (req._query.sid) {
                debug("setting new request for existing client");
                // @ts-ignore
                this.clients[req._query.sid].transport.onRequest(req);
            }
            else {
                const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);
                // @ts-ignore
                this.handshake(req._query.transport, req, closeConnection);
            }
        };
        this._applyMiddlewares(req, res, (err) => {
            if (err) {
                callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
            }
            else {
                this.verify(req, false, callback);
            }
        });
    }
    /**
     * Handles an Engine.IO HTTP Upgrade.
     *
     * @api public
     */
    handleUpgrade(req, socket, upgradeHead) {
        this.prepare(req);
        const res = new WebSocketResponse(req, socket);
        const callback = (errorCode, errorContext) => {
            if (errorCode !== undefined) {
                this.emit("connection_error", {
                    req,
                    code: errorCode,
                    message: Server.errorMessages[errorCode],
                    context: errorContext,
                });
                abortUpgrade(socket, errorCode, errorContext);
                return;
            }
            const head = Buffer.from(upgradeHead);
            upgradeHead = null;
            // some middlewares (like express-session) wait for the writeHead() call to flush their headers
            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244
            res.writeHead();
            // delegate to ws
            this.ws.handleUpgrade(req, socket, head, (websocket) => {
                this.onWebSocket(req, socket, websocket);
            });
        };
        this._applyMiddlewares(req, res, (err) => {
            if (err) {
                callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
            }
            else {
                this.verify(req, true, callback);
            }
        });
    }
    /**
     * Called upon a ws.io connection.
     *
     * @param {ws.Socket} websocket
     * @api private
     */
    onWebSocket(req, socket, websocket) {
        websocket.on("error", onUpgradeError);
        if (transports_1.default[req._query.transport] !== undefined &&
            !transports_1.default[req._query.transport].prototype.handlesUpgrades) {
            debug("transport doesnt handle upgraded requests");
            websocket.close();
            return;
        }
        // get client id
        const id = req._query.sid;
        // keep a reference to the ws.Socket
        req.websocket = websocket;
        if (id) {
            const client = this.clients[id];
            if (!client) {
                debug("upgrade attempt for closed client");
                websocket.close();
            }
            else if (client.upgrading) {
                debug("transport has already been trying to upgrade");
                websocket.close();
            }
            else if (client.upgraded) {
                debug("transport had already been upgraded");
                websocket.close();
            }
            else {
                debug("upgrading existing transport");
                // transport error handling takes over
                websocket.removeListener("error", onUpgradeError);
                const transport = this.createTransport(req._query.transport, req);
                transport.perMessageDeflate = this.opts.perMessageDeflate;
                client.maybeUpgrade(transport);
            }
        }
        else {
            const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);
            this.handshake(req._query.transport, req, closeConnection);
        }
        function onUpgradeError() {
            debug("websocket error before upgrade");
            // websocket.close() not needed
        }
    }
    /**
     * Captures upgrade requests for a http.Server.
     *
     * @param {http.Server} server
     * @param {Object} options
     * @api public
     */
    attach(server, options = {}) {
        const path = this._computePath(options);
        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;
        function check(req) {
            // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)
            return path === req.url.slice(0, path.length);
        }
        // cache and clean up listeners
        const listeners = server.listeners("request").slice(0);
        server.removeAllListeners("request");
        server.on("close", this.close.bind(this));
        server.on("listening", this.init.bind(this));
        // add request handler
        server.on("request", (req, res) => {
            if (check(req)) {
                debug('intercepting request for path "%s"', path);
                this.handleRequest(req, res);
            }
            else {
                let i = 0;
                const l = listeners.length;
                for (; i < l; i++) {
                    listeners[i].call(server, req, res);
                }
            }
        });
        if (~this.opts.transports.indexOf("websocket")) {
            server.on("upgrade", (req, socket, head) => {
                if (check(req)) {
                    this.handleUpgrade(req, socket, head);
                }
                else if (false !== options.destroyUpgrade) {
                    // default node behavior is to disconnect when no handlers
                    // but by adding a handler, we prevent that
                    // and if no eio thing handles the upgrade
                    // then the socket needs to die!
                    setTimeout(function () {
                        // @ts-ignore
                        if (socket.writable && socket.bytesWritten <= 0) {
                            socket.on("error", (e) => {
                                debug("error while destroying upgrade: %s", e.message);
                            });
                            return socket.end();
                        }
                    }, destroyUpgradeTimeout);
                }
            });
        }
    }
}
exports.Server = Server;
/**
 * Close the HTTP long-polling request
 *
 * @param res - the response object
 * @param errorCode - the error code
 * @param errorContext - additional error context
 *
 * @api private
 */
function abortRequest(res, errorCode, errorContext) {
    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
    const message = errorContext && errorContext.message
        ? errorContext.message
        : Server.errorMessages[errorCode];
    res.writeHead(statusCode, { "Content-Type": "application/json" });
    res.end(JSON.stringify({
        code: errorCode,
        message,
    }));
}
/**
 * Close the WebSocket connection
 *
 * @param {net.Socket} socket
 * @param {string} errorCode - the error code
 * @param {object} errorContext - additional error context
 *
 * @api private
 */
function abortUpgrade(socket, errorCode, errorContext = {}) {
    socket.on("error", () => {
        debug("ignoring error from closed connection");
    });
    if (socket.writable) {
        const message = errorContext.message || Server.errorMessages[errorCode];
        const length = Buffer.byteLength(message);
        socket.write("HTTP/1.1 400 Bad Request\r\n" +
            "Connection: close\r\n" +
            "Content-type: text/html\r\n" +
            "Content-Length: " +
            length +
            "\r\n" +
            "\r\n" +
            message);
    }
    socket.destroy();
}
/* eslint-disable */
/**
 * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354
 *
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 *
 * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
// prettier-ignore
const validHdrChars = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255
];
function checkInvalidHeaderChar(val) {
    val += "";
    if (val.length < 1)
        return false;
    if (!validHdrChars[val.charCodeAt(0)]) {
        debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
        return true;
    }
    if (val.length < 2)
        return false;
    if (!validHdrChars[val.charCodeAt(1)]) {
        debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
        return true;
    }
    if (val.length < 3)
        return false;
    if (!validHdrChars[val.charCodeAt(2)]) {
        debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
        return true;
    }
    if (val.length < 4)
        return false;
    if (!validHdrChars[val.charCodeAt(3)]) {
        debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
        return true;
    }
    for (let i = 4; i < val.length; ++i) {
        if (!validHdrChars[val.charCodeAt(i)]) {
            debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "../../node_modules/engine.io/build/socket.js":
/*!****************************************************!*\
  !*** ../../node_modules/engine.io/build/socket.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Socket = void 0;
const events_1 = __webpack_require__(/*! events */ "events");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const timers_1 = __webpack_require__(/*! timers */ "timers");
const debug = (0, debug_1.default)("engine:socket");
class Socket extends events_1.EventEmitter {
    /**
     * Client class (abstract).
     *
     * @api private
     */
    constructor(id, server, transport, req, protocol) {
        super();
        this._readyState = "opening";
        this.upgrading = false;
        this.upgraded = false;
        this.writeBuffer = [];
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.cleanupFn = [];
        this.id = id;
        this.server = server;
        this.request = req;
        this.protocol = protocol;
        // Cache IP since it might not be in the req later
        if (req) {
            if (req.websocket && req.websocket._socket) {
                this.remoteAddress = req.websocket._socket.remoteAddress;
            }
            else {
                this.remoteAddress = req.connection.remoteAddress;
            }
        }
        else {
            // TODO there is currently no way to get the IP address of the client when it connects with WebTransport
            //  see https://github.com/fails-components/webtransport/issues/114
        }
        this.pingTimeoutTimer = null;
        this.pingIntervalTimer = null;
        this.setTransport(transport);
        this.onOpen();
    }
    get readyState() {
        return this._readyState;
    }
    set readyState(state) {
        debug("readyState updated from %s to %s", this._readyState, state);
        this._readyState = state;
    }
    /**
     * Called upon transport considered open.
     *
     * @api private
     */
    onOpen() {
        this.readyState = "open";
        // sends an `open` packet
        this.transport.sid = this.id;
        this.sendPacket("open", JSON.stringify({
            sid: this.id,
            upgrades: this.getAvailableUpgrades(),
            pingInterval: this.server.opts.pingInterval,
            pingTimeout: this.server.opts.pingTimeout,
            maxPayload: this.server.opts.maxHttpBufferSize,
        }));
        if (this.server.opts.initialPacket) {
            this.sendPacket("message", this.server.opts.initialPacket);
        }
        this.emit("open");
        if (this.protocol === 3) {
            // in protocol v3, the client sends a ping, and the server answers with a pong
            this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
        }
        else {
            // in protocol v4, the server sends a ping, and the client answers with a pong
            this.schedulePing();
        }
    }
    /**
     * Called upon transport packet.
     *
     * @param {Object} packet
     * @api private
     */
    onPacket(packet) {
        if ("open" !== this.readyState) {
            return debug("packet received with closed socket");
        }
        // export packet event
        debug(`received packet ${packet.type}`);
        this.emit("packet", packet);
        // Reset ping timeout on any packet, incoming data is a good sign of
        // other side's liveness
        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
        switch (packet.type) {
            case "ping":
                if (this.transport.protocol !== 3) {
                    this.onError("invalid heartbeat direction");
                    return;
                }
                debug("got ping");
                this.sendPacket("pong");
                this.emit("heartbeat");
                break;
            case "pong":
                if (this.transport.protocol === 3) {
                    this.onError("invalid heartbeat direction");
                    return;
                }
                debug("got pong");
                this.pingIntervalTimer.refresh();
                this.emit("heartbeat");
                break;
            case "error":
                this.onClose("parse error");
                break;
            case "message":
                this.emit("data", packet.data);
                this.emit("message", packet.data);
                break;
        }
    }
    /**
     * Called upon transport error.
     *
     * @param {Error} err - error object
     * @api private
     */
    onError(err) {
        debug("transport error");
        this.onClose("transport error", err);
    }
    /**
     * Pings client every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @api private
     */
    schedulePing() {
        this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {
            debug("writing ping packet - expecting pong within %sms", this.server.opts.pingTimeout);
            this.sendPacket("ping");
            this.resetPingTimeout(this.server.opts.pingTimeout);
        }, this.server.opts.pingInterval);
    }
    /**
     * Resets ping timeout.
     *
     * @api private
     */
    resetPingTimeout(timeout) {
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {
            if (this.readyState === "closed")
                return;
            this.onClose("ping timeout");
        }, timeout);
    }
    /**
     * Attaches handlers for the given transport.
     *
     * @param {Transport} transport
     * @api private
     */
    setTransport(transport) {
        const onError = this.onError.bind(this);
        const onPacket = this.onPacket.bind(this);
        const flush = this.flush.bind(this);
        const onClose = this.onClose.bind(this, "transport close");
        this.transport = transport;
        this.transport.once("error", onError);
        this.transport.on("packet", onPacket);
        this.transport.on("drain", flush);
        this.transport.once("close", onClose);
        // this function will manage packet events (also message callbacks)
        this.setupSendCallback();
        this.cleanupFn.push(function () {
            transport.removeListener("error", onError);
            transport.removeListener("packet", onPacket);
            transport.removeListener("drain", flush);
            transport.removeListener("close", onClose);
        });
    }
    /**
     * Upgrades socket to the given transport
     *
     * @param {Transport} transport
     * @api private
     */
    maybeUpgrade(transport) {
        debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
        this.upgrading = true;
        // set transport upgrade timer
        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {
            debug("client did not complete upgrade - closing transport");
            cleanup();
            if ("open" === transport.readyState) {
                transport.close();
            }
        }, this.server.opts.upgradeTimeout);
        let checkIntervalTimer;
        const onPacket = (packet) => {
            if ("ping" === packet.type && "probe" === packet.data) {
                debug("got probe ping packet, sending pong");
                transport.send([{ type: "pong", data: "probe" }]);
                this.emit("upgrading", transport);
                clearInterval(checkIntervalTimer);
                checkIntervalTimer = setInterval(check, 100);
            }
            else if ("upgrade" === packet.type && this.readyState !== "closed") {
                debug("got upgrade packet - upgrading");
                cleanup();
                this.transport.discard();
                this.upgraded = true;
                this.clearTransport();
                this.setTransport(transport);
                this.emit("upgrade", transport);
                this.flush();
                if (this.readyState === "closing") {
                    transport.close(() => {
                        this.onClose("forced close");
                    });
                }
            }
            else {
                cleanup();
                transport.close();
            }
        };
        // we force a polling cycle to ensure a fast upgrade
        const check = () => {
            if ("polling" === this.transport.name && this.transport.writable) {
                debug("writing a noop packet to polling for fast upgrade");
                this.transport.send([{ type: "noop" }]);
            }
        };
        const cleanup = () => {
            this.upgrading = false;
            clearInterval(checkIntervalTimer);
            (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
            transport.removeListener("packet", onPacket);
            transport.removeListener("close", onTransportClose);
            transport.removeListener("error", onError);
            this.removeListener("close", onClose);
        };
        const onError = (err) => {
            debug("client did not complete upgrade - %s", err);
            cleanup();
            transport.close();
            transport = null;
        };
        const onTransportClose = () => {
            onError("transport closed");
        };
        const onClose = () => {
            onError("socket closed");
        };
        transport.on("packet", onPacket);
        transport.once("close", onTransportClose);
        transport.once("error", onError);
        this.once("close", onClose);
    }
    /**
     * Clears listeners and timers associated with current transport.
     *
     * @api private
     */
    clearTransport() {
        let cleanup;
        const toCleanUp = this.cleanupFn.length;
        for (let i = 0; i < toCleanUp; i++) {
            cleanup = this.cleanupFn.shift();
            cleanup();
        }
        // silence further transport errors and prevent uncaught exceptions
        this.transport.on("error", function () {
            debug("error triggered by discarded transport");
        });
        // ensure transport won't stay open
        this.transport.close();
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    }
    /**
     * Called upon transport considered closed.
     * Possible reasons: `ping timeout`, `client error`, `parse error`,
     * `transport error`, `server close`, `transport close`
     */
    onClose(reason, description) {
        if ("closed" !== this.readyState) {
            this.readyState = "closed";
            // clear timers
            (0, timers_1.clearTimeout)(this.pingIntervalTimer);
            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
            // clean writeBuffer in next tick, so developers can still
            // grab the writeBuffer on 'close' event
            process.nextTick(() => {
                this.writeBuffer = [];
            });
            this.packetsFn = [];
            this.sentCallbackFn = [];
            this.clearTransport();
            this.emit("close", reason, description);
        }
    }
    /**
     * Setup and manage send callback
     *
     * @api private
     */
    setupSendCallback() {
        // the message was sent successfully, execute the callback
        const onDrain = () => {
            if (this.sentCallbackFn.length > 0) {
                const seqFn = this.sentCallbackFn.splice(0, 1)[0];
                if ("function" === typeof seqFn) {
                    debug("executing send callback");
                    seqFn(this.transport);
                }
                else if (Array.isArray(seqFn)) {
                    debug("executing batch send callback");
                    const l = seqFn.length;
                    let i = 0;
                    for (; i < l; i++) {
                        if ("function" === typeof seqFn[i]) {
                            seqFn[i](this.transport);
                        }
                    }
                }
            }
        };
        this.transport.on("drain", onDrain);
        this.cleanupFn.push(() => {
            this.transport.removeListener("drain", onDrain);
        });
    }
    /**
     * Sends a message packet.
     *
     * @param {Object} data
     * @param {Object} options
     * @param {Function} callback
     * @return {Socket} for chaining
     * @api public
     */
    send(data, options, callback) {
        this.sendPacket("message", data, options, callback);
        return this;
    }
    /**
     * Alias of {@link send}.
     *
     * @param data
     * @param options
     * @param callback
     */
    write(data, options, callback) {
        this.sendPacket("message", data, options, callback);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type - packet type
     * @param {String} data
     * @param {Object} options
     * @param {Function} callback
     *
     * @api private
     */
    sendPacket(type, data, options = {}, callback) {
        if ("function" === typeof options) {
            callback = options;
            options = {};
        }
        if ("closing" !== this.readyState && "closed" !== this.readyState) {
            debug('sending packet "%s" (%s)', type, data);
            // compression is enabled by default
            options.compress = options.compress !== false;
            const packet = {
                type,
                options: options,
            };
            if (data)
                packet.data = data;
            // exports packetCreate event
            this.emit("packetCreate", packet);
            this.writeBuffer.push(packet);
            // add send callback to object, if defined
            if (callback)
                this.packetsFn.push(callback);
            this.flush();
        }
    }
    /**
     * Attempts to flush the packets buffer.
     *
     * @api private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            this.writeBuffer.length) {
            debug("flushing buffer to transport");
            this.emit("flush", this.writeBuffer);
            this.server.emit("flush", this, this.writeBuffer);
            const wbuf = this.writeBuffer;
            this.writeBuffer = [];
            if (!this.transport.supportsFraming) {
                this.sentCallbackFn.push(this.packetsFn);
            }
            else {
                this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
            }
            this.packetsFn = [];
            this.transport.send(wbuf);
            this.emit("drain");
            this.server.emit("drain", this);
        }
    }
    /**
     * Get available upgrades for this socket.
     *
     * @api private
     */
    getAvailableUpgrades() {
        const availableUpgrades = [];
        const allUpgrades = this.server.upgrades(this.transport.name);
        let i = 0;
        const l = allUpgrades.length;
        for (; i < l; ++i) {
            const upg = allUpgrades[i];
            if (this.server.opts.transports.indexOf(upg) !== -1) {
                availableUpgrades.push(upg);
            }
        }
        return availableUpgrades;
    }
    /**
     * Closes the socket and underlying transport.
     *
     * @param {Boolean} discard - optional, discard the transport
     * @return {Socket} for chaining
     * @api public
     */
    close(discard) {
        if ("open" !== this.readyState)
            return;
        this.readyState = "closing";
        if (this.writeBuffer.length) {
            debug("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
            this.once("drain", () => {
                debug("all packets have been sent, closing the transport");
                this.closeTransport(discard);
            });
            return;
        }
        debug("the buffer is empty, closing the transport right away", discard);
        this.closeTransport(discard);
    }
    /**
     * Closes the underlying transport.
     *
     * @param {Boolean} discard
     * @api private
     */
    closeTransport(discard) {
        debug("closing the transport (discard? %s)", discard);
        if (discard)
            this.transport.discard();
        this.transport.close(this.onClose.bind(this, "forced close"));
    }
}
exports.Socket = Socket;


/***/ }),

/***/ "../../node_modules/engine.io/build/transport.js":
/*!*******************************************************!*\
  !*** ../../node_modules/engine.io/build/transport.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transport = void 0;
const events_1 = __webpack_require__(/*! events */ "events");
const parser_v4 = __webpack_require__(/*! engine.io-parser */ "../../node_modules/engine.io-parser/build/cjs/index.js");
const parser_v3 = __webpack_require__(/*! ./parser-v3/index */ "../../node_modules/engine.io/build/parser-v3/index.js");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const debug = (0, debug_1.default)("engine:transport");
/**
 * Noop function.
 *
 * @api private
 */
function noop() { }
class Transport extends events_1.EventEmitter {
    /**
     * Transport constructor.
     *
     * @param {http.IncomingMessage} req
     * @api public
     */
    constructor(req) {
        super();
        this.writable = false;
        this._readyState = "open";
        this.discarded = false;
        this.protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default
        this.parser = this.protocol === 4 ? parser_v4 : parser_v3;
        this.supportsBinary = !(req._query && req._query.b64);
    }
    get readyState() {
        return this._readyState;
    }
    set readyState(state) {
        debug("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
        this._readyState = state;
    }
    /**
     * Flags the transport as discarded.
     *
     * @api private
     */
    discard() {
        this.discarded = true;
    }
    /**
     * Called with an incoming HTTP request.
     *
     * @param {http.IncomingMessage} req
     * @api protected
     */
    onRequest(req) {
        debug("setting request");
        this.req = req;
    }
    /**
     * Closes the transport.
     *
     * @api private
     */
    close(fn) {
        if ("closed" === this.readyState || "closing" === this.readyState)
            return;
        this.readyState = "closing";
        this.doClose(fn || noop);
    }
    /**
     * Called with a transport error.
     *
     * @param {String} msg - message error
     * @param {Object} desc - error description
     * @api protected
     */
    onError(msg, desc) {
        if (this.listeners("error").length) {
            const err = new Error(msg);
            // @ts-ignore
            err.type = "TransportError";
            // @ts-ignore
            err.description = desc;
            this.emit("error", err);
        }
        else {
            debug("ignored transport error %s (%s)", msg, desc);
        }
    }
    /**
     * Called with parsed out a packets from the data stream.
     *
     * @param {Object} packet
     * @api protected
     */
    onPacket(packet) {
        this.emit("packet", packet);
    }
    /**
     * Called with the encoded packet data.
     *
     * @param {String} data
     * @api protected
     */
    onData(data) {
        this.onPacket(this.parser.decodePacket(data));
    }
    /**
     * Called upon transport close.
     *
     * @api protected
     */
    onClose() {
        this.readyState = "closed";
        this.emit("close");
    }
}
exports.Transport = Transport;


/***/ }),

/***/ "../../node_modules/engine.io/build/transports-uws/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/engine.io/build/transports-uws/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const polling_1 = __webpack_require__(/*! ./polling */ "../../node_modules/engine.io/build/transports-uws/polling.js");
const websocket_1 = __webpack_require__(/*! ./websocket */ "../../node_modules/engine.io/build/transports-uws/websocket.js");
exports["default"] = {
    polling: polling_1.Polling,
    websocket: websocket_1.WebSocket,
};


/***/ }),

/***/ "../../node_modules/engine.io/build/transports-uws/polling.js":
/*!********************************************************************!*\
  !*** ../../node_modules/engine.io/build/transports-uws/polling.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Polling = void 0;
const transport_1 = __webpack_require__(/*! ../transport */ "../../node_modules/engine.io/build/transport.js");
const zlib_1 = __webpack_require__(/*! zlib */ "zlib");
const accepts = __webpack_require__(/*! accepts */ "../../node_modules/accepts/index.js");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const debug = (0, debug_1.default)("engine:polling");
const compressionMethods = {
    gzip: zlib_1.createGzip,
    deflate: zlib_1.createDeflate,
};
class Polling extends transport_1.Transport {
    /**
     * HTTP polling constructor.
     *
     * @api public.
     */
    constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1000;
    }
    /**
     * Transport name
     *
     * @api public
     */
    get name() {
        return "polling";
    }
    get supportsFraming() {
        return false;
    }
    /**
     * Overrides onRequest.
     *
     * @param req
     *
     * @api private
     */
    onRequest(req) {
        const res = req.res;
        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)
        req.res = null;
        if (req.getMethod() === "get") {
            this.onPollRequest(req, res);
        }
        else if (req.getMethod() === "post") {
            this.onDataRequest(req, res);
        }
        else {
            res.writeStatus("500 Internal Server Error");
            res.end();
        }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @api private
     */
    onPollRequest(req, res) {
        if (this.req) {
            debug("request overlap");
            // assert: this.res, '.req and .res should be (un)set together'
            this.onError("overlap from client");
            res.writeStatus("500 Internal Server Error");
            res.end();
            return;
        }
        debug("setting request");
        this.req = req;
        this.res = res;
        const onClose = () => {
            this.writable = false;
            this.onError("poll connection closed prematurely");
        };
        const cleanup = () => {
            this.req = this.res = null;
        };
        req.cleanup = cleanup;
        res.onAborted(onClose);
        this.writable = true;
        this.emit("drain");
        // if we're still writable but had a pending close, trigger an empty send
        if (this.writable && this.shouldClose) {
            debug("triggering empty send to append close packet");
            this.send([{ type: "noop" }]);
        }
    }
    /**
     * The client sends a request with data.
     *
     * @api private
     */
    onDataRequest(req, res) {
        if (this.dataReq) {
            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
            this.onError("data request overlap from client");
            res.writeStatus("500 Internal Server Error");
            res.end();
            return;
        }
        const expectedContentLength = Number(req.headers["content-length"]);
        if (!expectedContentLength) {
            this.onError("content-length header required");
            res.writeStatus("411 Length Required").end();
            return;
        }
        if (expectedContentLength > this.maxHttpBufferSize) {
            this.onError("payload too large");
            res.writeStatus("413 Payload Too Large").end();
            return;
        }
        const isBinary = "application/octet-stream" === req.headers["content-type"];
        if (isBinary && this.protocol === 4) {
            return this.onError("invalid content");
        }
        this.dataReq = req;
        this.dataRes = res;
        let buffer;
        let offset = 0;
        const headers = {
            // text/html is required instead of text/plain to avoid an
            // unwanted download dialog on certain user-agents (GH-43)
            "Content-Type": "text/html",
        };
        this.headers(req, headers);
        for (let key in headers) {
            res.writeHeader(key, String(headers[key]));
        }
        const onEnd = (buffer) => {
            this.onData(buffer.toString());
            this.onDataRequestCleanup();
            res.cork(() => {
                res.end("ok");
            });
        };
        res.onAborted(() => {
            this.onDataRequestCleanup();
            this.onError("data request connection closed prematurely");
        });
        res.onData((arrayBuffer, isLast) => {
            const totalLength = offset + arrayBuffer.byteLength;
            if (totalLength > expectedContentLength) {
                this.onError("content-length mismatch");
                res.close(); // calls onAborted
                return;
            }
            if (!buffer) {
                if (isLast) {
                    onEnd(Buffer.from(arrayBuffer));
                    return;
                }
                buffer = Buffer.allocUnsafe(expectedContentLength);
            }
            Buffer.from(arrayBuffer).copy(buffer, offset);
            if (isLast) {
                if (totalLength != expectedContentLength) {
                    this.onError("content-length mismatch");
                    res.writeStatus("400 Content-Length Mismatch").end();
                    this.onDataRequestCleanup();
                    return;
                }
                onEnd(buffer);
                return;
            }
            offset = totalLength;
        });
    }
    /**
     * Cleanup request.
     *
     * @api private
     */
    onDataRequestCleanup() {
        this.dataReq = this.dataRes = null;
    }
    /**
     * Processes the incoming data payload.
     *
     * @param {String} encoded payload
     * @api private
     */
    onData(data) {
        debug('received "%s"', data);
        const callback = (packet) => {
            if ("close" === packet.type) {
                debug("got xhr close packet");
                this.onClose();
                return false;
            }
            this.onPacket(packet);
        };
        if (this.protocol === 3) {
            this.parser.decodePayload(data, callback);
        }
        else {
            this.parser.decodePayload(data).forEach(callback);
        }
    }
    /**
     * Overrides onClose.
     *
     * @api private
     */
    onClose() {
        if (this.writable) {
            // close pending poll request
            this.send([{ type: "noop" }]);
        }
        super.onClose();
    }
    /**
     * Writes a packet payload.
     *
     * @param {Object} packet
     * @api private
     */
    send(packets) {
        this.writable = false;
        if (this.shouldClose) {
            debug("appending close packet to payload");
            packets.push({ type: "close" });
            this.shouldClose();
            this.shouldClose = null;
        }
        const doWrite = (data) => {
            const compress = packets.some((packet) => {
                return packet.options && packet.options.compress;
            });
            this.write(data, { compress });
        };
        if (this.protocol === 3) {
            this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        }
        else {
            this.parser.encodePayload(packets, doWrite);
        }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @api private
     */
    write(data, options) {
        debug('writing "%s"', data);
        this.doWrite(data, options, () => {
            this.req.cleanup();
        });
    }
    /**
     * Performs the write.
     *
     * @api private
     */
    doWrite(data, options, callback) {
        // explicit UTF-8 is required for pages not served under utf
        const isString = typeof data === "string";
        const contentType = isString
            ? "text/plain; charset=UTF-8"
            : "application/octet-stream";
        const headers = {
            "Content-Type": contentType,
        };
        const respond = (data) => {
            this.headers(this.req, headers);
            this.res.cork(() => {
                Object.keys(headers).forEach((key) => {
                    this.res.writeHeader(key, String(headers[key]));
                });
                this.res.end(data);
            });
            callback();
        };
        if (!this.httpCompression || !options.compress) {
            respond(data);
            return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len < this.httpCompression.threshold) {
            respond(data);
            return;
        }
        const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
        if (!encoding) {
            respond(data);
            return;
        }
        this.compress(data, encoding, (err, data) => {
            if (err) {
                this.res.writeStatus("500 Internal Server Error");
                this.res.end();
                callback(err);
                return;
            }
            headers["Content-Encoding"] = encoding;
            respond(data);
        });
    }
    /**
     * Compresses data.
     *
     * @api private
     */
    compress(data, encoding, callback) {
        debug("compressing");
        const buffers = [];
        let nread = 0;
        compressionMethods[encoding](this.httpCompression)
            .on("error", callback)
            .on("data", function (chunk) {
            buffers.push(chunk);
            nread += chunk.length;
        })
            .on("end", function () {
            callback(null, Buffer.concat(buffers, nread));
        })
            .end(data);
    }
    /**
     * Closes the transport.
     *
     * @api private
     */
    doClose(fn) {
        debug("closing");
        let closeTimeoutTimer;
        const onClose = () => {
            clearTimeout(closeTimeoutTimer);
            fn();
            this.onClose();
        };
        if (this.writable) {
            debug("transport writable - closing right away");
            this.send([{ type: "close" }]);
            onClose();
        }
        else if (this.discarded) {
            debug("transport discarded - closing right away");
            onClose();
        }
        else {
            debug("transport not writable - buffering orderly close");
            this.shouldClose = onClose;
            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
    }
    /**
     * Returns headers for a response.
     *
     * @param req - request
     * @param {Object} extra headers
     * @api private
     */
    headers(req, headers) {
        headers = headers || {};
        // prevent XSS warnings on IE
        // https://github.com/LearnBoost/socket.io/pull/1333
        const ua = req.headers["user-agent"];
        if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
            headers["X-XSS-Protection"] = "0";
        }
        headers["cache-control"] = "no-store";
        this.emit("headers", headers, req);
        return headers;
    }
}
exports.Polling = Polling;


/***/ }),

/***/ "../../node_modules/engine.io/build/transports-uws/websocket.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/engine.io/build/transports-uws/websocket.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocket = void 0;
const transport_1 = __webpack_require__(/*! ../transport */ "../../node_modules/engine.io/build/transport.js");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const debug = (0, debug_1.default)("engine:ws");
class WebSocket extends transport_1.Transport {
    /**
     * WebSocket transport
     *
     * @param req
     * @api public
     */
    constructor(req) {
        super(req);
        this.writable = false;
        this.perMessageDeflate = null;
    }
    /**
     * Transport name
     *
     * @api public
     */
    get name() {
        return "websocket";
    }
    /**
     * Advertise upgrade support.
     *
     * @api public
     */
    get handlesUpgrades() {
        return true;
    }
    /**
     * Advertise framing support.
     *
     * @api public
     */
    get supportsFraming() {
        return true;
    }
    /**
     * Writes a packet payload.
     *
     * @param {Array} packets
     * @api private
     */
    send(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const isLast = i + 1 === packets.length;
            const send = (data) => {
                const isBinary = typeof data !== "string";
                const compress = this.perMessageDeflate &&
                    Buffer.byteLength(data) > this.perMessageDeflate.threshold;
                debug('writing "%s"', data);
                this.socket.send(data, isBinary, compress);
                if (isLast) {
                    this.writable = true;
                    this.emit("drain");
                }
            };
            if (packet.options && typeof packet.options.wsPreEncoded === "string") {
                send(packet.options.wsPreEncoded);
            }
            else {
                this.parser.encodePacket(packet, this.supportsBinary, send);
            }
        }
    }
    /**
     * Closes the transport.
     *
     * @api private
     */
    doClose(fn) {
        debug("closing");
        fn && fn();
        // call fn first since socket.end() immediately emits a "close" event
        this.socket.end();
    }
}
exports.WebSocket = WebSocket;


/***/ }),

/***/ "../../node_modules/engine.io/build/transports/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/engine.io/build/transports/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const polling_1 = __webpack_require__(/*! ./polling */ "../../node_modules/engine.io/build/transports/polling.js");
const polling_jsonp_1 = __webpack_require__(/*! ./polling-jsonp */ "../../node_modules/engine.io/build/transports/polling-jsonp.js");
const websocket_1 = __webpack_require__(/*! ./websocket */ "../../node_modules/engine.io/build/transports/websocket.js");
const webtransport_1 = __webpack_require__(/*! ./webtransport */ "../../node_modules/engine.io/build/transports/webtransport.js");
exports["default"] = {
    polling: polling,
    websocket: websocket_1.WebSocket,
    webtransport: webtransport_1.WebTransport,
};
/**
 * Polling polymorphic constructor.
 *
 * @api private
 */
function polling(req) {
    if ("string" === typeof req._query.j) {
        return new polling_jsonp_1.JSONP(req);
    }
    else {
        return new polling_1.Polling(req);
    }
}
polling.upgradesTo = ["websocket", "webtransport"];


/***/ }),

/***/ "../../node_modules/engine.io/build/transports/polling-jsonp.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/engine.io/build/transports/polling-jsonp.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONP = void 0;
const polling_1 = __webpack_require__(/*! ./polling */ "../../node_modules/engine.io/build/transports/polling.js");
const qs = __webpack_require__(/*! querystring */ "querystring");
const rDoubleSlashes = /\\\\n/g;
const rSlashes = /(\\)?\\n/g;
class JSONP extends polling_1.Polling {
    /**
     * JSON-P polling transport.
     *
     * @api public
     */
    constructor(req) {
        super(req);
        this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
        this.foot = ");";
    }
    /**
     * Handles incoming data.
     * Due to a bug in \n handling by browsers, we expect a escaped string.
     *
     * @api private
     */
    onData(data) {
        // we leverage the qs module so that we get built-in DoS protection
        // and the fast alternative to decodeURIComponent
        data = qs.parse(data).d;
        if ("string" === typeof data) {
            // client will send already escaped newlines as \\\\n and newlines as \\n
            // \\n must be replaced with \n and \\\\n with \\n
            data = data.replace(rSlashes, function (match, slashes) {
                return slashes ? match : "\n";
            });
            super.onData(data.replace(rDoubleSlashes, "\\n"));
        }
    }
    /**
     * Performs the write.
     *
     * @api private
     */
    doWrite(data, options, callback) {
        // we must output valid javascript, not valid json
        // see: http://timelessrepo.com/json-isnt-a-javascript-subset
        const js = JSON.stringify(data)
            .replace(/\u2028/g, "\\u2028")
            .replace(/\u2029/g, "\\u2029");
        // prepare response
        data = this.head + js + this.foot;
        super.doWrite(data, options, callback);
    }
}
exports.JSONP = JSONP;


/***/ }),

/***/ "../../node_modules/engine.io/build/transports/polling.js":
/*!****************************************************************!*\
  !*** ../../node_modules/engine.io/build/transports/polling.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Polling = void 0;
const transport_1 = __webpack_require__(/*! ../transport */ "../../node_modules/engine.io/build/transport.js");
const zlib_1 = __webpack_require__(/*! zlib */ "zlib");
const accepts = __webpack_require__(/*! accepts */ "../../node_modules/accepts/index.js");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const debug = (0, debug_1.default)("engine:polling");
const compressionMethods = {
    gzip: zlib_1.createGzip,
    deflate: zlib_1.createDeflate,
};
class Polling extends transport_1.Transport {
    /**
     * HTTP polling constructor.
     *
     * @api public.
     */
    constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1000;
    }
    /**
     * Transport name
     *
     * @api public
     */
    get name() {
        return "polling";
    }
    get supportsFraming() {
        return false;
    }
    /**
     * Overrides onRequest.
     *
     * @param {http.IncomingMessage}
     * @api private
     */
    onRequest(req) {
        const res = req.res;
        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)
        req.res = null;
        if ("GET" === req.method) {
            this.onPollRequest(req, res);
        }
        else if ("POST" === req.method) {
            this.onDataRequest(req, res);
        }
        else {
            res.writeHead(500);
            res.end();
        }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @api private
     */
    onPollRequest(req, res) {
        if (this.req) {
            debug("request overlap");
            // assert: this.res, '.req and .res should be (un)set together'
            this.onError("overlap from client");
            res.writeHead(400);
            res.end();
            return;
        }
        debug("setting request");
        this.req = req;
        this.res = res;
        const onClose = () => {
            this.onError("poll connection closed prematurely");
        };
        const cleanup = () => {
            req.removeListener("close", onClose);
            this.req = this.res = null;
        };
        req.cleanup = cleanup;
        req.on("close", onClose);
        this.writable = true;
        this.emit("drain");
        // if we're still writable but had a pending close, trigger an empty send
        if (this.writable && this.shouldClose) {
            debug("triggering empty send to append close packet");
            this.send([{ type: "noop" }]);
        }
    }
    /**
     * The client sends a request with data.
     *
     * @api private
     */
    onDataRequest(req, res) {
        if (this.dataReq) {
            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
            this.onError("data request overlap from client");
            res.writeHead(400);
            res.end();
            return;
        }
        const isBinary = "application/octet-stream" === req.headers["content-type"];
        if (isBinary && this.protocol === 4) {
            return this.onError("invalid content");
        }
        this.dataReq = req;
        this.dataRes = res;
        let chunks = isBinary ? Buffer.concat([]) : "";
        const cleanup = () => {
            req.removeListener("data", onData);
            req.removeListener("end", onEnd);
            req.removeListener("close", onClose);
            this.dataReq = this.dataRes = chunks = null;
        };
        const onClose = () => {
            cleanup();
            this.onError("data request connection closed prematurely");
        };
        const onData = (data) => {
            let contentLength;
            if (isBinary) {
                chunks = Buffer.concat([chunks, data]);
                contentLength = chunks.length;
            }
            else {
                chunks += data;
                contentLength = Buffer.byteLength(chunks);
            }
            if (contentLength > this.maxHttpBufferSize) {
                res.writeHead(413).end();
                cleanup();
            }
        };
        const onEnd = () => {
            this.onData(chunks);
            const headers = {
                // text/html is required instead of text/plain to avoid an
                // unwanted download dialog on certain user-agents (GH-43)
                "Content-Type": "text/html",
                "Content-Length": 2,
            };
            res.writeHead(200, this.headers(req, headers));
            res.end("ok");
            cleanup();
        };
        req.on("close", onClose);
        if (!isBinary)
            req.setEncoding("utf8");
        req.on("data", onData);
        req.on("end", onEnd);
    }
    /**
     * Processes the incoming data payload.
     *
     * @param {String} encoded payload
     * @api private
     */
    onData(data) {
        debug('received "%s"', data);
        const callback = (packet) => {
            if ("close" === packet.type) {
                debug("got xhr close packet");
                this.onClose();
                return false;
            }
            this.onPacket(packet);
        };
        if (this.protocol === 3) {
            this.parser.decodePayload(data, callback);
        }
        else {
            this.parser.decodePayload(data).forEach(callback);
        }
    }
    /**
     * Overrides onClose.
     *
     * @api private
     */
    onClose() {
        if (this.writable) {
            // close pending poll request
            this.send([{ type: "noop" }]);
        }
        super.onClose();
    }
    /**
     * Writes a packet payload.
     *
     * @param {Object} packet
     * @api private
     */
    send(packets) {
        this.writable = false;
        if (this.shouldClose) {
            debug("appending close packet to payload");
            packets.push({ type: "close" });
            this.shouldClose();
            this.shouldClose = null;
        }
        const doWrite = (data) => {
            const compress = packets.some((packet) => {
                return packet.options && packet.options.compress;
            });
            this.write(data, { compress });
        };
        if (this.protocol === 3) {
            this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        }
        else {
            this.parser.encodePayload(packets, doWrite);
        }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @api private
     */
    write(data, options) {
        debug('writing "%s"', data);
        this.doWrite(data, options, () => {
            this.req.cleanup();
        });
    }
    /**
     * Performs the write.
     *
     * @api private
     */
    doWrite(data, options, callback) {
        // explicit UTF-8 is required for pages not served under utf
        const isString = typeof data === "string";
        const contentType = isString
            ? "text/plain; charset=UTF-8"
            : "application/octet-stream";
        const headers = {
            "Content-Type": contentType,
        };
        const respond = (data) => {
            headers["Content-Length"] =
                "string" === typeof data ? Buffer.byteLength(data) : data.length;
            this.res.writeHead(200, this.headers(this.req, headers));
            this.res.end(data);
            callback();
        };
        if (!this.httpCompression || !options.compress) {
            respond(data);
            return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len < this.httpCompression.threshold) {
            respond(data);
            return;
        }
        const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
        if (!encoding) {
            respond(data);
            return;
        }
        this.compress(data, encoding, (err, data) => {
            if (err) {
                this.res.writeHead(500);
                this.res.end();
                callback(err);
                return;
            }
            headers["Content-Encoding"] = encoding;
            respond(data);
        });
    }
    /**
     * Compresses data.
     *
     * @api private
     */
    compress(data, encoding, callback) {
        debug("compressing");
        const buffers = [];
        let nread = 0;
        compressionMethods[encoding](this.httpCompression)
            .on("error", callback)
            .on("data", function (chunk) {
            buffers.push(chunk);
            nread += chunk.length;
        })
            .on("end", function () {
            callback(null, Buffer.concat(buffers, nread));
        })
            .end(data);
    }
    /**
     * Closes the transport.
     *
     * @api private
     */
    doClose(fn) {
        debug("closing");
        let closeTimeoutTimer;
        if (this.dataReq) {
            debug("aborting ongoing data request");
            this.dataReq.destroy();
        }
        const onClose = () => {
            clearTimeout(closeTimeoutTimer);
            fn();
            this.onClose();
        };
        if (this.writable) {
            debug("transport writable - closing right away");
            this.send([{ type: "close" }]);
            onClose();
        }
        else if (this.discarded) {
            debug("transport discarded - closing right away");
            onClose();
        }
        else {
            debug("transport not writable - buffering orderly close");
            this.shouldClose = onClose;
            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
    }
    /**
     * Returns headers for a response.
     *
     * @param {http.IncomingMessage} request
     * @param {Object} extra headers
     * @api private
     */
    headers(req, headers) {
        headers = headers || {};
        // prevent XSS warnings on IE
        // https://github.com/LearnBoost/socket.io/pull/1333
        const ua = req.headers["user-agent"];
        if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
            headers["X-XSS-Protection"] = "0";
        }
        headers["cache-control"] = "no-store";
        this.emit("headers", headers, req);
        return headers;
    }
}
exports.Polling = Polling;


/***/ }),

/***/ "../../node_modules/engine.io/build/transports/websocket.js":
/*!******************************************************************!*\
  !*** ../../node_modules/engine.io/build/transports/websocket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocket = void 0;
const transport_1 = __webpack_require__(/*! ../transport */ "../../node_modules/engine.io/build/transport.js");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const debug = (0, debug_1.default)("engine:ws");
class WebSocket extends transport_1.Transport {
    /**
     * WebSocket transport
     *
     * @param {http.IncomingMessage}
     * @api public
     */
    constructor(req) {
        super(req);
        this.socket = req.websocket;
        this.socket.on("message", (data, isBinary) => {
            const message = isBinary ? data : data.toString();
            debug('received "%s"', message);
            super.onData(message);
        });
        this.socket.once("close", this.onClose.bind(this));
        this.socket.on("error", this.onError.bind(this));
        this.writable = true;
        this.perMessageDeflate = null;
    }
    /**
     * Transport name
     *
     * @api public
     */
    get name() {
        return "websocket";
    }
    /**
     * Advertise upgrade support.
     *
     * @api public
     */
    get handlesUpgrades() {
        return true;
    }
    /**
     * Advertise framing support.
     *
     * @api public
     */
    get supportsFraming() {
        return true;
    }
    /**
     * Writes a packet payload.
     *
     * @param {Array} packets
     * @api private
     */
    send(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const isLast = i + 1 === packets.length;
            // always creates a new object since ws modifies it
            const opts = {};
            if (packet.options) {
                opts.compress = packet.options.compress;
            }
            const onSent = (err) => {
                if (err) {
                    return this.onError("write error", err.stack);
                }
                else if (isLast) {
                    this.writable = true;
                    this.emit("drain");
                }
            };
            const send = (data) => {
                if (this.perMessageDeflate) {
                    const len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
                    if (len < this.perMessageDeflate.threshold) {
                        opts.compress = false;
                    }
                }
                debug('writing "%s"', data);
                this.socket.send(data, opts, onSent);
            };
            if (packet.options && typeof packet.options.wsPreEncoded === "string") {
                send(packet.options.wsPreEncoded);
            }
            else if (this._canSendPreEncodedFrame(packet)) {
                // the WebSocket frame was computed with WebSocket.Sender.frame()
                // see https://github.com/websockets/ws/issues/617#issuecomment-283002469
                this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, onSent);
            }
            else {
                this.parser.encodePacket(packet, this.supportsBinary, send);
            }
        }
    }
    /**
     * Whether the encoding of the WebSocket frame can be skipped.
     * @param packet
     * @private
     */
    _canSendPreEncodedFrame(packet) {
        var _a, _b, _c;
        return (!this.perMessageDeflate &&
            typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === "function" &&
            ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined);
    }
    /**
     * Closes the transport.
     *
     * @api private
     */
    doClose(fn) {
        debug("closing");
        this.socket.close();
        fn && fn();
    }
}
exports.WebSocket = WebSocket;


/***/ }),

/***/ "../../node_modules/engine.io/build/transports/webtransport.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/engine.io/build/transports/webtransport.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebTransport = void 0;
const transport_1 = __webpack_require__(/*! ../transport */ "../../node_modules/engine.io/build/transport.js");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ "../../node_modules/engine.io-parser/build/cjs/index.js");
const debug = (0, debug_1.default)("engine:webtransport");
/**
 * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API
 */
class WebTransport extends transport_1.Transport {
    constructor(session, stream, reader) {
        super({ _query: { EIO: "4" } });
        this.session = session;
        const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();
        transformStream.readable.pipeTo(stream.writable).catch(() => {
            debug("the stream was closed");
        });
        this.writer = transformStream.writable.getWriter();
        (async () => {
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        debug("session is closed");
                        break;
                    }
                    debug("received chunk: %o", value);
                    this.onPacket(value);
                }
            }
            catch (e) {
                debug("error while reading: %s", e.message);
            }
        })();
        session.closed.then(() => this.onClose());
        this.writable = true;
    }
    get name() {
        return "webtransport";
    }
    get supportsFraming() {
        return true;
    }
    async send(packets) {
        this.writable = false;
        try {
            for (let i = 0; i < packets.length; i++) {
                const packet = packets[i];
                await this.writer.write(packet);
            }
        }
        catch (e) {
            debug("error while writing: %s", e.message);
        }
        this.writable = true;
        this.emit("drain");
    }
    doClose(fn) {
        debug("closing WebTransport session");
        this.session.close();
        fn && fn();
    }
}
exports.WebTransport = WebTransport;


/***/ }),

/***/ "../../node_modules/engine.io/build/userver.js":
/*!*****************************************************!*\
  !*** ../../node_modules/engine.io/build/userver.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uServer = void 0;
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/engine.io/node_modules/debug/src/index.js");
const server_1 = __webpack_require__(/*! ./server */ "../../node_modules/engine.io/build/server.js");
const transports_uws_1 = __webpack_require__(/*! ./transports-uws */ "../../node_modules/engine.io/build/transports-uws/index.js");
const debug = (0, debug_1.default)("engine:uws");
class uServer extends server_1.BaseServer {
    init() { }
    cleanup() { }
    /**
     * Prepares a request by processing the query string.
     *
     * @api private
     */
    prepare(req, res) {
        req.method = req.getMethod().toUpperCase();
        req.url = req.getUrl();
        const params = new URLSearchParams(req.getQuery());
        req._query = Object.fromEntries(params.entries());
        req.headers = {};
        req.forEach((key, value) => {
            req.headers[key] = value;
        });
        req.connection = {
            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString(),
        };
        res.onAborted(() => {
            debug("response has been aborted");
        });
    }
    createTransport(transportName, req) {
        return new transports_uws_1.default[transportName](req);
    }
    /**
     * Attach the engine to a WebSockets.js server
     * @param app
     * @param options
     */
    attach(app /* : TemplatedApp */, options = {}) {
        const path = this._computePath(options);
        app
            .any(path, this.handleRequest.bind(this))
            //
            .ws(path, {
            compression: options.compression,
            idleTimeout: options.idleTimeout,
            maxBackpressure: options.maxBackpressure,
            maxPayloadLength: this.opts.maxHttpBufferSize,
            upgrade: this.handleUpgrade.bind(this),
            open: (ws) => {
                const transport = ws.getUserData().transport;
                transport.socket = ws;
                transport.writable = true;
                transport.emit("drain");
            },
            message: (ws, message, isBinary) => {
                ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());
            },
            close: (ws, code, message) => {
                ws.getUserData().transport.onClose(code, message);
            },
        });
    }
    _applyMiddlewares(req, res, callback) {
        if (this.middlewares.length === 0) {
            return callback();
        }
        // needed to buffer headers until the status is computed
        req.res = new ResponseWrapper(res);
        super._applyMiddlewares(req, req.res, (err) => {
            // some middlewares (like express-session) wait for the writeHead() call to flush their headers
            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244
            req.res.writeHead();
            callback(err);
        });
    }
    handleRequest(res, req) {
        debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
        this.prepare(req, res);
        req.res = res;
        const callback = (errorCode, errorContext) => {
            if (errorCode !== undefined) {
                this.emit("connection_error", {
                    req,
                    code: errorCode,
                    message: server_1.Server.errorMessages[errorCode],
                    context: errorContext,
                });
                this.abortRequest(req.res, errorCode, errorContext);
                return;
            }
            if (req._query.sid) {
                debug("setting new request for existing client");
                this.clients[req._query.sid].transport.onRequest(req);
            }
            else {
                const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);
                this.handshake(req._query.transport, req, closeConnection);
            }
        };
        this._applyMiddlewares(req, res, (err) => {
            if (err) {
                callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
            }
            else {
                this.verify(req, false, callback);
            }
        });
    }
    handleUpgrade(res, req, context) {
        debug("on upgrade");
        this.prepare(req, res);
        req.res = res;
        const callback = async (errorCode, errorContext) => {
            if (errorCode !== undefined) {
                this.emit("connection_error", {
                    req,
                    code: errorCode,
                    message: server_1.Server.errorMessages[errorCode],
                    context: errorContext,
                });
                this.abortRequest(res, errorCode, errorContext);
                return;
            }
            const id = req._query.sid;
            let transport;
            if (id) {
                const client = this.clients[id];
                if (!client) {
                    debug("upgrade attempt for closed client");
                    res.close();
                }
                else if (client.upgrading) {
                    debug("transport has already been trying to upgrade");
                    res.close();
                }
                else if (client.upgraded) {
                    debug("transport had already been upgraded");
                    res.close();
                }
                else {
                    debug("upgrading existing transport");
                    transport = this.createTransport(req._query.transport, req);
                    client.maybeUpgrade(transport);
                }
            }
            else {
                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));
                if (!transport) {
                    return;
                }
            }
            // calling writeStatus() triggers the flushing of any header added in a middleware
            req.res.writeStatus("101 Switching Protocols");
            res.upgrade({
                transport,
            }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);
        };
        this._applyMiddlewares(req, res, (err) => {
            if (err) {
                callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
            }
            else {
                this.verify(req, true, callback);
            }
        });
    }
    abortRequest(res, errorCode, errorContext) {
        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN
            ? "403 Forbidden"
            : "400 Bad Request";
        const message = errorContext && errorContext.message
            ? errorContext.message
            : server_1.Server.errorMessages[errorCode];
        res.writeStatus(statusCode);
        res.writeHeader("Content-Type", "application/json");
        res.end(JSON.stringify({
            code: errorCode,
            message,
        }));
    }
}
exports.uServer = uServer;
class ResponseWrapper {
    constructor(res) {
        this.res = res;
        this.statusWritten = false;
        this.headers = [];
        this.isAborted = false;
    }
    set statusCode(status) {
        if (!status) {
            return;
        }
        // FIXME: handle all status codes?
        this.writeStatus(status === 200 ? "200 OK" : "204 No Content");
    }
    writeHead(status) {
        this.statusCode = status;
    }
    setHeader(key, value) {
        if (Array.isArray(value)) {
            value.forEach((val) => {
                this.writeHeader(key, val);
            });
        }
        else {
            this.writeHeader(key, value);
        }
    }
    removeHeader() {
        // FIXME: not implemented
    }
    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134
    getHeader() { }
    writeStatus(status) {
        if (this.isAborted)
            return;
        this.res.writeStatus(status);
        this.statusWritten = true;
        this.writeBufferedHeaders();
        return this;
    }
    writeHeader(key, value) {
        if (this.isAborted)
            return;
        if (key === "Content-Length") {
            // the content length is automatically added by uWebSockets.js
            return;
        }
        if (this.statusWritten) {
            this.res.writeHeader(key, value);
        }
        else {
            this.headers.push([key, value]);
        }
    }
    writeBufferedHeaders() {
        this.headers.forEach(([key, value]) => {
            this.res.writeHeader(key, value);
        });
    }
    end(data) {
        if (this.isAborted)
            return;
        this.res.cork(() => {
            if (!this.statusWritten) {
                // status will be inferred as "200 OK"
                this.writeBufferedHeaders();
            }
            this.res.end(data);
        });
    }
    onData(fn) {
        if (this.isAborted)
            return;
        this.res.onData(fn);
    }
    onAborted(fn) {
        if (this.isAborted)
            return;
        this.res.onAborted(() => {
            // Any attempt to use the UWS response object after abort will throw!
            this.isAborted = true;
            fn();
        });
    }
    cork(fn) {
        if (this.isAborted)
            return;
        this.res.cork(fn);
    }
}


/***/ }),

/***/ "../../node_modules/socket.io-parser/build/cjs/binary.js":
/*!***************************************************************!*\
  !*** ../../node_modules/socket.io-parser/build/cjs/binary.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reconstructPacket = exports.deconstructPacket = void 0;
const is_binary_js_1 = __webpack_require__(/*! ./is-binary.js */ "../../node_modules/socket.io-parser/build/cjs/is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
exports.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if ((0, is_binary_js_1.isBinary)(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
exports.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" &&
            data.num >= 0 &&
            data.num < buffers.length;
        if (isIndexValid) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        }
        else {
            throw new Error("illegal attachments");
        }
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}


/***/ }),

/***/ "../../node_modules/socket.io-parser/build/cjs/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/socket.io-parser/build/cjs/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
const component_emitter_1 = __webpack_require__(/*! @socket.io/component-emitter */ "../../node_modules/@socket.io/component-emitter/index.mjs");
const binary_js_1 = __webpack_require__(/*! ./binary.js */ "../../node_modules/socket.io-parser/build/cjs/binary.js");
const is_binary_js_1 = __webpack_require__(/*! ./is-binary.js */ "../../node_modules/socket.io-parser/build/cjs/is-binary.js");
const debug_1 = __webpack_require__(/*! debug */ "../../node_modules/socket.io-parser/node_modules/debug/src/index.js"); // debug()
const debug = (0, debug_1.default)("socket.io-parser"); // debug()
/**
 * These strings must not be used as event names, as they have a special meaning.
 */
const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener", // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
exports.protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if ((0, is_binary_js_1.hasBinary)(obj)) {
                return this.encodeAsBinary({
                    type: obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK,
                    nsp: obj.nsp,
                    data: obj.data,
                    id: obj.id,
                });
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
        }
        debug("encoded %j as %s", obj, str);
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
exports.Encoder = Encoder;
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends component_emitter_1.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) {
                throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        debug("decoded %s as %j", str, p);
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        }
        catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return isObject(payload);
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || isObject(payload);
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return (Array.isArray(payload) &&
                    (typeof payload[0] === "number" ||
                        (typeof payload[0] === "string" &&
                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
exports.Decoder = Decoder;
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}


/***/ }),

/***/ "../../node_modules/socket.io-parser/build/cjs/is-binary.js":
/*!******************************************************************!*\
  !*** ../../node_modules/socket.io-parser/build/cjs/is-binary.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasBinary = exports.isBinary = void 0;
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
exports.isBinary = isBinary;
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}
exports.hasBinary = hasBinary;


/***/ }),

/***/ "../../node_modules/socket.io/dist/broadcast-operator.js":
/*!***************************************************************!*\
  !*** ../../node_modules/socket.io/dist/broadcast-operator.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoteSocket = exports.BroadcastOperator = void 0;
const socket_1 = __webpack_require__(/*! ./socket */ "../../node_modules/socket.io/dist/socket.js");
const socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "../../node_modules/socket.io-parser/build/cjs/index.js");
class BroadcastOperator {
    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {
        this.adapter = adapter;
        this.rooms = rooms;
        this.exceptRooms = exceptRooms;
        this.flags = flags;
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * io.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
        const rooms = new Set(this.rooms);
        if (Array.isArray(room)) {
            room.forEach((r) => rooms.add(r));
        }
        else {
            rooms.add(room);
        }
        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * // disconnect all clients in the "room-101" room
     * io.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
        return this.to(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * io.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * io.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
        const exceptRooms = new Set(this.exceptRooms);
        if (Array.isArray(room)) {
            room.forEach((r) => exceptRooms.add(r));
        }
        else {
            exceptRooms.add(room);
        }
        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     */
    compress(compress) {
        const flags = Object.assign({}, this.flags, { compress });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return a new BroadcastOperator instance
     */
    get volatile() {
        const flags = Object.assign({}, this.flags, { volatile: true });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * // the foo event will be broadcast to all connected clients on this node
     * io.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
        const flags = Object.assign({}, this.flags, { local: true });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Adds a timeout in milliseconds for the next operation
     *
     * @example
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
        const flags = Object.assign({}, this.flags, { timeout });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Emits to all clients.
     *
     * @example
     * // the foo event will be broadcast to all connected clients
     * io.emit("foo", "bar");
     *
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an acknowledgement expected from all connected clients
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @return Always true
     */
    emit(ev, ...args) {
        if (socket_1.RESERVED_EVENTS.has(ev)) {
            throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        // set up packet object
        const data = [ev, ...args];
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: data,
        };
        const withAck = typeof data[data.length - 1] === "function";
        if (!withAck) {
            this.adapter.broadcast(packet, {
                rooms: this.rooms,
                except: this.exceptRooms,
                flags: this.flags,
            });
            return true;
        }
        const ack = data.pop();
        let timedOut = false;
        let responses = [];
        const timer = setTimeout(() => {
            timedOut = true;
            ack.apply(this, [
                new Error("operation has timed out"),
                this.flags.expectSingleResponse ? null : responses,
            ]);
        }, this.flags.timeout);
        let expectedServerCount = -1;
        let actualServerCount = 0;
        let expectedClientCount = 0;
        const checkCompleteness = () => {
            if (!timedOut &&
                expectedServerCount === actualServerCount &&
                responses.length === expectedClientCount) {
                clearTimeout(timer);
                ack.apply(this, [
                    null,
                    this.flags.expectSingleResponse ? responses[0] : responses,
                ]);
            }
        };
        this.adapter.broadcastWithAck(packet, {
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        }, (clientCount) => {
            // each Socket.IO server in the cluster sends the number of clients that were notified
            expectedClientCount += clientCount;
            actualServerCount++;
            checkCompleteness();
        }, (clientResponse) => {
            // each client sends an acknowledgement
            responses.push(clientResponse);
            checkCompleteness();
        });
        this.adapter.serverCount().then((serverCount) => {
            expectedServerCount = serverCount;
            checkCompleteness();
        });
        return true;
    }
    /**
     * Emits an event and waits for an acknowledgement from all clients.
     *
     * @example
     * try {
     *   const responses = await io.timeout(1000).emitWithAck("some-event");
     *   console.log(responses); // one response per client
     * } catch (e) {
     *   // some clients did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when all clients have acknowledged the event
     */
    emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            args.push((err, responses) => {
                if (err) {
                    err.responses = responses;
                    return reject(err);
                }
                else {
                    return resolve(responses);
                }
            });
            this.emit(ev, ...args);
        });
    }
    /**
     * Gets a list of clients.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
     * {@link fetchSockets} instead.
     */
    allSockets() {
        if (!this.adapter) {
            throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
        }
        return this.adapter.sockets(this.rooms);
    }
    /**
     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // return all Socket instances
     * const sockets = await io.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await io.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
        return this.adapter
            .fetchSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        })
            .then((sockets) => {
            return sockets.map((socket) => {
                if (socket instanceof socket_1.Socket) {
                    // FIXME the TypeScript compiler complains about missing private properties
                    return socket;
                }
                else {
                    return new RemoteSocket(this.adapter, socket);
                }
            });
        });
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     *
     * // make all socket instances join the "room1" room
     * io.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * io.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
        this.adapter.addSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances leave the "room1" room
     * io.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * io.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
        this.adapter.delSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * io.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * io.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
        this.adapter.disconnectSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        }, close);
    }
}
exports.BroadcastOperator = BroadcastOperator;
/**
 * Expose of subset of the attributes and methods of the Socket class
 */
class RemoteSocket {
    constructor(adapter, details) {
        this.id = details.id;
        this.handshake = details.handshake;
        this.rooms = new Set(details.rooms);
        this.data = details.data;
        this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {
            expectSingleResponse: true, // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()
        });
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * const sockets = await io.fetchSockets();
     *
     * for (const socket of sockets) {
     *   if (someCondition) {
     *     socket.timeout(1000).emit("some-event", (err) => {
     *       if (err) {
     *         // the client did not acknowledge the event in the given delay
     *       }
     *     });
     *   }
     * }
     *
     * // note: if possible, using a room instead of looping over all sockets is preferable
     * io.timeout(1000).to(someConditionRoom).emit("some-event", (err, responses) => {
     *   // ...
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
        return this.operator.timeout(timeout);
    }
    emit(ev, ...args) {
        return this.operator.emit(ev, ...args);
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} room - room or array of rooms
     */
    join(room) {
        return this.operator.socketsJoin(room);
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     */
    leave(room) {
        return this.operator.socketsLeave(room);
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     */
    disconnect(close = false) {
        this.operator.disconnectSockets(close);
        return this;
    }
}
exports.RemoteSocket = RemoteSocket;


/***/ }),

/***/ "../../node_modules/socket.io/dist/client.js":
/*!***************************************************!*\
  !*** ../../node_modules/socket.io/dist/client.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = void 0;
const socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "../../node_modules/socket.io-parser/build/cjs/index.js");
const debugModule = __webpack_require__(/*! debug */ "../../node_modules/socket.io/node_modules/debug/src/index.js");
const url = __webpack_require__(/*! url */ "url");
const debug = debugModule("socket.io:client");
class Client {
    /**
     * Client constructor.
     *
     * @param server instance
     * @param conn
     * @package
     */
    constructor(server, conn) {
        this.sockets = new Map();
        this.nsps = new Map();
        this.server = server;
        this.conn = conn;
        this.encoder = server.encoder;
        this.decoder = new server._parser.Decoder();
        this.id = conn.id;
        this.setup();
    }
    /**
     * @return the reference to the request that originated the Engine.IO connection
     *
     * @public
     */
    get request() {
        return this.conn.request;
    }
    /**
     * Sets up event listeners.
     *
     * @private
     */
    setup() {
        this.onclose = this.onclose.bind(this);
        this.ondata = this.ondata.bind(this);
        this.onerror = this.onerror.bind(this);
        this.ondecoded = this.ondecoded.bind(this);
        // @ts-ignore
        this.decoder.on("decoded", this.ondecoded);
        this.conn.on("data", this.ondata);
        this.conn.on("error", this.onerror);
        this.conn.on("close", this.onclose);
        this.connectTimeout = setTimeout(() => {
            if (this.nsps.size === 0) {
                debug("no namespace joined yet, close the client");
                this.close();
            }
            else {
                debug("the client has already joined a namespace, nothing to do");
            }
        }, this.server._connectTimeout);
    }
    /**
     * Connects a client to a namespace.
     *
     * @param {String} name - the namespace
     * @param {Object} auth - the auth parameters
     * @private
     */
    connect(name, auth = {}) {
        if (this.server._nsps.has(name)) {
            debug("connecting to namespace %s", name);
            return this.doConnect(name, auth);
        }
        this.server._checkNamespace(name, auth, (dynamicNspName) => {
            if (dynamicNspName) {
                this.doConnect(name, auth);
            }
            else {
                debug("creation of namespace %s was denied", name);
                this._packet({
                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,
                    nsp: name,
                    data: {
                        message: "Invalid namespace",
                    },
                });
            }
        });
    }
    /**
     * Connects a client to a namespace.
     *
     * @param name - the namespace
     * @param {Object} auth - the auth parameters
     *
     * @private
     */
    doConnect(name, auth) {
        const nsp = this.server.of(name);
        nsp._add(this, auth, (socket) => {
            this.sockets.set(socket.id, socket);
            this.nsps.set(nsp.name, socket);
            if (this.connectTimeout) {
                clearTimeout(this.connectTimeout);
                this.connectTimeout = undefined;
            }
        });
    }
    /**
     * Disconnects from all namespaces and closes transport.
     *
     * @private
     */
    _disconnect() {
        for (const socket of this.sockets.values()) {
            socket.disconnect();
        }
        this.sockets.clear();
        this.close();
    }
    /**
     * Removes a socket. Called by each `Socket`.
     *
     * @private
     */
    _remove(socket) {
        if (this.sockets.has(socket.id)) {
            const nsp = this.sockets.get(socket.id).nsp.name;
            this.sockets.delete(socket.id);
            this.nsps.delete(nsp);
        }
        else {
            debug("ignoring remove for %s", socket.id);
        }
    }
    /**
     * Closes the underlying connection.
     *
     * @private
     */
    close() {
        if ("open" === this.conn.readyState) {
            debug("forcing transport close");
            this.conn.close();
            this.onclose("forced server close");
        }
    }
    /**
     * Writes a packet to the transport.
     *
     * @param {Object} packet object
     * @param {Object} opts
     * @private
     */
    _packet(packet, opts = {}) {
        if (this.conn.readyState !== "open") {
            debug("ignoring packet write %j", packet);
            return;
        }
        const encodedPackets = opts.preEncoded
            ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()
            : this.encoder.encode(packet);
        this.writeToEngine(encodedPackets, opts);
    }
    writeToEngine(encodedPackets, opts) {
        if (opts.volatile && !this.conn.transport.writable) {
            debug("volatile packet is discarded since the transport is not currently writable");
            return;
        }
        const packets = Array.isArray(encodedPackets)
            ? encodedPackets
            : [encodedPackets];
        for (const encodedPacket of packets) {
            this.conn.write(encodedPacket, opts);
        }
    }
    /**
     * Called with incoming transport data.
     *
     * @private
     */
    ondata(data) {
        // try/catch is needed for protocol violations (GH-1880)
        try {
            this.decoder.add(data);
        }
        catch (e) {
            debug("invalid packet format");
            this.onerror(e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        let namespace;
        let authPayload;
        if (this.conn.protocol === 3) {
            const parsed = url.parse(packet.nsp, true);
            namespace = parsed.pathname;
            authPayload = parsed.query;
        }
        else {
            namespace = packet.nsp;
            authPayload = packet.data;
        }
        const socket = this.nsps.get(namespace);
        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {
            this.connect(namespace, authPayload);
        }
        else if (socket &&
            packet.type !== socket_io_parser_1.PacketType.CONNECT &&
            packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {
            process.nextTick(function () {
                socket._onpacket(packet);
            });
        }
        else {
            debug("invalid state (packet type: %s)", packet.type);
            this.close();
        }
    }
    /**
     * Handles an error.
     *
     * @param {Object} err object
     * @private
     */
    onerror(err) {
        for (const socket of this.sockets.values()) {
            socket._onerror(err);
        }
        this.conn.close();
    }
    /**
     * Called upon transport close.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        debug("client close with reason %s", reason);
        // ignore a potential subsequent `close` event
        this.destroy();
        // `nsps` and `sockets` are cleaned up seamlessly
        for (const socket of this.sockets.values()) {
            socket._onclose(reason, description);
        }
        this.sockets.clear();
        this.decoder.destroy(); // clean up decoder
    }
    /**
     * Cleans up event listeners.
     * @private
     */
    destroy() {
        this.conn.removeListener("data", this.ondata);
        this.conn.removeListener("error", this.onerror);
        this.conn.removeListener("close", this.onclose);
        // @ts-ignore
        this.decoder.removeListener("decoded", this.ondecoded);
        if (this.connectTimeout) {
            clearTimeout(this.connectTimeout);
            this.connectTimeout = undefined;
        }
    }
}
exports.Client = Client;


/***/ }),

/***/ "../../node_modules/socket.io/dist/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/socket.io/dist/index.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Namespace = exports.Socket = exports.Server = void 0;
const http = __webpack_require__(/*! http */ "http");
const fs_1 = __webpack_require__(/*! fs */ "fs");
const zlib_1 = __webpack_require__(/*! zlib */ "zlib");
const accepts = __webpack_require__(/*! accepts */ "../../node_modules/accepts/index.js");
const stream_1 = __webpack_require__(/*! stream */ "stream");
const path = __webpack_require__(/*! path */ "path");
const engine_io_1 = __webpack_require__(/*! engine.io */ "../../node_modules/engine.io/build/engine.io.js");
const client_1 = __webpack_require__(/*! ./client */ "../../node_modules/socket.io/dist/client.js");
const events_1 = __webpack_require__(/*! events */ "events");
const namespace_1 = __webpack_require__(/*! ./namespace */ "../../node_modules/socket.io/dist/namespace.js");
Object.defineProperty(exports, "Namespace", ({ enumerable: true, get: function () { return namespace_1.Namespace; } }));
const parent_namespace_1 = __webpack_require__(/*! ./parent-namespace */ "../../node_modules/socket.io/dist/parent-namespace.js");
const socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ "../../node_modules/socket.io-adapter/dist/index.js");
const parser = __importStar(__webpack_require__(/*! socket.io-parser */ "../../node_modules/socket.io-parser/build/cjs/index.js"));
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "../../node_modules/socket.io/node_modules/debug/src/index.js"));
const socket_1 = __webpack_require__(/*! ./socket */ "../../node_modules/socket.io/dist/socket.js");
Object.defineProperty(exports, "Socket", ({ enumerable: true, get: function () { return socket_1.Socket; } }));
const typed_events_1 = __webpack_require__(/*! ./typed-events */ "../../node_modules/socket.io/dist/typed-events.js");
const uws_1 = __webpack_require__(/*! ./uws */ "../../node_modules/socket.io/dist/uws.js");
const cors_1 = __importDefault(__webpack_require__(/*! cors */ "../../node_modules/cors/lib/index.js"));
const debug = (0, debug_1.default)("socket.io:server");
const clientVersion = (__webpack_require__(/*! ../package.json */ "../../node_modules/socket.io/package.json").version);
const dotMapRegex = /\.map/;
/**
 * Represents a Socket.IO server.
 *
 * @example
 * import { Server } from "socket.io";
 *
 * const io = new Server();
 *
 * io.on("connection", (socket) => {
 *   console.log(`socket ${socket.id} connected`);
 *
 *   // send an event to the client
 *   socket.emit("foo", "bar");
 *
 *   socket.on("foobar", () => {
 *     // an event was received from the client
 *   });
 *
 *   // upon disconnection
 *   socket.on("disconnect", (reason) => {
 *     console.log(`socket ${socket.id} disconnected due to ${reason}`);
 *   });
 * });
 *
 * io.listen(3000);
 */
class Server extends typed_events_1.StrictEventEmitter {
    constructor(srv, opts = {}) {
        super();
        /**
         * @private
         */
        this._nsps = new Map();
        this.parentNsps = new Map();
        /**
         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular
         * expression.
         *
         * @private
         */
        this.parentNamespacesFromRegExp = new Map();
        if ("object" === typeof srv &&
            srv instanceof Object &&
            !srv.listen) {
            opts = srv;
            srv = undefined;
        }
        this.path(opts.path || "/socket.io");
        this.connectTimeout(opts.connectTimeout || 45000);
        this.serveClient(false !== opts.serveClient);
        this._parser = opts.parser || parser;
        this.encoder = new this._parser.Encoder();
        this.opts = opts;
        if (opts.connectionStateRecovery) {
            opts.connectionStateRecovery = Object.assign({
                maxDisconnectionDuration: 2 * 60 * 1000,
                skipMiddlewares: true,
            }, opts.connectionStateRecovery);
            this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
        }
        else {
            this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
        }
        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
        this.sockets = this.of("/");
        if (srv || typeof srv == "number")
            this.attach(srv);
        if (this.opts.cors) {
            this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
        }
    }
    get _opts() {
        return this.opts;
    }
    serveClient(v) {
        if (!arguments.length)
            return this._serveClient;
        this._serveClient = v;
        return this;
    }
    /**
     * Executes the middleware for an incoming namespace not already created on the server.
     *
     * @param name - name of incoming namespace
     * @param auth - the auth parameters
     * @param fn - callback
     *
     * @private
     */
    _checkNamespace(name, auth, fn) {
        if (this.parentNsps.size === 0)
            return fn(false);
        const keysIterator = this.parentNsps.keys();
        const run = () => {
            const nextFn = keysIterator.next();
            if (nextFn.done) {
                return fn(false);
            }
            nextFn.value(name, auth, (err, allow) => {
                if (err || !allow) {
                    return run();
                }
                if (this._nsps.has(name)) {
                    // the namespace was created in the meantime
                    debug("dynamic namespace %s already exists", name);
                    return fn(this._nsps.get(name));
                }
                const namespace = this.parentNsps.get(nextFn.value).createChild(name);
                debug("dynamic namespace %s was created", name);
                fn(namespace);
            });
        };
        run();
    }
    path(v) {
        if (!arguments.length)
            return this._path;
        this._path = v.replace(/\/$/, "");
        const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        this.clientPathRegex = new RegExp("^" +
            escapedPath +
            "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
        return this;
    }
    connectTimeout(v) {
        if (v === undefined)
            return this._connectTimeout;
        this._connectTimeout = v;
        return this;
    }
    adapter(v) {
        if (!arguments.length)
            return this._adapter;
        this._adapter = v;
        for (const nsp of this._nsps.values()) {
            nsp._initAdapter();
        }
        return this;
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     */
    listen(srv, opts = {}) {
        return this.attach(srv, opts);
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     */
    attach(srv, opts = {}) {
        if ("function" == typeof srv) {
            const msg = "You are trying to attach socket.io to an express " +
                "request handler function. Please pass a http.Server instance.";
            throw new Error(msg);
        }
        // handle a port as a string
        if (Number(srv) == srv) {
            srv = Number(srv);
        }
        if ("number" == typeof srv) {
            debug("creating http server and binding to %d", srv);
            const port = srv;
            srv = http.createServer((req, res) => {
                res.writeHead(404);
                res.end();
            });
            srv.listen(port);
        }
        // merge the options passed to the Socket.IO server
        Object.assign(opts, this.opts);
        // set engine.io path to `/socket.io`
        opts.path = opts.path || this._path;
        this.initEngine(srv, opts);
        return this;
    }
    attachApp(app /*: TemplatedApp */, opts = {}) {
        // merge the options passed to the Socket.IO server
        Object.assign(opts, this.opts);
        // set engine.io path to `/socket.io`
        opts.path = opts.path || this._path;
        // initialize engine
        debug("creating uWebSockets.js-based engine with opts %j", opts);
        const engine = new engine_io_1.uServer(opts);
        engine.attach(app, opts);
        // bind to engine events
        this.bind(engine);
        if (this._serveClient) {
            // attach static file serving
            app.get(`${this._path}/*`, (res, req) => {
                if (!this.clientPathRegex.test(req.getUrl())) {
                    req.setYield(true);
                    return;
                }
                const filename = req
                    .getUrl()
                    .replace(this._path, "")
                    .replace(/\?.*$/, "")
                    .replace(/^\//, "");
                const isMap = dotMapRegex.test(filename);
                const type = isMap ? "map" : "source";
                // Per the standard, ETags must be quoted:
                // https://tools.ietf.org/html/rfc7232#section-2.3
                const expectedEtag = '"' + clientVersion + '"';
                const weakEtag = "W/" + expectedEtag;
                const etag = req.getHeader("if-none-match");
                if (etag) {
                    if (expectedEtag === etag || weakEtag === etag) {
                        debug("serve client %s 304", type);
                        res.writeStatus("304 Not Modified");
                        res.end();
                        return;
                    }
                }
                debug("serve client %s", type);
                res.writeHeader("cache-control", "public, max-age=0");
                res.writeHeader("content-type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
                res.writeHeader("etag", expectedEtag);
                const filepath = path.join(__dirname, "../client-dist/", filename);
                (0, uws_1.serveFile)(res, filepath);
            });
        }
        (0, uws_1.patchAdapter)(app);
    }
    /**
     * Initialize engine
     *
     * @param srv - the server to attach to
     * @param opts - options passed to engine.io
     * @private
     */
    initEngine(srv, opts) {
        // initialize engine
        debug("creating engine.io instance with opts %j", opts);
        this.eio = (0, engine_io_1.attach)(srv, opts);
        // attach static file serving
        if (this._serveClient)
            this.attachServe(srv);
        // Export http server
        this.httpServer = srv;
        // bind to engine events
        this.bind(this.eio);
    }
    /**
     * Attaches the static file serving.
     *
     * @param srv http server
     * @private
     */
    attachServe(srv) {
        debug("attaching client serving req handler");
        const evs = srv.listeners("request").slice(0);
        srv.removeAllListeners("request");
        srv.on("request", (req, res) => {
            if (this.clientPathRegex.test(req.url)) {
                if (this._corsMiddleware) {
                    this._corsMiddleware(req, res, () => {
                        this.serve(req, res);
                    });
                }
                else {
                    this.serve(req, res);
                }
            }
            else {
                for (let i = 0; i < evs.length; i++) {
                    evs[i].call(srv, req, res);
                }
            }
        });
    }
    /**
     * Handles a request serving of client source and map
     *
     * @param req
     * @param res
     * @private
     */
    serve(req, res) {
        const filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
        const isMap = dotMapRegex.test(filename);
        const type = isMap ? "map" : "source";
        // Per the standard, ETags must be quoted:
        // https://tools.ietf.org/html/rfc7232#section-2.3
        const expectedEtag = '"' + clientVersion + '"';
        const weakEtag = "W/" + expectedEtag;
        const etag = req.headers["if-none-match"];
        if (etag) {
            if (expectedEtag === etag || weakEtag === etag) {
                debug("serve client %s 304", type);
                res.writeHead(304);
                res.end();
                return;
            }
        }
        debug("serve client %s", type);
        res.setHeader("Cache-Control", "public, max-age=0");
        res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
        res.setHeader("ETag", expectedEtag);
        Server.sendFile(filename, req, res);
    }
    /**
     * @param filename
     * @param req
     * @param res
     * @private
     */
    static sendFile(filename, req, res) {
        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, "../client-dist/", filename));
        const encoding = accepts(req).encodings(["br", "gzip", "deflate"]);
        const onError = (err) => {
            if (err) {
                res.end();
            }
        };
        switch (encoding) {
            case "br":
                res.writeHead(200, { "content-encoding": "br" });
                readStream.pipe((0, zlib_1.createBrotliCompress)()).pipe(res);
                (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
                break;
            case "gzip":
                res.writeHead(200, { "content-encoding": "gzip" });
                (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
                break;
            case "deflate":
                res.writeHead(200, { "content-encoding": "deflate" });
                (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
                break;
            default:
                res.writeHead(200);
                (0, stream_1.pipeline)(readStream, res, onError);
        }
    }
    /**
     * Binds socket.io to an engine.io instance.
     *
     * @param engine engine.io (or compatible) server
     * @return self
     */
    bind(engine) {
        this.engine = engine;
        this.engine.on("connection", this.onconnection.bind(this));
        return this;
    }
    /**
     * Called with each incoming transport connection.
     *
     * @param {engine.Socket} conn
     * @return self
     * @private
     */
    onconnection(conn) {
        debug("incoming connection with id %s", conn.id);
        const client = new client_1.Client(this, conn);
        if (conn.protocol === 3) {
            // @ts-ignore
            client.connect("/");
        }
        return this;
    }
    /**
     * Looks up a namespace.
     *
     * @example
     * // with a simple string
     * const myNamespace = io.of("/my-namespace");
     *
     * // with a regex
     * const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
     *   const namespace = socket.nsp; // newNamespace.name === "/dynamic-101"
     *
     *   // broadcast to all clients in the given sub-namespace
     *   namespace.emit("hello");
     * });
     *
     * @param name - nsp name
     * @param fn optional, nsp `connection` ev handler
     */
    of(name, fn) {
        if (typeof name === "function" || name instanceof RegExp) {
            const parentNsp = new parent_namespace_1.ParentNamespace(this);
            debug("initializing parent namespace %s", parentNsp.name);
            if (typeof name === "function") {
                this.parentNsps.set(name, parentNsp);
            }
            else {
                this.parentNsps.set((nsp, conn, next) => next(null, name.test(nsp)), parentNsp);
                this.parentNamespacesFromRegExp.set(name, parentNsp);
            }
            if (fn) {
                // @ts-ignore
                parentNsp.on("connect", fn);
            }
            return parentNsp;
        }
        if (String(name)[0] !== "/")
            name = "/" + name;
        let nsp = this._nsps.get(name);
        if (!nsp) {
            for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp) {
                if (regex.test(name)) {
                    debug("attaching namespace %s to parent namespace %s", name, regex);
                    return parentNamespace.createChild(name);
                }
            }
            debug("initializing namespace %s", name);
            nsp = new namespace_1.Namespace(this, name);
            this._nsps.set(name, nsp);
            if (name !== "/") {
                // @ts-ignore
                this.sockets.emitReserved("new_namespace", nsp);
            }
        }
        if (fn)
            nsp.on("connect", fn);
        return nsp;
    }
    /**
     * Closes server connection
     *
     * @param [fn] optional, called as `fn([err])` on error OR all conns closed
     */
    close(fn) {
        for (const socket of this.sockets.sockets.values()) {
            socket._onclose("server shutting down");
        }
        this.engine.close();
        // restore the Adapter prototype
        (0, uws_1.restoreAdapter)();
        if (this.httpServer) {
            this.httpServer.close(fn);
        }
        else {
            fn && fn();
        }
    }
    /**
     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
     *
     * @example
     * io.use((socket, next) => {
     *   // ...
     *   next();
     * });
     *
     * @param fn - the middleware function
     */
    use(fn) {
        this.sockets.use(fn);
        return this;
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * io.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
        return this.sockets.to(room);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * // disconnect all clients in the "room-101" room
     * io.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
        return this.sockets.in(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * io.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * io.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
        return this.sockets.except(room);
    }
    /**
     * Sends a `message` event to all clients.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * io.send("hello");
     *
     * // this is equivalent to
     * io.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.sockets.emit("message", ...args);
        return this;
    }
    /**
     * Sends a `message` event to all clients. Alias of {@link send}.
     *
     * @return self
     */
    write(...args) {
        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.sockets.emit("message", ...args);
        return this;
    }
    /**
     * Sends a message to the other Socket.IO servers of the cluster.
     *
     * @example
     * io.serverSideEmit("hello", "world");
     *
     * io.on("hello", (arg1) => {
     *   console.log(arg1); // prints "world"
     * });
     *
     * // acknowledgements (without binary content) are supported too:
     * io.serverSideEmit("ping", (err, responses) => {
     *  if (err) {
     *     // some servers did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per server (except the current one)
     *   }
     * });
     *
     * io.on("ping", (cb) => {
     *   cb("pong");
     * });
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(ev, ...args) {
        return this.sockets.serverSideEmit(ev, ...args);
    }
    /**
     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
     *
     * @example
     * try {
     *   const responses = await io.serverSideEmitWithAck("ping");
     *   console.log(responses); // one response per server (except the current one)
     * } catch (e) {
     *   // some servers did not acknowledge the event in the given delay
     * }
     *
     * @param ev - the event name
     * @param args - an array of arguments
     *
     * @return a Promise that will be fulfilled when all servers have acknowledged the event
     */
    serverSideEmitWithAck(ev, ...args) {
        return this.sockets.serverSideEmitWithAck(ev, ...args);
    }
    /**
     * Gets a list of socket ids.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
     * {@link Server#fetchSockets} instead.
     */
    allSockets() {
        return this.sockets.allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    compress(compress) {
        return this.sockets.compress(compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get volatile() {
        return this.sockets.volatile;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * // the foo event will be broadcast to all connected clients on this node
     * io.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
        return this.sockets.local;
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
        return this.sockets.timeout(timeout);
    }
    /**
     * Returns the matching socket instances.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // return all Socket instances
     * const sockets = await io.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await io.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
        return this.sockets.fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     *
     * // make all socket instances join the "room1" room
     * io.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * io.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
        return this.sockets.socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances leave the "room1" room
     * io.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * io.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
        return this.sockets.socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * io.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * io.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
        return this.sockets.disconnectSockets(close);
    }
}
exports.Server = Server;
/**
 * Expose main namespace (/).
 */
const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {
    return typeof events_1.EventEmitter.prototype[key] === "function";
});
emitterMethods.forEach(function (fn) {
    Server.prototype[fn] = function () {
        return this.sockets[fn].apply(this.sockets, arguments);
    };
});
module.exports = (srv, opts) => new Server(srv, opts);
module.exports.Server = Server;
module.exports.Namespace = namespace_1.Namespace;
module.exports.Socket = socket_1.Socket;
var socket_2 = __webpack_require__(/*! ./socket */ "../../node_modules/socket.io/dist/socket.js");


/***/ }),

/***/ "../../node_modules/socket.io/dist/namespace.js":
/*!******************************************************!*\
  !*** ../../node_modules/socket.io/dist/namespace.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Namespace = exports.RESERVED_EVENTS = void 0;
const socket_1 = __webpack_require__(/*! ./socket */ "../../node_modules/socket.io/dist/socket.js");
const typed_events_1 = __webpack_require__(/*! ./typed-events */ "../../node_modules/socket.io/dist/typed-events.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "../../node_modules/socket.io/node_modules/debug/src/index.js"));
const broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ "../../node_modules/socket.io/dist/broadcast-operator.js");
const debug = (0, debug_1.default)("socket.io:namespace");
exports.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);
/**
 * A Namespace is a communication channel that allows you to split the logic of your application over a single shared
 * connection.
 *
 * Each namespace has its own:
 *
 * - event handlers
 *
 * ```
 * io.of("/orders").on("connection", (socket) => {
 *   socket.on("order:list", () => {});
 *   socket.on("order:create", () => {});
 * });
 *
 * io.of("/users").on("connection", (socket) => {
 *   socket.on("user:list", () => {});
 * });
 * ```
 *
 * - rooms
 *
 * ```
 * const orderNamespace = io.of("/orders");
 *
 * orderNamespace.on("connection", (socket) => {
 *   socket.join("room1");
 *   orderNamespace.to("room1").emit("hello");
 * });
 *
 * const userNamespace = io.of("/users");
 *
 * userNamespace.on("connection", (socket) => {
 *   socket.join("room1"); // distinct from the room in the "orders" namespace
 *   userNamespace.to("room1").emit("hol");
 * });
 * ```
 *
 * - middlewares
 *
 * ```
 * const orderNamespace = io.of("/orders");
 *
 * orderNamespace.use((socket, next) => {
 *   // ensure the socket has access to the "orders" namespace
 * });
 *
 * const userNamespace = io.of("/users");
 *
 * userNamespace.use((socket, next) => {
 *   // ensure the socket has access to the "users" namespace
 * });
 * ```
 */
class Namespace extends typed_events_1.StrictEventEmitter {
    /**
     * Namespace constructor.
     *
     * @param server instance
     * @param name
     */
    constructor(server, name) {
        super();
        this.sockets = new Map();
        /** @private */
        this._fns = [];
        /** @private */
        this._ids = 0;
        this.server = server;
        this.name = name;
        this._initAdapter();
    }
    /**
     * Initializes the `Adapter` for this nsp.
     * Run upon changing adapter by `Server#adapter`
     * in addition to the constructor.
     *
     * @private
     */
    _initAdapter() {
        // @ts-ignore
        this.adapter = new (this.server.adapter())(this);
    }
    /**
     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.use((socket, next) => {
     *   // ...
     *   next();
     * });
     *
     * @param fn - the middleware function
     */
    use(fn) {
        this._fns.push(fn);
        return this;
    }
    /**
     * Executes the middleware for an incoming client.
     *
     * @param socket - the socket that will get added
     * @param fn - last fn call in the middleware
     * @private
     */
    run(socket, fn) {
        const fns = this._fns.slice(0);
        if (!fns.length)
            return fn(null);
        function run(i) {
            fns[i](socket, function (err) {
                // upon error, short-circuit
                if (err)
                    return fn(err);
                // if no middleware left, summon callback
                if (!fns[i + 1])
                    return fn(null);
                // go on to next
                run(i + 1);
            });
        }
        run(0);
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * myNamespace.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * myNamespace.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * myNamespace.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // disconnect all clients in the "room-101" room
     * myNamespace.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * myNamespace.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * myNamespace.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * myNamespace.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    /**
     * Adds a new client.
     *
     * @return {Socket}
     * @private
     */
    async _add(client, auth, fn) {
        var _a;
        debug("adding socket to nsp %s", this.name);
        const socket = await this._createSocket(client, auth);
        if (
        // @ts-ignore
        ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) &&
            socket.recovered &&
            client.conn.readyState === "open") {
            return this._doConnect(socket, fn);
        }
        this.run(socket, (err) => {
            process.nextTick(() => {
                if ("open" !== client.conn.readyState) {
                    debug("next called after client was closed - ignoring socket");
                    socket._cleanup();
                    return;
                }
                if (err) {
                    debug("middleware error, sending CONNECT_ERROR packet to the client");
                    socket._cleanup();
                    if (client.conn.protocol === 3) {
                        return socket._error(err.data || err.message);
                    }
                    else {
                        return socket._error({
                            message: err.message,
                            data: err.data,
                        });
                    }
                }
                this._doConnect(socket, fn);
            });
        });
    }
    async _createSocket(client, auth) {
        const sessionId = auth.pid;
        const offset = auth.offset;
        if (
        // @ts-ignore
        this.server.opts.connectionStateRecovery &&
            typeof sessionId === "string" &&
            typeof offset === "string") {
            let session;
            try {
                session = await this.adapter.restoreSession(sessionId, offset);
            }
            catch (e) {
                debug("error while restoring session: %s", e);
            }
            if (session) {
                debug("connection state recovered for sid %s", session.sid);
                return new socket_1.Socket(this, client, auth, session);
            }
        }
        return new socket_1.Socket(this, client, auth);
    }
    _doConnect(socket, fn) {
        // track socket
        this.sockets.set(socket.id, socket);
        // it's paramount that the internal `onconnect` logic
        // fires before user-set events to prevent state order
        // violations (such as a disconnection before the connection
        // logic is complete)
        socket._onconnect();
        if (fn)
            fn(socket);
        // fire user-set events
        this.emitReserved("connect", socket);
        this.emitReserved("connection", socket);
    }
    /**
     * Removes a client. Called by each `Socket`.
     *
     * @private
     */
    _remove(socket) {
        if (this.sockets.has(socket.id)) {
            this.sockets.delete(socket.id);
        }
        else {
            debug("ignoring remove for %s", socket.id);
        }
    }
    /**
     * Emits to all connected clients.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * myNamespace.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the clients
     * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @return Always true
     */
    emit(ev, ...args) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
    }
    /**
     * Sends a `message` event to all clients.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.send("hello");
     *
     * // this is equivalent to
     * myNamespace.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.emit("message", ...args);
        return this;
    }
    /**
     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.
     *
     * @return self
     */
    write(...args) {
        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.emit("message", ...args);
        return this;
    }
    /**
     * Sends a message to the other Socket.IO servers of the cluster.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.serverSideEmit("hello", "world");
     *
     * myNamespace.on("hello", (arg1) => {
     *   console.log(arg1); // prints "world"
     * });
     *
     * // acknowledgements (without binary content) are supported too:
     * myNamespace.serverSideEmit("ping", (err, responses) => {
     *  if (err) {
     *     // some servers did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per server (except the current one)
     *   }
     * });
     *
     * myNamespace.on("ping", (cb) => {
     *   cb("pong");
     * });
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(ev, ...args) {
        if (exports.RESERVED_EVENTS.has(ev)) {
            throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        args.unshift(ev);
        this.adapter.serverSideEmit(args);
        return true;
    }
    /**
     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * try {
     *   const responses = await myNamespace.serverSideEmitWithAck("ping");
     *   console.log(responses); // one response per server (except the current one)
     * } catch (e) {
     *   // some servers did not acknowledge the event in the given delay
     * }
     *
     * @param ev - the event name
     * @param args - an array of arguments
     *
     * @return a Promise that will be fulfilled when all servers have acknowledged the event
     */
    serverSideEmitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            args.push((err, responses) => {
                if (err) {
                    err.responses = responses;
                    return reject(err);
                }
                else {
                    return resolve(responses);
                }
            });
            this.serverSideEmit(ev, ...args);
        });
    }
    /**
     * Called when a packet is received from another Socket.IO server
     *
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     *
     * @private
     */
    _onServerSideEmit(args) {
        super.emitUntyped.apply(this, args);
    }
    /**
     * Gets a list of clients.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or
     * {@link Namespace#fetchSockets} instead.
     */
    allSockets() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return self
     */
    get volatile() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the foo event will be broadcast to all connected clients on this node
     * myNamespace.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
    }
    /**
     * Returns the matching socket instances.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // return all Socket instances
     * const sockets = await myNamespace.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await myNamespace.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances join the "room1" room
     * myNamespace.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * myNamespace.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances leave the "room1" room
     * myNamespace.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * myNamespace.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * myNamespace.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * myNamespace.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
}
exports.Namespace = Namespace;


/***/ }),

/***/ "../../node_modules/socket.io/dist/parent-namespace.js":
/*!*************************************************************!*\
  !*** ../../node_modules/socket.io/dist/parent-namespace.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParentNamespace = void 0;
const namespace_1 = __webpack_require__(/*! ./namespace */ "../../node_modules/socket.io/dist/namespace.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "../../node_modules/socket.io/node_modules/debug/src/index.js"));
const debug = (0, debug_1.default)("socket.io:parent-namespace");
/**
 * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either
 * with a regular expression or with a function.
 *
 * @example
 * const parentNamespace = io.of(/\/dynamic-\d+/);
 *
 * parentNamespace.on("connection", (socket) => {
 *   const childNamespace = socket.nsp;
 * }
 *
 * // will reach all the clients that are in one of the child namespaces, like "/dynamic-101"
 * parentNamespace.emit("hello", "world");
 *
 */
class ParentNamespace extends namespace_1.Namespace {
    constructor(server) {
        super(server, "/_" + ParentNamespace.count++);
        this.children = new Set();
    }
    /**
     * @private
     */
    _initAdapter() {
        const broadcast = (packet, opts) => {
            this.children.forEach((nsp) => {
                nsp.adapter.broadcast(packet, opts);
            });
        };
        // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?
        this.adapter = { broadcast };
    }
    emit(ev, ...args) {
        this.children.forEach((nsp) => {
            nsp.emit(ev, ...args);
        });
        return true;
    }
    createChild(name) {
        debug("creating child namespace %s", name);
        const namespace = new namespace_1.Namespace(this.server, name);
        namespace._fns = this._fns.slice(0);
        this.listeners("connect").forEach((listener) => namespace.on("connect", listener));
        this.listeners("connection").forEach((listener) => namespace.on("connection", listener));
        this.children.add(namespace);
        if (this.server._opts.cleanupEmptyChildNamespaces) {
            const remove = namespace._remove;
            namespace._remove = (socket) => {
                remove.call(namespace, socket);
                if (namespace.sockets.size === 0) {
                    debug("closing child namespace %s", name);
                    namespace.adapter.close();
                    this.server._nsps.delete(namespace.name);
                    this.children.delete(namespace);
                }
            };
        }
        this.server._nsps.set(name, namespace);
        // @ts-ignore
        this.server.sockets.emitReserved("new_namespace", namespace);
        return namespace;
    }
    fetchSockets() {
        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the
        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but
        // the behavior for namespaces created with a function is less clear
        // note: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace
        // may exist on one node but not exist on another (since it is created upon client connection)
        throw new Error("fetchSockets() is not supported on parent namespaces");
    }
}
exports.ParentNamespace = ParentNamespace;
ParentNamespace.count = 0;


/***/ }),

/***/ "../../node_modules/socket.io/dist/socket.js":
/*!***************************************************!*\
  !*** ../../node_modules/socket.io/dist/socket.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Socket = exports.RESERVED_EVENTS = void 0;
const socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "../../node_modules/socket.io-parser/build/cjs/index.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "../../node_modules/socket.io/node_modules/debug/src/index.js"));
const typed_events_1 = __webpack_require__(/*! ./typed-events */ "../../node_modules/socket.io/dist/typed-events.js");
const base64id_1 = __importDefault(__webpack_require__(/*! base64id */ "../../node_modules/base64id/lib/base64id.js"));
const broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ "../../node_modules/socket.io/dist/broadcast-operator.js");
const debug = (0, debug_1.default)("socket.io:socket");
const RECOVERABLE_DISCONNECT_REASONS = new Set([
    "transport error",
    "transport close",
    "forced close",
    "ping timeout",
    "server shutting down",
    "forced server close",
]);
exports.RESERVED_EVENTS = new Set([
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener",
]);
function noop() { }
/**
 * This is the main object for interacting with a client.
 *
 * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.
 *
 * Within each {@link Namespace}, you can also define arbitrary channels (called "rooms") that the {@link Socket} can
 * join and leave. That provides a convenient way to broadcast to a group of socket instances.
 *
 * @example
 * io.on("connection", (socket) => {
 *   console.log(`socket ${socket.id} connected`);
 *
 *   // send an event to the client
 *   socket.emit("foo", "bar");
 *
 *   socket.on("foobar", () => {
 *     // an event was received from the client
 *   });
 *
 *   // join the room named "room1"
 *   socket.join("room1");
 *
 *   // broadcast to everyone in the room named "room1"
 *   io.to("room1").emit("hello");
 *
 *   // upon disconnection
 *   socket.on("disconnect", (reason) => {
 *     console.log(`socket ${socket.id} disconnected due to ${reason}`);
 *   });
 * });
 */
class Socket extends typed_events_1.StrictEventEmitter {
    /**
     * Interface to a `Client` for a given `Namespace`.
     *
     * @param {Namespace} nsp
     * @param {Client} client
     * @param {Object} auth
     * @package
     */
    constructor(nsp, client, auth, previousSession) {
        super();
        this.nsp = nsp;
        this.client = client;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted to the client, the data attribute and the rooms will be restored.
         */
        this.recovered = false;
        /**
         * Additional information that can be attached to the Socket instance and which will be used in the
         * {@link Server.fetchSockets()} method.
         */
        this.data = {};
        /**
         * Whether the socket is currently connected or not.
         *
         * @example
         * io.use((socket, next) => {
         *   console.log(socket.connected); // false
         *   next();
         * });
         *
         * io.on("connection", (socket) => {
         *   console.log(socket.connected); // true
         * });
         */
        this.connected = false;
        this.acks = new Map();
        this.fns = [];
        this.flags = {};
        this.server = nsp.server;
        this.adapter = this.nsp.adapter;
        if (previousSession) {
            this.id = previousSession.sid;
            this.pid = previousSession.pid;
            previousSession.rooms.forEach((room) => this.join(room));
            this.data = previousSession.data;
            previousSession.missedPackets.forEach((packet) => {
                this.packet({
                    type: socket_io_parser_1.PacketType.EVENT,
                    data: packet,
                });
            });
            this.recovered = true;
        }
        else {
            if (client.conn.protocol === 3) {
                // @ts-ignore
                this.id = nsp.name !== "/" ? nsp.name + "#" + client.id : client.id;
            }
            else {
                this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information
            }
            if (this.server._opts.connectionStateRecovery) {
                this.pid = base64id_1.default.generateId();
            }
        }
        this.handshake = this.buildHandshake(auth);
        // prevents crash when the socket receives an "error" event without listener
        this.on("error", noop);
    }
    /**
     * Builds the `handshake` BC object
     *
     * @private
     */
    buildHandshake(auth) {
        var _a, _b, _c, _d;
        return {
            headers: ((_a = this.request) === null || _a === void 0 ? void 0 : _a.headers) || {},
            time: new Date() + "",
            address: this.conn.remoteAddress,
            xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),
            // @ts-ignore
            secure: !this.request || !!this.request.connection.encrypted,
            issued: +new Date(),
            url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,
            // @ts-ignore
            query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},
            auth,
        };
    }
    /**
     * Emits to this client.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.emit("hello", "world");
     *
     *   // all serializable datastructures are supported (no need to call JSON.stringify)
     *   socket.emit("hello", 1, "2", { 3: ["4"], 5: Buffer.from([6]) });
     *
     *   // with an acknowledgement from the client
     *   socket.emit("hello", "world", (val) => {
     *     // ...
     *   });
     * });
     *
     * @return Always returns `true`.
     */
    emit(ev, ...args) {
        if (exports.RESERVED_EVENTS.has(ev)) {
            throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        const data = [ev, ...args];
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: data,
        };
        // access last argument to see if it's an ACK callback
        if (typeof data[data.length - 1] === "function") {
            const id = this.nsp._ids++;
            debug("emitting packet with ack id %d", id);
            this.registerAckCallback(id, data.pop());
            packet.id = id;
        }
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        // @ts-ignore
        if (this.nsp.server.opts.connectionStateRecovery) {
            // this ensures the packet is stored and can be transmitted upon reconnection
            this.adapter.broadcast(packet, {
                rooms: new Set([this.id]),
                except: new Set(),
                flags,
            });
        }
        else {
            this.notifyOutgoingListeners(packet);
            this.packet(packet, flags);
        }
        return true;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * io.on("connection", async (socket) => {
     *   // without timeout
     *   const response = await socket.emitWithAck("hello", "world");
     *
     *   // with a specific timeout
     *   try {
     *     const response = await socket.timeout(1000).emitWithAck("hello", "world");
     *   } catch (err) {
     *     // the client did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @return a Promise that will be fulfilled when the client acknowledges the event
     */
    emitWithAck(ev, ...args) {
        // the timeout flag is optional
        const withErr = this.flags.timeout !== undefined;
        return new Promise((resolve, reject) => {
            args.push((arg1, arg2) => {
                if (withErr) {
                    return arg1 ? reject(arg1) : resolve(arg2);
                }
                else {
                    return resolve(arg1);
                }
            });
            this.emit(ev, ...args);
        });
    }
    /**
     * @private
     */
    registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === undefined) {
            this.acks.set(id, ack);
            return;
        }
        const timer = setTimeout(() => {
            debug("event with ack id %d has timed out after %d ms", id, timeout);
            this.acks.delete(id);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks.set(id, (...args) => {
            clearTimeout(timer);
            ack.apply(this, [null, ...args]);
        });
    }
    /**
     * Targets a room when broadcasting.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // the foo event will be broadcast to all connected clients in the room-101 room, except this socket
     *   socket.to("room-101").emit("foo", "bar");
     *
     *   // the code above is equivalent to:
     *   io.to("room-101").except(socket.id).emit("foo", "bar");
     *
     *   // with an array of rooms (a client will be notified at most once)
     *   socket.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     *   // with multiple chained calls
     *   socket.to("room-101").to("room-102").emit("foo", "bar");
     * });
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
        return this.newBroadcastOperator().to(room);
    }
    /**
     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * io.on("connection", (socket) => {
     *   // disconnect all clients in the "room-101" room, except this socket
     *   socket.in("room-101").disconnectSockets();
     * });
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
        return this.newBroadcastOperator().in(room);
    }
    /**
     * Excludes a room when broadcasting.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     *   // and this socket
     *   socket.except("room-101").emit("foo", "bar");
     *
     *   // with an array of rooms
     *   socket.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     *   // with multiple chained calls
     *   socket.except("room-101").except("room-102").emit("foo", "bar");
     * });
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
        return this.newBroadcastOperator().except(room);
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.send("hello");
     *
     *   // this is equivalent to
     *   socket.emit("message", "hello");
     * });
     *
     * @return self
     */
    send(...args) {
        this.emit("message", ...args);
        return this;
    }
    /**
     * Sends a `message` event. Alias of {@link send}.
     *
     * @return self
     */
    write(...args) {
        this.emit("message", ...args);
        return this;
    }
    /**
     * Writes a packet.
     *
     * @param {Object} packet - packet object
     * @param {Object} opts - options
     * @private
     */
    packet(packet, opts = {}) {
        packet.nsp = this.nsp.name;
        opts.compress = false !== opts.compress;
        this.client._packet(packet, opts);
    }
    /**
     * Joins a room.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // join a single room
     *   socket.join("room1");
     *
     *   // join multiple rooms
     *   socket.join(["room1", "room2"]);
     * });
     *
     * @param {String|Array} rooms - room or array of rooms
     * @return a Promise or nothing, depending on the adapter
     */
    join(rooms) {
        debug("join room %s", rooms);
        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
    }
    /**
     * Leaves a room.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // leave a single room
     *   socket.leave("room1");
     *
     *   // leave multiple rooms
     *   socket.leave("room1").leave("room2");
     * });
     *
     * @param {String} room
     * @return a Promise or nothing, depending on the adapter
     */
    leave(room) {
        debug("leave room %s", room);
        return this.adapter.del(this.id, room);
    }
    /**
     * Leave all rooms.
     *
     * @private
     */
    leaveAll() {
        this.adapter.delAll(this.id);
    }
    /**
     * Called by `Namespace` upon successful
     * middleware execution (ie: authorization).
     * Socket is added to namespace array before
     * call to join, so adapters can access it.
     *
     * @private
     */
    _onconnect() {
        debug("socket connected - writing packet");
        this.connected = true;
        this.join(this.id);
        if (this.conn.protocol === 3) {
            this.packet({ type: socket_io_parser_1.PacketType.CONNECT });
        }
        else {
            this.packet({
                type: socket_io_parser_1.PacketType.CONNECT,
                data: { sid: this.id, pid: this.pid },
            });
        }
    }
    /**
     * Called with each packet. Called by `Client`.
     *
     * @param {Object} packet
     * @private
     */
    _onpacket(packet) {
        debug("got packet %j", packet);
        switch (packet.type) {
            case socket_io_parser_1.PacketType.EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
        }
    }
    /**
     * Called upon event packet.
     *
     * @param {Packet} packet - packet object
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        this.dispatch(args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @param {Number} id - packet id
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function () {
            // prevent double callbacks
            if (sent)
                return;
            const args = Array.prototype.slice.call(arguments);
            debug("sending ack %j", args);
            self.packet({
                id: id,
                type: socket_io_parser_1.PacketType.ACK,
                data: args,
            });
            sent = true;
        };
    }
    /**
     * Called upon ack packet.
     *
     * @private
     */
    onack(packet) {
        const ack = this.acks.get(packet.id);
        if ("function" == typeof ack) {
            debug("calling ack %s with %j", packet.id, packet.data);
            ack.apply(this, packet.data);
            this.acks.delete(packet.id);
        }
        else {
            debug("bad ack %s", packet.id);
        }
    }
    /**
     * Called upon client disconnect packet.
     *
     * @private
     */
    ondisconnect() {
        debug("got disconnect packet");
        this._onclose("client namespace disconnect");
    }
    /**
     * Handles a client error.
     *
     * @private
     */
    _onerror(err) {
        // FIXME the meaning of the "error" event is overloaded:
        //  - it can be sent by the client (`socket.emit("error")`)
        //  - it can be emitted when the connection encounters an error (an invalid packet for example)
        //  - it can be emitted when a packet is rejected in a middleware (`socket.use()`)
        this.emitReserved("error", err);
    }
    /**
     * Called upon closing. Called by `Client`.
     *
     * @param {String} reason
     * @param description
     * @throw {Error} optional error object
     *
     * @private
     */
    _onclose(reason, description) {
        if (!this.connected)
            return this;
        debug("closing socket - reason %s", reason);
        this.emitReserved("disconnecting", reason, description);
        if (this.server._opts.connectionStateRecovery &&
            RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
            debug("connection state recovery is enabled for sid %s", this.id);
            this.adapter.persistSession({
                sid: this.id,
                pid: this.pid,
                rooms: [...this.rooms],
                data: this.data,
            });
        }
        this._cleanup();
        this.client._remove(this);
        this.connected = false;
        this.emitReserved("disconnect", reason, description);
        return;
    }
    /**
     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room
     *
     * @private
     */
    _cleanup() {
        this.leaveAll();
        this.nsp._remove(this);
        this.join = noop;
    }
    /**
     * Produces an `error` packet.
     *
     * @param {Object} err - error object
     *
     * @private
     */
    _error(err) {
        this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });
    }
    /**
     * Disconnects this client.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // disconnect this socket (the connection might be kept alive for other namespaces)
     *   socket.disconnect();
     *
     *   // disconnect this socket and close the underlying connection
     *   socket.disconnect(true);
     * })
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return self
     */
    disconnect(close = false) {
        if (!this.connected)
            return this;
        if (close) {
            this.client._disconnect();
        }
        else {
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
            this._onclose("server namespace disconnect");
        }
        return this;
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.compress(false).emit("hello");
     * });
     *
     * @param {Boolean} compress - if `true`, compresses the sending data
     * @return {Socket} self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.volatile.emit("hello"); // the client may or may not receive it
     * });
     *
     * @return {Socket} self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the
     * sender.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // the foo event will be broadcast to all connected clients, except this socket
     *   socket.broadcast.emit("foo", "bar");
     * });
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get broadcast() {
        return this.newBroadcastOperator();
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // the foo event will be broadcast to all connected clients on this node, except this socket
     *   socket.local.emit("foo", "bar");
     * });
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
        return this.newBroadcastOperator().local;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the client:
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.timeout(5000).emit("my-event", (err) => {
     *     if (err) {
     *       // the client did not acknowledge the event in the given delay
     *     }
     *   });
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Dispatch incoming event to socket listeners.
     *
     * @param {Array} event - event that will get emitted
     * @private
     */
    dispatch(event) {
        debug("dispatching an event %j", event);
        this.run(event, (err) => {
            process.nextTick(() => {
                if (err) {
                    return this._onerror(err);
                }
                if (this.connected) {
                    super.emitUntyped.apply(this, event);
                }
                else {
                    debug("ignore packet received after disconnection");
                }
            });
        });
    }
    /**
     * Sets up socket middleware.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.use(([event, ...args], next) => {
     *     if (isUnauthorized(event)) {
     *       return next(new Error("unauthorized event"));
     *     }
     *     // do not forget to call next
     *     next();
     *   });
     *
     *   socket.on("error", (err) => {
     *     if (err && err.message === "unauthorized event") {
     *       socket.disconnect();
     *     }
     *   });
     * });
     *
     * @param {Function} fn - middleware function (event, next)
     * @return {Socket} self
     */
    use(fn) {
        this.fns.push(fn);
        return this;
    }
    /**
     * Executes the middleware for an incoming event.
     *
     * @param {Array} event - event that will get emitted
     * @param {Function} fn - last fn call in the middleware
     * @private
     */
    run(event, fn) {
        const fns = this.fns.slice(0);
        if (!fns.length)
            return fn(null);
        function run(i) {
            fns[i](event, function (err) {
                // upon error, short-circuit
                if (err)
                    return fn(err);
                // if no middleware left, summon callback
                if (!fns[i + 1])
                    return fn(null);
                // go on to next
                run(i + 1);
            });
        }
        run(0);
    }
    /**
     * Whether the socket is currently disconnected
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * A reference to the request that originated the underlying Engine.IO Socket.
     */
    get request() {
        return this.client.request;
    }
    /**
     * A reference to the underlying Client transport connection (Engine.IO Socket object).
     *
     * @example
     * io.on("connection", (socket) => {
     *   console.log(socket.conn.transport.name); // prints "polling" or "websocket"
     *
     *   socket.conn.once("upgrade", () => {
     *     console.log(socket.conn.transport.name); // prints "websocket"
     *   });
     * });
     */
    get conn() {
        return this.client.conn;
    }
    /**
     * Returns the rooms the socket is currently in.
     *
     * @example
     * io.on("connection", (socket) => {
     *   console.log(socket.rooms); // Set { <socket.id> }
     *
     *   socket.join("room1");
     *
     *   console.log(socket.rooms); // Set { <socket.id>, "room1" }
     * });
     */
    get rooms() {
        return this.adapter.socketRooms(this.id) || new Set();
    }
    /**
     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to
     * the callback.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.onAny((event, ...args) => {
     *     console.log(`got event ${event}`);
     *   });
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to
     * the callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is received.
     *
     * @example
     * io.on("connection", (socket) => {
     *   const catchAllListener = (event, ...args) => {
     *     console.log(`got event ${event}`);
     *   }
     *
     *   socket.onAny(catchAllListener);
     *
     *   // remove a specific listener
     *   socket.offAny(catchAllListener);
     *
     *   // or remove all listeners
     *   socket.offAny();
     * });
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to
     * the callback.
     *
     * Note: acknowledgements sent to the client are not included.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.onAnyOutgoing((event, ...args) => {
     *     console.log(`sent event ${event}`);
     *   });
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.prependAnyOutgoing((event, ...args) => {
     *     console.log(`sent event ${event}`);
     *   });
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is sent.
     *
     * @example
     * io.on("connection", (socket) => {
     *   const catchAllListener = (event, ...args) => {
     *     console.log(`sent event ${event}`);
     *   }
     *
     *   socket.onAnyOutgoing(catchAllListener);
     *
     *   // remove a specific listener
     *   socket.offAnyOutgoing(catchAllListener);
     *
     *   // or remove all listeners
     *   socket.offAnyOutgoing();
     * });
     *
     * @param listener - the catch-all listener
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent (emit or broadcast)
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
    newBroadcastOperator() {
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);
    }
}
exports.Socket = Socket;


/***/ }),

/***/ "../../node_modules/socket.io/dist/typed-events.js":
/*!*********************************************************!*\
  !*** ../../node_modules/socket.io/dist/typed-events.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StrictEventEmitter = void 0;
const events_1 = __webpack_require__(/*! events */ "events");
/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */
class StrictEventEmitter extends events_1.EventEmitter {
    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    on(ev, listener) {
        return super.on(ev, listener);
    }
    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    once(ev, listener) {
        return super.once(ev, listener);
    }
    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */
    emit(ev, ...args) {
        return super.emit(ev, ...args);
    }
    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */
    emitReserved(ev, ...args) {
        return super.emit(ev, ...args);
    }
    /**
     * Emits an event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can get around the strict typing. This is useful for
     * calling `emit.apply`, which can be called as `emitUntyped.apply`.
     *
     * @param ev Event name
     * @param args Arguments to emit along with the event
     */
    emitUntyped(ev, ...args) {
        return super.emit(ev, ...args);
    }
    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */
    listeners(event) {
        return super.listeners(event);
    }
}
exports.StrictEventEmitter = StrictEventEmitter;


/***/ }),

/***/ "../../node_modules/socket.io/dist/uws.js":
/*!************************************************!*\
  !*** ../../node_modules/socket.io/dist/uws.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serveFile = exports.restoreAdapter = exports.patchAdapter = void 0;
const socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ "../../node_modules/socket.io-adapter/dist/index.js");
const fs_1 = __webpack_require__(/*! fs */ "fs");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "../../node_modules/socket.io/node_modules/debug/src/index.js"));
const debug = (0, debug_1.default)("socket.io:adapter-uws");
const SEPARATOR = "\x1f"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;
function patchAdapter(app /* : TemplatedApp */) {
    socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {
        const isNew = !this.sids.has(id);
        addAll.call(this, id, rooms);
        const socket = this.nsp.sockets.get(id);
        if (!socket) {
            return;
        }
        if (socket.conn.transport.name === "websocket") {
            subscribe(this.nsp.name, socket, isNew, rooms);
            return;
        }
        if (isNew) {
            socket.conn.on("upgrade", () => {
                const rooms = this.sids.get(id);
                if (rooms) {
                    subscribe(this.nsp.name, socket, isNew, rooms);
                }
            });
        }
    };
    socket_io_adapter_1.Adapter.prototype.del = function (id, room) {
        del.call(this, id, room);
        const socket = this.nsp.sockets.get(id);
        if (socket && socket.conn.transport.name === "websocket") {
            // @ts-ignore
            const sessionId = socket.conn.id;
            // @ts-ignore
            const websocket = socket.conn.transport.socket;
            const topic = `${this.nsp.name}${SEPARATOR}${room}`;
            debug("unsubscribe connection %s from topic %s", sessionId, topic);
            websocket.unsubscribe(topic);
        }
    };
    socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {
        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;
        if (!useFastPublish) {
            broadcast.call(this, packet, opts);
            return;
        }
        const flags = opts.flags || {};
        const basePacketOpts = {
            preEncoded: true,
            volatile: flags.volatile,
            compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        const encodedPackets = this.encoder.encode(packet);
        const topic = opts.rooms.size === 0
            ? this.nsp.name
            : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;
        debug("fast publish to %s", topic);
        // fast publish for clients connected with WebSocket
        encodedPackets.forEach((encodedPacket) => {
            const isBinary = typeof encodedPacket !== "string";
            // "4" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol
            app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
        });
        this.apply(opts, (socket) => {
            if (socket.conn.transport.name !== "websocket") {
                // classic publish for clients connected with HTTP long-polling
                socket.client.writeToEngine(encodedPackets, basePacketOpts);
            }
        });
    };
}
exports.patchAdapter = patchAdapter;
function subscribe(namespaceName, socket, isNew, rooms) {
    // @ts-ignore
    const sessionId = socket.conn.id;
    // @ts-ignore
    const websocket = socket.conn.transport.socket;
    if (isNew) {
        debug("subscribe connection %s to topic %s", sessionId, namespaceName);
        websocket.subscribe(namespaceName);
    }
    rooms.forEach((room) => {
        const topic = `${namespaceName}${SEPARATOR}${room}`; // '#' can be used as wildcard
        debug("subscribe connection %s to topic %s", sessionId, topic);
        websocket.subscribe(topic);
    });
}
function restoreAdapter() {
    socket_io_adapter_1.Adapter.prototype.addAll = addAll;
    socket_io_adapter_1.Adapter.prototype.del = del;
    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
}
exports.restoreAdapter = restoreAdapter;
const toArrayBuffer = (buffer) => {
    const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;
    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
};
// imported from https://github.com/kolodziejczak-sz/uwebsocket-serve
function serveFile(res /* : HttpResponse */, filepath) {
    const { size } = (0, fs_1.statSync)(filepath);
    const readStream = (0, fs_1.createReadStream)(filepath);
    const destroyReadStream = () => !readStream.destroyed && readStream.destroy();
    const onError = (error) => {
        destroyReadStream();
        throw error;
    };
    const onDataChunk = (chunk) => {
        const arrayBufferChunk = toArrayBuffer(chunk);
        const lastOffset = res.getWriteOffset();
        const [ok, done] = res.tryEnd(arrayBufferChunk, size);
        if (!done && !ok) {
            readStream.pause();
            res.onWritable((offset) => {
                const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
                if (!done && ok) {
                    readStream.resume();
                }
                return ok;
            });
        }
    };
    res.onAborted(destroyReadStream);
    readStream
        .on("data", onDataChunk)
        .on("error", onError)
        .on("end", destroyReadStream);
}
exports.serveFile = serveFile;


/***/ }),

/***/ "../../node_modules/@socket.io/component-emitter/index.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@socket.io/component-emitter/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Emitter: () => (/* binding */ Emitter)
/* harmony export */ });
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "../../node_modules/mediasoup/node_modules/supports-color/index.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mediasoup/node_modules/supports-color/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSupportsColor: () => (/* binding */ createSupportsColor),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:os */ "node:os");
/* harmony import */ var node_tty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:tty */ "node:tty");




// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : node_process__WEBPACK_IMPORTED_MODULE_0__.argv) {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}

const {env} = node_process__WEBPACK_IMPORTED_MODULE_0__;

let flagForceColor;
if (
	hasFlag('no-color')
	|| hasFlag('no-colors')
	|| hasFlag('color=false')
	|| hasFlag('color=never')
) {
	flagForceColor = 0;
} else if (
	hasFlag('color')
	|| hasFlag('colors')
	|| hasFlag('color=true')
	|| hasFlag('color=always')
) {
	flagForceColor = 1;
}

function envForceColor() {
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			return 1;
		}

		if (env.FORCE_COLOR === 'false') {
			return 0;
		}

		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3,
	};
}

function _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m')
			|| hasFlag('color=full')
			|| hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	// Check for Azure DevOps pipelines.
	// Has to be above the `!streamIsTTY` check.
	if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
		return 1;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = node_os__WEBPACK_IMPORTED_MODULE_1__.release().split('.');
		if (
			Number(osRelease[0]) >= 10
			&& Number(osRelease[2]) >= 10_586
		) {
			return Number(osRelease[2]) >= 14_931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if ('GITHUB_ACTIONS' in env || 'GITEA_ACTIONS' in env) {
			return 3;
		}

		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if (env.TERM === 'xterm-kitty') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app': {
				return version >= 3 ? 3 : 2;
			}

			case 'Apple_Terminal': {
				return 2;
			}
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function createSupportsColor(stream, options = {}) {
	const level = _supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options,
	});

	return translateLevel(level);
}

const supportsColor = {
	stdout: createSupportsColor({isTTY: node_tty__WEBPACK_IMPORTED_MODULE_2__.isatty(1)}),
	stderr: createSupportsColor({isTTY: node_tty__WEBPACK_IMPORTED_MODULE_2__.isatty(2)}),
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (supportsColor);


/***/ }),

/***/ "../../node_modules/socket.io/wrapper.mjs":
/*!************************************************!*\
  !*** ../../node_modules/socket.io/wrapper.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Namespace: () => (/* binding */ Namespace),
/* harmony export */   Server: () => (/* binding */ Server),
/* harmony export */   Socket: () => (/* binding */ Socket)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "../../node_modules/socket.io/dist/index.js");


const {Server, Namespace, Socket} = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__;


/***/ }),

/***/ "../../node_modules/mediasoup/package.json":
/*!*************************************************!*\
  !*** ../../node_modules/mediasoup/package.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"mediasoup","version":"3.13.19","description":"Cutting Edge WebRTC Video Conferencing","contributors":["Iaki Baz Castillo <ibc@aliax.net> (https://inakibaz.me)","Jos Luis Milln <jmillan@aliax.net> (https://github.com/jmillan)","Nazar Mokynskyi (https://github.com/nazar-pc)"],"license":"ISC","homepage":"https://mediasoup.org","repository":{"type":"git","url":"git+https://github.com/versatica/mediasoup.git"},"funding":{"type":"opencollective","url":"https://opencollective.com/mediasoup"},"main":"node/lib/index.js","types":"node/lib/index.d.ts","files":["node/lib","worker/deps/libwebrtc","worker/fbs","worker/fuzzer/include","worker/fuzzer/src","worker/include","worker/src","worker/scripts/*.json","worker/scripts/*.mjs","worker/scripts/*.py","worker/scripts/*.sh","worker/subprojects/*.wrap","worker/test/include","worker/test/src","worker/meson.build","worker/meson_options.txt","worker/tasks.py","npm-scripts.mjs"],"engines":{"node":">=16"},"keywords":["webrtc","ortc","sfu","nodejs"],"scripts":{"prepare":"node npm-scripts.mjs prepare","postinstall":"node npm-scripts.mjs postinstall","typescript:build":"node npm-scripts.mjs typescript:build","typescript:watch":"node npm-scripts.mjs typescript:watch","worker:build":"node npm-scripts.mjs worker:build","worker:prebuild":"node npm-scripts.mjs worker:prebuild","lint":"npm run lint:node && npm run lint:worker","lint:node":"node npm-scripts.mjs lint:node","lint:worker":"node npm-scripts.mjs lint:worker","format":"npm run format:node && npm run format:worker","format:node":"node npm-scripts.mjs format:node","format:worker":"node npm-scripts.mjs format:worker","flatc":"npm run flatc:node && npm run flatc:worker","flatc:node":"node npm-scripts.mjs flatc:node","flatc:worker":"node npm-scripts.mjs flatc:worker","test":"npm run test:node && npm run test:worker","test:node":"node npm-scripts.mjs test:node","test:worker":"node npm-scripts.mjs test:worker","coverage:node":"node npm-scripts.mjs coverage:node","release:check":"node npm-scripts.mjs release:check","release":"node npm-scripts.mjs release"},"jest":{"verbose":true,"testEnvironment":"node","testRegex":"node/src/test/test-.*\\\\.ts","transform":{"^.*\\\\.ts$":["ts-jest",{"diagnostics":{"ignoreCodes":["TS151001"]}}]},"coveragePathIgnorePatterns":["node/src/fbs","node/src/test"],"cacheDirectory":".cache/jest","modulePathIgnorePatterns":["worker","rust","target"]},"dependencies":{"debug":"^4.3.4","flatbuffers":"^23.5.26","h264-profile-level-id":"^2.0.0","node-fetch":"^3.3.2","supports-color":"^9.4.0","tar":"^6.2.0"},"devDependencies":{"@octokit/rest":"^20.0.2","@types/debug":"^4.1.12","@types/jest":"^29.5.12","@types/node":"^20.11.17","@typescript-eslint/eslint-plugin":"^6.21.0","@typescript-eslint/parser":"^6.21.0","eslint":"^8.56.0","eslint-config-prettier":"^9.1.0","eslint-plugin-jest":"^27.6.3","eslint-plugin-prettier":"^5.1.3","jest":"^29.7.0","marked":"^12.0.0","open-cli":"^8.0.0","pick-port":"^2.0.1","prettier":"^3.2.5","sctp":"^1.0.0","ts-jest":"^29.1.2","typescript":"^5.3.3"}}');

/***/ }),

/***/ "../../node_modules/mime-db/db.json":
/*!******************************************!*\
  !*** ../../node_modules/mime-db/db.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ "../../node_modules/socket.io/package.json":
/*!*************************************************!*\
  !*** ../../node_modules/socket.io/package.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"socket.io","version":"4.7.4","description":"node.js realtime framework server","keywords":["realtime","framework","websocket","tcp","events","socket","io"],"files":["dist/","client-dist/","wrapper.mjs","!**/*.tsbuildinfo"],"directories":{"doc":"docs/","example":"example/","lib":"lib/","test":"test/"},"type":"commonjs","main":"./dist/index.js","exports":{"types":"./dist/index.d.ts","import":"./wrapper.mjs","require":"./dist/index.js"},"types":"./dist/index.d.ts","license":"MIT","repository":{"type":"git","url":"git://github.com/socketio/socket.io"},"scripts":{"compile":"rimraf ./dist && tsc","test":"npm run format:check && npm run compile && npm run test:types && npm run test:unit","test:types":"tsd","test:unit":"nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts","format:check":"prettier --check \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","format:fix":"prettier --write \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","prepack":"npm run compile"},"dependencies":{"accepts":"~1.3.4","base64id":"~2.0.0","cors":"~2.8.5","debug":"~4.3.2","engine.io":"~6.5.2","socket.io-adapter":"~2.5.2","socket.io-parser":"~4.2.4"},"devDependencies":{"@types/mocha":"^9.0.0","expect.js":"0.3.1","mocha":"^10.0.0","nyc":"^15.1.0","prettier":"^2.3.2","rimraf":"^3.0.2","socket.io-client":"4.7.4","socket.io-client-v2":"npm:socket.io-client@^2.4.0","superagent":"^8.0.0","supertest":"^6.1.6","ts-node":"^10.2.1","tsd":"^0.27.0","typescript":"^4.4.2","uWebSockets.js":"github:uNetworking/uWebSockets.js#v20.30.0"},"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"engines":{"node":">=10.2.0"},"tsd":{"directory":"test"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const run = () => __awaiter(void 0, void 0, void 0, function* () {
    yield _server__WEBPACK_IMPORTED_MODULE_0__.Server.create();
});
run();

})();

/******/ })()
;